using System;
using System.Collections.Generic;
using System.Linq;
using Sonoria.MusicTheory.Timeline;
using Sonoria.MusicTheory.Diagnostics;

namespace Sonoria.MusicTheory
{
    /// <summary>
    /// Represents a chord event in a progression context.
    /// Used as input for voicing functions.
    /// </summary>
    public struct ChordEvent
    {
        /// <summary>
        /// The key/mode context for this chord.
        /// </summary>
        public TheoryKey Key;

        /// <summary>
        /// The chord recipe (degree, quality, extension, etc.).
        /// </summary>
        public ChordRecipe Recipe;

        /// <summary>
        /// Position in beats (for future use in progression voice-leading).
        /// </summary>
        public float TimeBeats;

        /// <summary>
        /// Optional melody note to lock to top voice (unused in Phase 1).
        /// Will be used later for melody-harmonization.
        /// </summary>
        public int? MelodyMidi;
    }

    /// <summary>
    /// Represents a chord voiced into multiple parts (SATB-style).
    /// </summary>
    public struct VoicedChord
    {
        /// <summary>
        /// Position in beats (copied from ChordEvent).
        /// </summary>
        public float TimeBeats;

        /// <summary>
        /// MIDI notes for each voice, low-to-high: [bass, tenor, alto, soprano] for 4 voices.
        /// Length is 3 or 4 depending on numVoices parameter.
        /// </summary>
        public int[] VoicesMidi;
    }

    /// <summary>
    /// Settings for Play button voicing continuity and register control.
    /// Used to tame awkward leaps and extreme registers in the simple Play path (no melody).
    /// </summary>
    public struct PlayVoicingSettings
    {
        /// <summary>
        /// Maximum allowed leap in semitones between consecutive chords (e.g., 9 = a 6th).
        /// </summary>
        public int MaxLeapSemitones;

        /// <summary>
        /// Minimum MIDI note for each voice.
        /// Indexed from top voice (0 = soprano) to bottom voice (3 = bass).
        /// </summary>
        public int[] MinMidiByVoice;

        /// <summary>
        /// Maximum MIDI note for each voice.
        /// Indexed from top voice (0 = soprano) to bottom voice (3 = bass).
        /// </summary>
        public int[] MaxMidiByVoice;
    }

    /// <summary>
    /// Static class providing voicing functions for chords.
    /// Phase 1: Simple block voicing for individual chords.
    /// Phase 2: Progression voice-leading with soft tonal tendency rules.
    /// 
    /// Voice-leading includes soft preferences for classical patterns:
    /// - Chord 7ths prefer to resolve down by step
    /// - Global leading tone (degree 7) prefers to resolve up to tonic (when appropriate)
    /// - Local leading tone (3rd of secondary dominants) prefers to resolve up to target root
    /// These are SOFT biases that enhance but do not override basic distance-based voice-leading.
    /// </summary>
    public static class TheoryVoicing
    {
        /// <summary>
        /// Debug flag to enable logging of tendency rule decisions.
        /// When true, logs cases where tendencies exist but textbook resolution wasn't chosen.
        /// </summary>
        private static bool enableTendencyDebug = false;
        private static bool enableTraceLogs = true; // Enable trace logs for debugging non-chord tones
        private static bool enableVoicingPathDebug = false; // Enable voicing path and weight logging
        private static bool enableFullSearchDebugSummary = false; // Enable full search candidate count and cost breakdown logging
        private static bool s_enableHardPruneDebug = false; // Enable hard constraint pruning debug counters
        private static bool s_useFullSearchEveryChord = false; // Force full search for every chord in melody-constrained voicing
        private static bool enableTraceNonChordDebug = true; // Enable narrow trace for regions 2 and 5
        public static bool s_debugTensionDetect = false; // Enable tension detection debug logging
        
        private static bool s_debugTensionVerbose = false; // Enable verbose per-candidate/per-step tension diagnostics (investigative only)
        private static bool s_debugSharp9OctaveTrace = false; // Enable #9 octave selection tracing (for G7#9 octave jump investigation)
        private static bool s_enableAug5Debug = false; // Enable augmented 5th resolution debugging
        private static bool s_enableSatbNoCrossingDebug = false; // Enable SATB no-crossing constraint debugging
        
        /// <summary>
        /// Placement policy for requested extensions (9, b9, #11, etc.)
        /// </summary>
        public enum RequestedExtensionPlacementMode
        {
            AnyVoice,        // Extensions can appear in any voice (jazzy clusters allowed)
            PreferSoprano,   // Prefer melodic tensions in soprano, add-tones in inner voices
            ForceSoprano     // Force melodic tensions to appear in soprano (constrain candidates)
        }
        
        private static RequestedExtensionPlacementMode s_extensionPlacementMode = RequestedExtensionPlacementMode.PreferSoprano;
        
        // ========================================================================
        // TONAL TENDENCY RULE CONSTANTS
        // ========================================================================
        
        // Rule A: Chord 7th resolution
        private const float SeventhResolutionDownStepBonus = -3.5f;
        private const float SeventhResolutionHoldPenalty = +2.0f;
        private const float SeventhResolutionLargeLeapPenalty = +0.5f;
        
        // Rule A: Strong resolution bonuses/penalties when step-down resolution exists
        private const float SeventhResolutionDownStrongBonus = -8.0f;  // Increased from -6.0f for stronger preference
        private const float SeventhResolutionAvoidPenalty = +10.0f;   // Increased from +6.0f to strongly penalize upward motion when resolution available
        
        // Rule A: Normal 7th resolution (no melody doubling) - stepwise downward resolution
        // These can be set from ChordLabController to allow Inspector adjustment
        private static float seventhResolutionDownStepBonusNormal = -6.0f;
        private static float seventhResolutionAvoidPenaltyNormal = +6.0f;
        
        // #11 resolution tendency: strong on dominant, weak on maj/maj7
        // These can be set from ChordLabController to allow Inspector adjustment
        private static float sharp11ResolveUpBonus_Dominant = -4.0f;  // Strong preference for #11→5 resolution on dominant
        private static float sharp11ResolveUpBonus_Maj7 = -0.5f;      // Weak preference for #11→5 resolution on maj/maj7 (Lydian color)
        
        // Augmented 5th resolution (up by semitone)
        // Default weight similar to 7th resolution - strong but not overwhelming
        private static float augmentedFifthResolutionWeight = 1.5f;
        
        // Rule A special case: 7th resolution with melody doubling
        private const float SeventhResolutionWithMelodyDoubleBonus = -4.0f;
        private const float SeventhResolutionWithMelodyDoublePenalty = +4.0f;
        
        // Rule A hard constraint: 7th resolution (non-soprano only, when valid resolution exists)
        private const float SeventhResolutionDownStepBonusHard = -10.0f;
        private const float SeventhResolutionHardPenalty = +1000.0f;
        
        // 9th resolution tendencies: soft preferences for stepwise resolution
        // b9 (flat 9): strong preference to resolve down by 1 semitone
        private static float ninthResolutionFlat9DownBonus = -5.0f;  // Strong bonus for b9 resolving down
        
        // 9 (natural 9): whole-step resolution (mirrors b9 but whole-step)
        private static float ninthResolutionNatural9DownBonus = -5.0f;  // Strong bonus for 9 resolving down by whole-step (X-2)
        private static float ninthResolutionNatural9UpBonus = -3.0f;   // Weaker bonus for 9 resolving up by whole-step (X+2)
        private static float ninthResolutionNatural9LeapPenalty = +8.0f; // Penalty for resolving 9 by leap (>= P4), especially in upper voices
        private static float ninthResolutionNatural9DoubleSeventhPenalty = +4.0f; // Soft penalty if up-step target is 7th and that PC is already present
        
        // #9 (sharp 9): strong preference to resolve up by 1 semitone
        private static float ninthResolutionSharp9UpBonus = -5.0f;  // Strong bonus for #9 resolving up
        
        // Voice crossing hard constraint: prevents Bass > Tenor, Tenor > Alto, Alto > Soprano
        private const float VoiceCrossingPenalty = +100000f; // Effectively vetoes candidates with voice crossing
        
        // Voice spacing hard constraints: maximum allowed intervals between adjacent voices
        private const int MaxSopranoAltoInterval = 12;  // One octave
        private const int MaxAltoTenorInterval = 12;   // One octave
        private const int MaxTenorBassInterval = 24;   // Two octaves
        
        // Absolute lower bound for Tenor (and inner voice range when needed)
        // E3 = 48. Prevents tenor dipping into "muddy" register while still allowing
        // reasonable downward resolutions.
        private const int TenorAbsoluteMinMidi = 48;
        
        // Soft compactness preferences (weights are intentionally small)
        // These can be set from ChordLabController to allow Inspector adjustment
        private static float compactnessWeightTenorBass = 0.15f;
        private static float compactnessWeightAltoTenor = 0.25f;
        
        // Add-tone bonuses (optional color tones - reward inclusion, no penalty for omission)
        private static float s_add9Bonus = -1.0f;  // Bonus when add9 is present in voicing
        private static float s_add11Bonus = -1.0f; // Bonus when add11 is present in voicing
        
        /// <summary>
        /// Sets the compactness weights for SATB voicing. Called from ChordLabController to allow Inspector adjustment.
        /// </summary>
        public static void SetCompactnessWeights(float tenorBass, float altoTenor)
        {
            compactnessWeightTenorBass = tenorBass;
            compactnessWeightAltoTenor = altoTenor;
        }
        
        /// <summary>
        /// Gets the current compactness weight for Tenor-Bass gap.
        /// </summary>
        public static float GetCompactnessWeightTenorBass() => compactnessWeightTenorBass;
        
        /// <summary>
        /// Gets the current compactness weight for Alto-Tenor gap.
        /// </summary>
        public static float GetCompactnessWeightAltoTenor() => compactnessWeightAltoTenor;
        
        // Register gravity & compression
        private static bool s_enableRegisterGravity = true;
        private static float s_tenorRegisterCenter = 55f;
        private static float s_altoRegisterCenter = 60f;
        private static float s_tenorRegisterWeight = 0.2f;
        private static float s_altoRegisterWeight = 0.3f;
        private static bool s_enableCompressionCost = true;
        private static float s_targetAltoTenorGap = 7f;
        private static float s_targetSopAltoGap = 7f;
        private static float s_compressionWeightAT = 0.5f;
        private static float s_compressionWeightSA = 0.5f;
        
        // Movement weighting (inner voices)
        private static bool s_enableMovementWeighting = true;
        private static float s_movementWeightInnerVoices = 1.0f;
        
        // Soprano tension preference (style preference, not enforcement)
        private static float s_preferRequestedTensionInSopranoWeight = 6.0f; // Default: moderate preference (4-10 range)
        
        /// <summary>
        /// Sets the weight for preferring requested tensions (9, b9, #11, etc.) in the soprano voice.
        /// This is a style preference (cost bonus) that encourages tensions in soprano when feasible.
        /// Only applies when melody is not active (soprano is not protected by melody).
        /// Default: 6.0 (moderate preference, breaks ties without overriding major constraints).
        /// </summary>
        public static void SetPreferRequestedTensionInSopranoWeight(float weight)
        {
            s_preferRequestedTensionInSopranoWeight = weight;
        }
        
        /// <summary>
        /// Gets the current weight for preferring requested tensions in soprano.
        /// </summary>
        public static float GetPreferRequestedTensionInSopranoWeight() => s_preferRequestedTensionInSopranoWeight;
        
        /// <summary>
        /// Sets the register gravity, compression, and movement weighting parameters.
        /// Called from ChordLabController to allow Inspector adjustment.
        /// </summary>
        public static void SetRegisterAndCompressionSettings(
            bool enableRegisterGravity,
            float tenorRegisterCenter,
            float altoRegisterCenter,
            float tenorRegisterWeight,
            float altoRegisterWeight,
            bool enableCompressionCost,
            float targetAltoTenorGap,
            float targetSopAltoGap,
            float compressionWeightAT,
            float compressionWeightSA,
            bool enableMovementWeighting,
            float movementWeightInnerVoices)
        {
            s_enableRegisterGravity = enableRegisterGravity;
            s_tenorRegisterCenter = tenorRegisterCenter;
            s_altoRegisterCenter = altoRegisterCenter;
            s_tenorRegisterWeight = Math.Max(0f, tenorRegisterWeight);
            s_altoRegisterWeight = Math.Max(0f, altoRegisterWeight);
            s_enableCompressionCost = enableCompressionCost;
            s_targetAltoTenorGap = Math.Max(0f, targetAltoTenorGap);
            s_targetSopAltoGap = Math.Max(0f, targetSopAltoGap);
            s_compressionWeightAT = Math.Max(0f, compressionWeightAT);
            s_compressionWeightSA = Math.Max(0f, compressionWeightSA);
            s_enableMovementWeighting = enableMovementWeighting;
            s_movementWeightInnerVoices = Math.Max(0f, movementWeightInnerVoices);
        }
        
        /// <summary>
        /// Sets the voice leading tendency parameters. Called from ChordLabController to allow Inspector adjustment.
        /// </summary>
        public static void SetVoiceLeadingTendencies(
            float seventhResolutionBonus,
            float seventhResolutionAvoidPenalty,
            float spacingPreferred,
            float spacingBassTenor,
            float augmentedFifthResolutionWeightParam = 1.5f)
        {
            seventhResolutionDownStepBonusNormal = seventhResolutionBonus;
            seventhResolutionAvoidPenaltyNormal = seventhResolutionAvoidPenalty;
            spacingPreferredPenalty = spacingPreferred;
            spacingBassTenorPenalty = spacingBassTenor;
            augmentedFifthResolutionWeight = augmentedFifthResolutionWeightParam;
        }
        
        /// <summary>
        /// Sets the #11 resolution tendency parameters. Called from ChordLabController to allow Inspector adjustment.
        /// </summary>
        public static void SetSharp11ResolutionTendencies(
            float dominantBonus,
            float maj7Bonus)
        {
            sharp11ResolveUpBonus_Dominant = dominantBonus;
            sharp11ResolveUpBonus_Maj7 = maj7Bonus;
        }
        
        /// <summary>
        /// Gets the current augmented 5th resolution weight.
        /// </summary>
        public static float GetAugmentedFifthResolutionWeight() => augmentedFifthResolutionWeight;
        
        /// <summary>
        /// Gets the current 7th resolution bonus value.
        /// </summary>
        public static float GetSeventhResolutionDownStepBonusNormal() => seventhResolutionDownStepBonusNormal;
        
        /// <summary>
        /// Sets the requested extension placement mode.
        /// </summary>
        public static void SetExtensionPlacementMode(RequestedExtensionPlacementMode mode)
        {
            s_extensionPlacementMode = mode;
        }
        
        /// <summary>
        /// Gets the current requested extension placement mode.
        /// </summary>
        public static RequestedExtensionPlacementMode GetExtensionPlacementMode() => s_extensionPlacementMode;
        
        /// <summary>
        /// Sets the add-tone bonus values (optional color tones).
        /// </summary>
        public static void SetAddToneBonuses(float add9Bonus, float add11Bonus)
        {
            s_add9Bonus = add9Bonus;
            s_add11Bonus = add11Bonus;
        }
        
        /// <summary>
        /// Computes soft bonus for optional add-tones (add9/add11) when present in voicing.
        /// Returns negative cost (bonus) if add-tones are present, 0 if missing (no penalty).
        /// </summary>
        private static float ComputeAddToneBonus(
            ChordEvent chordEvent,
            int? sopranoMidi,
            int? tenorMidi,
            int? altoMidi,
            int? candidateMidi,
            bool isSelectingTenor,
            bool isSelectingAlto,
            bool isSelectingSoprano)
        {
            var req = chordEvent.Recipe.RequestedExtensions;
            if (!req.Add9 && !req.Add11)
                return 0f;
            
            // Compute root PC
            int rootPc = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
            if (rootPc < 0) rootPc += 12;
            
            float bonus = 0f;
            bool add9Present = false;
            bool add11Present = false;
            
            // Check realized pitch classes
            var realizedPcs = new HashSet<int>();
            if (sopranoMidi.HasValue) realizedPcs.Add((sopranoMidi.Value % 12 + 12) % 12);
            if (tenorMidi.HasValue) realizedPcs.Add((tenorMidi.Value % 12 + 12) % 12);
            if (altoMidi.HasValue) realizedPcs.Add((altoMidi.Value % 12 + 12) % 12);
            if (candidateMidi.HasValue) realizedPcs.Add((candidateMidi.Value % 12 + 12) % 12);
            
            // Check add9
            if (req.Add9)
            {
                int add9Pc = (rootPc + 2) % 12;
                if (realizedPcs.Contains(add9Pc))
                {
                    bonus += s_add9Bonus;
                    add9Present = true;
                }
            }
            
            // Check add11
            if (req.Add11)
            {
                int add11Pc = (rootPc + 5) % 12;
                if (realizedPcs.Contains(add11Pc))
                {
                    bonus += s_add11Bonus;
                    add11Present = true;
                }
            }
            
            // Debug logging
            if (s_debugTensionDetect && (req.Add9 || req.Add11))
            {
                string selectingStr = isSelectingTenor ? "selectingTenor" : isSelectingAlto ? "selectingAlto" : isSelectingSoprano ? "selectingSoprano" : "complete";
                UnityEngine.Debug.Log(
                    $"[REQ_EXT_ADD_BONUS] {selectingStr} " +
                    $"add9={(add9Present ? "present" : "missing")} bonus={(add9Present ? s_add9Bonus : 0f):F2} " +
                    $"add11={(add11Present ? "present" : "missing")} bonus={(add11Present ? s_add11Bonus : 0f):F2} " +
                    $"totalBonus={bonus:F2}");
            }
            
            return bonus;
        }
        
        /// <summary>
        /// Computes cost adjustment for extension placement policy (PreferSoprano/ForceSoprano).
        /// Returns negative cost (bonus) for preferred placements, positive (penalty) for dispreferred.
        /// Can work with partial voicing (e.g., when selecting Tenor, only tenor and soprano may be known).
        /// </summary>
        private static float ComputeExtensionPlacementCostAdjustment(
            ChordEvent chordEvent,
            int? sopranoMidi,
            int? tenorMidi,
            int? altoMidi,
            int? candidateMidi,
            bool isSelectingTenor,
            bool isSelectingAlto,
            bool isSelectingSoprano,
            List<int> chordTonePcs)
        {
            var req = chordEvent.Recipe.RequestedExtensions;
            if (!req.HasAny || s_extensionPlacementMode == RequestedExtensionPlacementMode.AnyVoice)
                return 0f;
            
            // Determine which voices we know
            int? sopranoPc = sopranoMidi.HasValue ? (sopranoMidi.Value % 12 + 12) % 12 : (int?)null;
            int? tenorPc = tenorMidi.HasValue ? (tenorMidi.Value % 12 + 12) % 12 : (int?)null;
            int? altoPc = altoMidi.HasValue ? (altoMidi.Value % 12 + 12) % 12 : (int?)null;
            int? candidatePc = candidateMidi.HasValue ? (candidateMidi.Value % 12 + 12) % 12 : (int?)null;
            
            var innerVoicePcs = new HashSet<int>();
            if (tenorPc.HasValue) innerVoicePcs.Add(tenorPc.Value);
            if (altoPc.HasValue) innerVoicePcs.Add(altoPc.Value);
            
            // If we're selecting a voice, include the candidate in the appropriate set
            if (isSelectingTenor && candidatePc.HasValue)
            {
                innerVoicePcs.Add(candidatePc.Value);
            }
            else if (isSelectingAlto && candidatePc.HasValue)
            {
                innerVoicePcs.Add(candidatePc.Value);
            }
            else if (isSelectingSoprano && candidatePc.HasValue)
            {
                sopranoPc = candidatePc.Value;
            }
            
            // Compute root PC
            int rootPc = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
            if (rootPc < 0) rootPc += 12;
            
            float adjustment = 0f;
            
            // Melodic tensions: TensionSharp11, TensionFlat9, Tension9, TensionSharp9
            var melodicTensionPcs = new List<int>();
            var requestedTensionNames = new List<string>();
            if (req.TensionSharp11) { melodicTensionPcs.Add((rootPc + 6) % 12); requestedTensionNames.Add("#11"); }
            if (req.TensionFlat9) { melodicTensionPcs.Add((rootPc + 1) % 12); requestedTensionNames.Add("b9"); }
            if (req.Tension9) { melodicTensionPcs.Add((rootPc + 2) % 12); requestedTensionNames.Add("9"); }
            if (req.TensionSharp9) { melodicTensionPcs.Add((rootPc + 3) % 12); requestedTensionNames.Add("#9"); }
            
            var requestedInInner = new List<string>();
            var requestedInSoprano = new List<string>();
            
            if (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano)
            {
                // PreferSoprano: bonus if soprano matches melodic tension, penalty if only in inner voices
                for (int i = 0; i < melodicTensionPcs.Count; i++)
                {
                    int tensionPc = melodicTensionPcs[i];
                    string tensionName = requestedTensionNames[i];
                    bool inSoprano = sopranoPc.HasValue && (sopranoPc.Value == tensionPc);
                    bool inInner = innerVoicePcs.Contains(tensionPc);
                    
                    // When selecting Tenor: penalize if candidate is a melodic tension (should be in soprano)
                    if (isSelectingTenor && candidatePc.HasValue && candidatePc.Value == tensionPc)
                    {
                        adjustment += 1.5f; // Penalty for placing melodic tension in tenor
                        requestedInInner.Add(tensionName);
                    }
                    // When selecting Alto: penalize if candidate is a melodic tension (should be in soprano)
                    else if (isSelectingAlto && candidatePc.HasValue && candidatePc.Value == tensionPc)
                    {
                        adjustment += 1.5f; // Penalty for placing melodic tension in alto
                        requestedInInner.Add(tensionName);
                    }
                    // When selecting Soprano: bonus if candidate is a melodic tension
                    else if (isSelectingSoprano && candidatePc.HasValue && candidatePc.Value == tensionPc)
                    {
                        adjustment -= 2.0f; // Bonus for soprano placement
                        requestedInSoprano.Add(tensionName);
                    }
                    // When all voices are known: check final state
                    else if (sopranoPc.HasValue && !isSelectingTenor && !isSelectingAlto && !isSelectingSoprano)
                    {
                        if (inSoprano)
                        {
                            adjustment -= 2.0f; // Bonus for soprano placement
                            requestedInSoprano.Add(tensionName);
                        }
                        else if (inInner && !inSoprano)
                        {
                            adjustment += 1.5f; // Penalty if only in inner voices (not soprano)
                            requestedInInner.Add(tensionName);
                        }
                    }
                }
                
                // Add9/Add11: prefer inner voices (small bonus if in alto/tenor, small penalty if in soprano)
                if (req.Add9)
                {
                    int add9Pc = (rootPc + 2) % 12;
                    // When selecting Tenor or Alto: bonus if candidate is add9
                    if ((isSelectingTenor || isSelectingAlto) && candidatePc.HasValue && candidatePc.Value == add9Pc)
                    {
                        adjustment -= 0.5f; // Bonus for inner voice
                    }
                    // When selecting Soprano: small penalty if candidate is add9
                    else if (isSelectingSoprano && candidatePc.HasValue && candidatePc.Value == add9Pc)
                    {
                        adjustment += 0.3f; // Small penalty for soprano
                    }
                    // When all voices known: check final state
                    else if (sopranoPc.HasValue && !isSelectingTenor && !isSelectingAlto && !isSelectingSoprano)
                    {
                        if (innerVoicePcs.Contains(add9Pc))
                            adjustment -= 0.5f; // Bonus for inner voice
                        else if (sopranoPc.Value == add9Pc)
                            adjustment += 0.3f; // Small penalty for soprano
                    }
                }
                
                if (req.Add11)
                {
                    int add11Pc = (rootPc + 5) % 12;
                    // When selecting Tenor or Alto: bonus if candidate is add11
                    if ((isSelectingTenor || isSelectingAlto) && candidatePc.HasValue && candidatePc.Value == add11Pc)
                    {
                        adjustment -= 0.5f; // Bonus for inner voice
                    }
                    // When selecting Soprano: small penalty if candidate is add11
                    else if (isSelectingSoprano && candidatePc.HasValue && candidatePc.Value == add11Pc)
                    {
                        adjustment += 0.3f; // Small penalty for soprano
                    }
                    // When all voices known: check final state
                    else if (sopranoPc.HasValue && !isSelectingTenor && !isSelectingAlto && !isSelectingSoprano)
                    {
                        if (innerVoicePcs.Contains(add11Pc))
                            adjustment -= 0.5f; // Bonus for inner voice
                        else if (sopranoPc.Value == add11Pc)
                            adjustment += 0.3f; // Small penalty for soprano
                    }
                }
                
                // Sus4: bonus if 4th in upper voice (S/A/T), optional penalty if both 3rd and 4th present
                if (req.Sus4)
                {
                    int fourthPc = (rootPc + 5) % 12;
                    var allUpperPcs = new HashSet<int>(innerVoicePcs);
                    if (sopranoPc.HasValue) allUpperPcs.Add(sopranoPc.Value);
                    if (candidatePc.HasValue && (isSelectingTenor || isSelectingAlto || isSelectingSoprano))
                        allUpperPcs.Add(candidatePc.Value);
                    
                    if (allUpperPcs.Contains(fourthPc))
                    {
                        adjustment -= 1.0f; // Bonus for 4th in upper voice
                    }
                    
                    // Optional: mild penalty if both 3rd and 4th present (can be configurable later)
                    int thirdPc = chordTonePcs.Count > 1 ? chordTonePcs[1] : -1;
                    if (thirdPc >= 0 && allUpperPcs.Contains(thirdPc) && allUpperPcs.Contains(fourthPc))
                    {
                        adjustment += 0.5f; // Mild penalty for 3rd+4th clash
                    }
                }
            }
            // ForceSoprano is handled by constraining candidates (see GetSopranoCandidatesForForceMode)
            
            // Debug logging
            if (s_debugTensionDetect && (adjustment != 0f || requestedInSoprano.Count > 0 || requestedInInner.Count > 0 || requestedTensionNames.Count > 0))
            {
                string requestedStr = string.Join(",", requestedTensionNames);
                string inSopranoStr = requestedInSoprano.Count > 0 ? string.Join(",", requestedInSoprano) : "none";
                string inInnerStr = requestedInInner.Count > 0 ? string.Join(",", requestedInInner) : "none";
                
                // Build voice assignment string
                var voiceAssignments = new List<string>();
                for (int i = 0; i < melodicTensionPcs.Count; i++)
                {
                    int tensionPc = melodicTensionPcs[i];
                    string tensionName = requestedTensionNames[i];
                    string voice = "missing";
                    if (sopranoPc.HasValue && sopranoPc.Value == tensionPc) voice = "S";
                    else if (tenorPc.HasValue && tenorPc.Value == tensionPc) voice = "T";
                    else if (altoPc.HasValue && altoPc.Value == tensionPc) voice = "A";
                    else if (candidatePc.HasValue && candidatePc.Value == tensionPc)
                    {
                        if (isSelectingSoprano) voice = "S";
                        else if (isSelectingTenor) voice = "T";
                        else if (isSelectingAlto) voice = "A";
                    }
                    voiceAssignments.Add($"{tensionName}:{voice}");
                }
                
                string voiceAssignStr = voiceAssignments.Count > 0 ? string.Join(",", voiceAssignments) : "none";
                string selectingStr = isSelectingTenor ? "selectingTenor" : isSelectingAlto ? "selectingAlto" : isSelectingSoprano ? "selectingSoprano" : "complete";
                string sopranoInfo = sopranoPc.HasValue ? $"{sopranoPc.Value}" : "?";
                
                if (s_debugTensionVerbose)
                {
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_PLACE] mode={s_extensionPlacementMode} {selectingStr} " +
                        $"sopranoPc={sopranoInfo} tenorPc={(tenorPc.HasValue ? tenorPc.Value.ToString() : "?")} " +
                        $"altoPc={(altoPc.HasValue ? altoPc.Value.ToString() : "?")} " +
                        $"candidatePc={(candidatePc.HasValue ? candidatePc.Value.ToString() : "?")} " +
                        $"requested=[{requestedStr}] voices=[{voiceAssignStr}] " +
                        $"adjustment={adjustment:F2}");
                }
            }
            
            return adjustment;
        }
        
        /// <summary>
        /// Gets soprano candidate pitch classes when ForceSoprano mode is active.
        /// Returns list of melodic tension pitch classes (priority: #11 > b9 > 9 > 11).
        /// Returns null if ForceSoprano should not apply (no melodic tensions or sus4/add-only).
        /// </summary>
        private static List<int> GetSopranoCandidatePcsForForceMode(ChordEvent chordEvent)
        {
            if (s_extensionPlacementMode != RequestedExtensionPlacementMode.ForceSoprano)
                return null;
            
            var req = chordEvent.Recipe.RequestedExtensions;
            if (!req.HasAny)
                return null;
            
            // ForceSoprano only applies to melodic tensions, not sus4 or add-tones
            if (!req.TensionSharp11 && !req.TensionFlat9 && !req.Tension9 && !req.TensionSharp9)
                return null; // Only sus4/add-tones requested - don't force soprano
            
            // Compute root PC
            int rootPc = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
            if (rootPc < 0) rootPc += 12;
            
            // Priority order: #11 > b9 > #9 > 9 > 11
            var candidatePcs = new List<int>();
            if (req.TensionSharp11) candidatePcs.Add((rootPc + 6) % 12);
            if (req.TensionFlat9) candidatePcs.Add((rootPc + 1) % 12);
            if (req.TensionSharp9) candidatePcs.Add((rootPc + 3) % 12);
            if (req.Tension9) candidatePcs.Add((rootPc + 2) % 12);
            // Note: plain 11 (add11) is not forced to soprano
            
            return candidatePcs.Count > 0 ? candidatePcs : null;
        }
        
        /// <summary>
        /// Explicitly selects soprano for no-melody path, applying Force/Prefer Soprano policies.
        /// Returns selected soprano MIDI, or -1 if no valid candidate found.
        /// </summary>
        private static int SelectSopranoExplicitly(
            ChordEvent chordEvent,
            List<int> innerVoices, // Already selected tenor/alto
            int bassVoice,
            List<int> chordTonePcs,
            int upperMinMidi,
            int upperMaxMidi,
            int stepIndex,
            DiagnosticsCollector diags,
            ChordEvent? previousEvent = null,
            int previousSopranoMidi = -1,
            ChordFunctionProfile? previousAnalysis = null,
            ChordFunctionProfile? currentAnalysis = null)
        {
            var req = chordEvent.Recipe.RequestedExtensions;
            
            // Compute root PC
            int rootPc = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
            if (rootPc < 0) rootPc += 12;
            
            // Build soprano candidate set: chord tones + requested tension PCs
            // CRITICAL: b9 and 9 are mutually exclusive - if b9 is requested, do NOT include natural 9
            var sopranoCandidatePcs = new HashSet<int>(chordTonePcs);
            
            // Add requested tension PCs (mutually exclusive: b9, #9, and 9 are mutually exclusive)
            if (req.TensionFlat9)
            {
                // b9 requested: include ONLY b9Pc, NOT natural 9 or #9
                sopranoCandidatePcs.Add((rootPc + 1) % 12);
                // Explicitly do NOT add natural 9 or #9
            }
            else if (req.TensionSharp9)
            {
                // #9 requested (and not b9): include ONLY #9Pc
                sopranoCandidatePcs.Add((rootPc + 3) % 12);
            }
            else if (req.Tension9)
            {
                // Natural 9 requested (and not b9 or #9): include ONLY 9Pc
                sopranoCandidatePcs.Add((rootPc + 2) % 12);
            }
            
            if (req.TensionSharp11) sopranoCandidatePcs.Add((rootPc + 6) % 12);
            
            // Trace: Log soprano candidate construction (point 3)
            if (s_debugTensionDetect)
            {
                var requestedList = new List<string>();
                if (req.Tension9) requestedList.Add("9");
                if (req.TensionFlat9) requestedList.Add("b9");
                if (req.TensionSharp9) requestedList.Add("#9");
                if (req.TensionSharp11) requestedList.Add("#11");
                string requestedStr = requestedList.Count > 0 ? string.Join(",", requestedList) : "none";
                
                var melodicTensionPcs = new List<int>();
                if (req.TensionFlat9) melodicTensionPcs.Add((rootPc + 1) % 12);
                else if (req.TensionSharp9) melodicTensionPcs.Add((rootPc + 3) % 12);
                else if (req.Tension9) melodicTensionPcs.Add((rootPc + 2) % 12);
                if (req.TensionSharp11) melodicTensionPcs.Add((rootPc + 6) % 12);
                
                string beforeStr = string.Join(",", sopranoCandidatePcs.OrderBy(x => x));
                string melodicStr = melodicTensionPcs.Count > 0 ? string.Join(",", melodicTensionPcs) : "none";
                bool isExplicit = !chordEvent.MelodyMidi.HasValue;
                
                UnityEngine.Debug.Log(
                    $"[REQ_EXT_TRACE][SOPRANO_CANDIDATES] step={stepIndex} policy={s_extensionPlacementMode} explicit={isExplicit}\n" +
                    $"  before=[{beforeStr}]\n" +
                    $"  melodicTensions=[{melodicStr}]");
            }
            
            // Generate MIDI candidates for all soprano candidate PCs
            var sopranoCandidates = GenerateCandidatesInRange(new List<int>(sopranoCandidatePcs), upperMinMidi, upperMaxMidi);
            
            // INSTRUMENTATION: Debug logging for soprano candidate generation (b9 chords only)
            // Note: req is already declared above, so we reuse it
            bool hasB9 = req.TensionFlat9;
            bool shouldLogSopranoCandidates = hasB9 || 
                                             (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano && req.TensionFlat9);
            if (shouldLogSopranoCandidates)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                int rootPcForSopranoLog = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
                if (rootPcForSopranoLog < 0) rootPcForSopranoLog = 0;
                rootPcForSopranoLog = (rootPcForSopranoLog + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
                if (rootPcForSopranoLog < 0) rootPcForSopranoLog += 12;
                int b9Pc = (rootPcForSopranoLog + 1) % 12;
                
                // Check if any soprano candidates have the b9 PC
                var candidatesWithB9Pc = new List<int>();
                foreach (int candidate in sopranoCandidates)
                {
                    int candidatePc = (candidate % 12 + 12) % 12;
                    if (candidatePc == b9Pc)
                    {
                        candidatesWithB9Pc.Add(candidate);
                    }
                }
                
                string sopranoPcsStr = string.Join(",", sopranoCandidatePcs.OrderBy(x => x));
                string candidatesWithB9Str = candidatesWithB9Pc.Count > 0 
                    ? string.Join(",", candidatesWithB9Pc) 
                    : "none";
                
                UnityEngine.Debug.Log(
                    $"[SOPRANO_CANDIDATES] step={stepIndex} chord={chordLabel}\n" +
                    $"  sopranoCandidatePcs=[{sopranoPcsStr}], b9Pc={b9Pc}\n" +
                    $"  sopranoRange=[{upperMinMidi}-{upperMaxMidi}], totalCandidates={sopranoCandidates.Count}\n" +
                    $"  candidatesWithB9Pc=[{candidatesWithB9Str}] ({candidatesWithB9Pc.Count} found)");
            }
            
            // Filter out candidates that would cause voice crossing
            var validCandidates = new List<int>();
            int highestInner = innerVoices.Count > 0 ? innerVoices[innerVoices.Count - 1] : bassVoice;
            foreach (int candidate in sopranoCandidates)
            {
                if (candidate > highestInner) // Must be above all inner voices
                {
                    validCandidates.Add(candidate);
                }
            }
            
            if (validCandidates.Count == 0)
            {
                if (s_debugTensionDetect)
                {
                    string label = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    UnityEngine.Debug.LogWarning(
                        $"[REQ_EXT_TRACE][SOPRANO_CANDIDATES] step={stepIndex} {label} policy={s_extensionPlacementMode}\n" +
                        $"  no valid soprano candidates after spacing filter");
                }
                return -1; // No valid candidates
            }
            
            int originalCount = validCandidates.Count;
            
            // Trace: Update soprano candidates trace with after-filtering info
            if (s_debugTensionDetect)
            {
                var afterPcs = new HashSet<int>();
                foreach (int candidate in validCandidates)
                {
                    afterPcs.Add((candidate % 12 + 12) % 12);
                }
                if (s_debugTensionVerbose)
                {
                    string afterStr = string.Join(",", afterPcs.OrderBy(x => x));
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_TRACE][SOPRANO_CANDIDATES] step={stepIndex} policy={s_extensionPlacementMode} explicit=true\n" +
                        $"  after=[{afterStr}] (after spacing filter, {validCandidates.Count} candidates)");
                }
            }
            var requestedTensionPcs = new List<int>();
            var requestedTensionNames = new List<string>();
            if (req.TensionSharp11) { requestedTensionPcs.Add((rootPc + 6) % 12); requestedTensionNames.Add("#11"); }
            // CRITICAL: b9, #9, and 9 are mutually exclusive - only add the one that's requested
            if (req.TensionFlat9) { requestedTensionPcs.Add((rootPc + 1) % 12); requestedTensionNames.Add("b9"); }
            else if (req.TensionSharp9) { requestedTensionPcs.Add((rootPc + 3) % 12); requestedTensionNames.Add("#9"); }
            else if (req.Tension9) { requestedTensionPcs.Add((rootPc + 2) % 12); requestedTensionNames.Add("9"); }
            
            // ForceSoprano: filter to only melodic tension PCs
            if (s_extensionPlacementMode == RequestedExtensionPlacementMode.ForceSoprano && requestedTensionPcs.Count > 0)
            {
                var forcedCandidates = new List<int>();
                foreach (int candidate in validCandidates)
                {
                    int candidatePc = (candidate % 12 + 12) % 12;
                    if (requestedTensionPcs.Contains(candidatePc))
                    {
                        forcedCandidates.Add(candidate);
                    }
                }
                
                if (forcedCandidates.Count > 0)
                {
                    validCandidates = forcedCandidates;
                    
                    if (s_debugTensionDetect)
                    {
                        string label = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                        string forcedPcsStr = string.Join(",", requestedTensionPcs);
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_TRACE][SOPRANO_FORCE] step={stepIndex} {label}\n" +
                            $"  forcedPcs=[{forcedPcsStr}]\n" +
                            $"  candidatesBefore={originalCount} candidatesAfter={forcedCandidates.Count}");
                    }
                }
                else
                {
                    // Fallback: no forced candidates found
                    string fallbackReason = "noCandidates";
                    if (s_debugTensionDetect)
                    {
                        string label = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                        string forcedPcsStr = string.Join(",", requestedTensionPcs);
                        UnityEngine.Debug.LogWarning(
                            $"[SOPRANO_FORCE_FALLBACK] step={stepIndex} {label} " +
                            $"requestedTensionPCs=[{forcedPcsStr}] reason={fallbackReason} " +
                            $"originalCount={originalCount} - falling back to all candidates");
                    }
                    // Keep original validCandidates (fallback)
                }
            }
            
            // Score candidates with PreferSoprano policy
            int bestSoprano = -1;
            float bestCost = float.MaxValue;
            
            // Build tension set and check which tensions are already in inner voices
            var tensionPcSetForSoprano = new HashSet<int>();
            if (req.TensionFlat9) tensionPcSetForSoprano.Add((rootPc + 1) % 12);
            if (req.Tension9) tensionPcSetForSoprano.Add((rootPc + 2) % 12);
            if (req.TensionSharp9) tensionPcSetForSoprano.Add((rootPc + 3) % 12);
            if (req.TensionSharp11) tensionPcSetForSoprano.Add((rootPc + 6) % 12);
            if (req.Add9) tensionPcSetForSoprano.Add((rootPc + 2) % 12);
            if (req.Add11) tensionPcSetForSoprano.Add((rootPc + 5) % 12);
            
            // Include natural 9 from dominant 7th extensions (e.g., V9)
            bool chordHasSeventhForSoprano = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                                           chordEvent.Recipe.SeventhQuality != SeventhQuality.None;
            if (chordHasSeventhForSoprano && chordEvent.Recipe.SeventhQuality == SeventhQuality.Dominant7 && 
                !req.TensionFlat9 && !req.TensionSharp9)
            {
                tensionPcSetForSoprano.Add((rootPc + 2) % 12);
            }
            
            // Check which tension PCs are already in inner voices
            var tensionPcsInInnerVoices = new HashSet<int>();
            foreach (int innerVoice in innerVoices)
            {
                int innerPc = (innerVoice % 12 + 12) % 12;
                if (tensionPcSetForSoprano.Contains(innerPc))
                {
                    tensionPcsInInnerVoices.Add(innerPc);
                }
            }
            
            // Build VoiceTendencyInfo for previous soprano if available
            VoiceTendencyInfo previousSopranoTendencyInfo = new VoiceTendencyInfo { midiNote = previousSopranoMidi };
            if (previousEvent != null && previousSopranoMidi >= 0 && previousAnalysis != null)
            {
                previousSopranoTendencyInfo = AnalyzeVoiceTendencies(
                    previousSopranoMidi,
                    chordEvent.Key, // Use current key (same key context)
                    previousEvent.Value.Recipe,
                    previousAnalysis.Value);
            }
            
            // DIAGNOSTIC: Log step 1 soprano candidate evaluation when resolving b9 from step 0
            bool isStep1B9Resolution = (stepIndex == 1 && previousEvent.HasValue && previousEvent.Value.Recipe.RequestedExtensions.TensionFlat9);
            int strictTargetMidi = -1;
            if (isStep1B9Resolution && previousSopranoMidi >= 0)
            {
                strictTargetMidi = previousSopranoMidi - 1;  // Strict-step resolution: exactly -1 semitone
                UnityEngine.Debug.Log(
                    $"[SOPRANO_STEP1_DIAG] === Step 1 Soprano Candidate Evaluation (b9 resolution) ===\n" +
                    $"  prevMidi used={previousSopranoMidi} ({TheoryPitch.GetPitchNameFromMidi(previousSopranoMidi, chordEvent.Key)})\n" +
                    $"  strictTargetMidi={strictTargetMidi} ({TheoryPitch.GetPitchNameFromMidi(strictTargetMidi, chordEvent.Key)})\n" +
                    $"  validCandidates count={validCandidates.Count}\n" +
                    $"  candidates: [{string.Join(", ", validCandidates.Select(m => $"{m}({TheoryPitch.GetPitchNameFromMidi(m, chordEvent.Key)})"))}]");
            }
            
            foreach (int candidate in validCandidates)
            {
                float cost = 0f;
                
                // Base cost: distance from previous soprano (if available)
                // Use previousSopranoMidi if provided, otherwise use highest inner voice
                int prevSopranoForCost = previousSopranoMidi >= 0 ? previousSopranoMidi : (innerVoices.Count > 0 ? innerVoices[innerVoices.Count - 1] : -1);
                if (prevSopranoForCost >= 0)
                {
                    cost += Math.Abs(candidate - prevSopranoForCost);
                }
                
                // Apply tendency cost adjustment (including b9 resolution) if we have previous chord info
                float tendAdjust = 0f;
                if (previousEvent.HasValue && previousSopranoMidi >= 0 && previousAnalysis.HasValue && currentAnalysis.HasValue)
                {
                    tendAdjust = ComputeTendencyCostAdjustment(
                        previousSopranoTendencyInfo,
                        candidate,
                        chordEvent.Key,
                        previousEvent.Value.Recipe,
                        chordEvent.Recipe,
                        previousAnalysis.Value,
                        currentAnalysis.Value,
                        isSoprano: true,
                        nextMelodyMidi: chordEvent.MelodyMidi,
                        voiceMinMidi: -1, // No range constraint for soprano
                        voiceMaxMidi: -1);
                    cost += tendAdjust;
                    
                    // DIAGNOSTIC: Log cost breakdown for step 1 soprano candidates
                    if (isStep1B9Resolution)
                    {
                        bool isStrictStep = (candidate == strictTargetMidi);
                        UnityEngine.Debug.Log(
                            $"[SOPRANO_STEP1_DIAG] candidate={candidate} ({TheoryPitch.GetPitchNameFromMidi(candidate, chordEvent.Key)}):\n" +
                            $"  baseCost={Math.Abs(candidate - prevSopranoForCost)}, tendAdjust={tendAdjust}, totalCost={cost}\n" +
                            $"  isStrictStep={isStrictStep} (candidate == strictTargetMidi {strictTargetMidi}?)");
                    }
                }
                
                // PreferSoprano: bonus if candidate is a requested melodic tension
                // Also apply "Prefer Requested Tension In Soprano Weight" bonus (style preference)
                float sopranoTensionBonus = 0f;
                int candidatePc = (candidate % 12 + 12) % 12;
                
                if (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano)
                {
                    if (requestedTensionPcs.Contains(candidatePc))
                    {
                        sopranoTensionBonus -= 10.0f; // Large bonus for melodic tension in soprano (PreferSoprano policy)
                    }
                    else
                    {
                        // Check if any requested tension is in inner voices but not soprano
                        var innerVoicePcs = new HashSet<int>();
                        foreach (int inner in innerVoices)
                        {
                            innerVoicePcs.Add((inner % 12 + 12) % 12);
                        }
                        
                        bool tensionInInner = false;
                        foreach (int tensionPc in requestedTensionPcs)
                        {
                            if (innerVoicePcs.Contains(tensionPc))
                            {
                                tensionInInner = true;
                                break;
                            }
                        }
                        
                        if (tensionInInner)
                        {
                            cost += 8.0f; // Large penalty if tension is in inner voices but soprano is not a tension
                        }
                    }
                }
                
                // Apply "Prefer Requested Tension In Soprano Weight" bonus (style preference, not enforcement)
                // This works alongside PreferSoprano policy or independently
                if (s_preferRequestedTensionInSopranoWeight > 0f)
                {
                    float rawPreference = ComputeRequestedTensionSopranoPreference(
                        chordEvent.Recipe, chordEvent.Key, candidate);
                    sopranoTensionBonus += rawPreference * s_preferRequestedTensionInSopranoWeight;
                }
                
                cost += sopranoTensionBonus;
                
                // SAFETY RAIL: Infinite penalty for doubled tensions (soprano cannot double a tension already in inner voices)
                if (tensionPcSetForSoprano.Contains(candidatePc) && tensionPcsInInnerVoices.Contains(candidatePc))
                {
                    cost += 1e9f; // Infinite penalty
                    if (GetTendencyDebug())
                    {
                        string tensionName = "";
                        if (candidatePc == (rootPc + 1) % 12) tensionName = "b9";
                        else if (candidatePc == (rootPc + 2) % 12) tensionName = "9";
                        else if (candidatePc == (rootPc + 3) % 12) tensionName = "#9";
                        else if (candidatePc == (rootPc + 6) % 12) tensionName = "#11";
                        else tensionName = $"pc={candidatePc}";
                        string chordName = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                        UnityEngine.Debug.Log(
                            $"[NO_DOUBLE_TENSION] INF PENALTY applied to Soprano candidate {candidate} (pc={candidatePc}, {tensionName}): " +
                            $"tension already chosen in inner voice for chord {chordName}");
                    }
                }
                
                // HARD CONSTRAINT: Chordal 7th must resolve down if previous voice held the 7th and legal target exists
                // This is a correctness invariant, not a cost preference
                if (previousEvent.HasValue && previousSopranoMidi >= 0)
                {
                    var prevEvent = previousEvent.Value;
                    // Check if previous chord has a 7th
                    if (prevEvent.Recipe.SeventhQuality != SeventhQuality.None)
                    {
                        // Get the 7th pitch class from previous chord
                        var prevChordTonePcs = GetChordTonePitchClasses(prevEvent);
                        if (prevChordTonePcs != null && prevChordTonePcs.Count >= 4)
                        {
                            int seventhPc = prevChordTonePcs[3]; // 7th is at index 3
                            int prevSopranoPc = (previousSopranoMidi % 12 + 12) % 12;
                            
                            // Check if previous soprano held the 7th
                            if (prevSopranoPc == seventhPc)
                            {
                                // Compute allowed resolution pitch classes (-1 and -2 semitones)
                                int pcDown1 = (seventhPc + 11) % 12; // -1 semitone
                                int pcDown2 = (seventhPc + 10) % 12; // -2 semitones
                                
                                // Check if destination chord contains either resolution pitch class
                                bool hasPcDown1InDest = chordTonePcs.Contains(pcDown1);
                                bool hasPcDown2InDest = chordTonePcs.Contains(pcDown2);
                                bool hasValidResolution = hasPcDown1InDest || hasPcDown2InDest;
                                
                                if (hasValidResolution)
                                {
                                    // HARD VETO: Candidate must resolve to one of the legal resolution PCs
                                    if (candidatePc != pcDown1 && candidatePc != pcDown2)
                                    {
                                        cost += 1e9f; // Infinite penalty (hard veto)
                                        if (GetTendencyDebug())
                                        {
                                            string prevChordName = TheoryChord.RecipeToRomanNumeral(prevEvent.Key, prevEvent.Recipe);
                                            string chordName = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                                            string seventhName = TheoryPitch.GetPitchNameFromMidi(seventhPc + 60, chordEvent.Key);
                                            string pcDown1Name = TheoryPitch.GetPitchNameFromMidi(pcDown1 + 60, chordEvent.Key);
                                            string pcDown2Name = TheoryPitch.GetPitchNameFromMidi(pcDown2 + 60, chordEvent.Key);
                                            string candidateName = TheoryPitch.GetPitchNameFromMidi(candidate, chordEvent.Key);
                                            UnityEngine.Debug.Log(
                                                $"[SEVENTH_RESOLUTION_VETO] INF PENALTY applied to Soprano candidate {candidate} ({candidateName}, pc={candidatePc}): " +
                                                $"previous soprano held 7th {seventhName} (pc={seventhPc}) in {prevChordName}, " +
                                                $"must resolve to {pcDown1Name} (pc={pcDown1}) or {pcDown2Name} (pc={pcDown2}) in {chordName}, " +
                                                $"but candidate resolves to {candidateName} (pc={candidatePc})");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // INSTRUMENTATION: Log candidate evaluation for V9 (gated)
                var reqForSopranoEval = chordEvent.Recipe.RequestedExtensions;
                bool hasExtension9ForSopranoEval = reqForSopranoEval.Tension9 || reqForSopranoEval.TensionFlat9 || reqForSopranoEval.TensionSharp9;
                bool shouldLogSopranoEval = hasExtension9ForSopranoEval || 
                                          s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano ||
                                          (chordEvent.Recipe.Extension == ChordExtension.Seventh && chordEvent.Recipe.Degree == 5); // V9
                
                if (shouldLogSopranoEval)
                {
                    string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    int candidatePcForLog = (candidate % 12 + 12) % 12;
                    string candidateName = TheoryPitch.GetPitchNameFromMidi(candidate, chordEvent.Key);
                    bool bonusAppliedForLog = sopranoTensionBonus != 0f;
                    
                    float tendAdjustForLog = (previousEvent.HasValue && previousSopranoMidi >= 0 && previousAnalysis.HasValue && currentAnalysis.HasValue) ? tendAdjust : 0f;
                    UnityEngine.Debug.Log(
                        $"[SOPRANO_CANDIDATE_EVAL] step={stepIndex} chord={chordLabel} candidate={candidate}({candidateName},pc={candidatePcForLog})\n" +
                        $"  baseCost={Math.Abs(candidate - prevSopranoForCost):F2}, tendAdjust={tendAdjustForLog:F2}, sopranoTensionBonus={sopranoTensionBonus:F2}, totalCost={cost:F2}\n" +
                        $"  bonusApplied={bonusAppliedForLog}");
                }
                
                if (cost < bestCost)
                {
                    bestCost = cost;
                    bestSoprano = candidate;
                }
            }
            
            // INSTRUMENTATION: Log final chosen soprano for V9 (gated)
            var reqForSopranoFinal = chordEvent.Recipe.RequestedExtensions;
            bool hasB9ForSopranoFinal = reqForSopranoFinal.TensionFlat9;
            bool shouldLogSopranoFinal = hasB9ForSopranoFinal || 
                                       (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano && reqForSopranoFinal.TensionFlat9);
            
            if (shouldLogSopranoFinal && bestSoprano >= 0)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                int chosenPc = (bestSoprano % 12 + 12) % 12;
                string chosenName = TheoryPitch.GetPitchNameFromMidi(bestSoprano, chordEvent.Key);
                
                // Recompute bonus for chosen candidate
                float chosenRawPreference = 0f;
                float chosenBonus = 0f;
                if (s_preferRequestedTensionInSopranoWeight > 0f)
                {
                    chosenRawPreference = ComputeRequestedTensionSopranoPreference(
                        chordEvent.Recipe, chordEvent.Key, bestSoprano);
                    chosenBonus = chosenRawPreference * s_preferRequestedTensionInSopranoWeight;
                }
                
                bool bonusApplied = chosenBonus != 0f;
                
                UnityEngine.Debug.Log(
                    $"[FINAL_CHOSEN_SOPRANO] step={stepIndex} chord={chordLabel} AFTER SelectSopranoExplicitly (non-melody path)\n" +
                    $"  chosen soprano: {bestSoprano}({chosenName},pc={chosenPc})\n" +
                    $"  bonusApplied={bonusApplied}, rawPreference={chosenRawPreference:F2}, weightedBonus={chosenBonus:F2}, totalCost={bestCost:F2}");
            }
            
            // DIAGNOSTIC: Log final chosen soprano for step 1 b9 resolution
            if (isStep1B9Resolution && bestSoprano >= 0)
            {
                bool isStrictStep = (bestSoprano == strictTargetMidi);
                UnityEngine.Debug.Log(
                    $"[SOPRANO_STEP1_DIAG] === FINAL CHOSEN Soprano (step 1, b9 resolution) ===\n" +
                    $"  prevMidi used={previousSopranoMidi} ({TheoryPitch.GetPitchNameFromMidi(previousSopranoMidi, chordEvent.Key)})\n" +
                    $"  strictTargetMidi={strictTargetMidi} ({TheoryPitch.GetPitchNameFromMidi(strictTargetMidi, chordEvent.Key)})\n" +
                    $"  chosen soprano midi={bestSoprano} ({TheoryPitch.GetPitchNameFromMidi(bestSoprano, chordEvent.Key)})\n" +
                    $"  isStrictStep={isStrictStep} (expected: true for 68→67)");
            }
            
            // Log soprano selection
            if (s_debugTensionDetect && bestSoprano >= 0)
            {
                string label = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                int chosenPc = (bestSoprano % 12 + 12) % 12;
                string chosenName = TheoryPitch.GetPitchNameFromMidi(bestSoprano, chordEvent.Key);
                
                // Determine which voice contains each requested tension
                var voiceAssignments = new List<string>();
                var allVoicePcs = new Dictionary<int, string>();
                allVoicePcs[(bassVoice % 12 + 12) % 12] = "B";
                for (int i = 0; i < innerVoices.Count; i++)
                {
                    int pc = (innerVoices[i] % 12 + 12) % 12;
                    string voiceName = i == 0 ? "T" : "A";
                    allVoicePcs[pc] = voiceName;
                }
                allVoicePcs[chosenPc] = "S";
                
                foreach (int tensionPc in requestedTensionPcs)
                {
                    string voice = allVoicePcs.ContainsKey(tensionPc) ? allVoicePcs[tensionPc] : "missing";
                    int tensionIdx = requestedTensionPcs.IndexOf(tensionPc);
                    string tensionName = tensionIdx >= 0 && tensionIdx < requestedTensionNames.Count ? requestedTensionNames[tensionIdx] : "?";
                    voiceAssignments.Add($"{tensionName}:{voice}");
                }
                
                string requestedPcsStr = requestedTensionPcs.Count > 0 ? string.Join(",", requestedTensionPcs) : "none";
                string voiceAssignStr = voiceAssignments.Count > 0 ? string.Join(",", voiceAssignments) : "none";
                
                // Trace: Log soprano selection with policy info (verbose only)
                if (s_debugTensionVerbose)
                {
                    UnityEngine.Debug.Log(
                        $"[PLAY_TRACE] step={stepIndex} soprano selection:\n" +
                        $"  method=SelectSopranoExplicitly policy={s_extensionPlacementMode}\n" +
                        $"  requestedTensionPCs=[{requestedPcsStr}]\n" +
                        $"  candidatesBefore={originalCount} candidatesAfter={validCandidates.Count}\n" +
                        $"  chosen={bestSoprano}({chosenName},pc={chosenPc})\n" +
                        $"  tensionsInVoices=[{voiceAssignStr}]");
                }
            }
            
            return bestSoprano;
        }
        
        /// <summary>
        /// Computes a penalty for bad leading-tone resolution (e.g., B→Eb in key of C when G7→Cm).
        /// Returns positive penalty value if leading tone does not resolve to tonic.
        /// </summary>
        private static float ComputeLeadingToneResolutionPenalty(
            int prevMidi,
            int nextMidi,
            ChordEvent prevEvent,
            ChordEvent nextEvent,
            int stepIndex)
        {
            // Detect dominant-to-tonic motion
            // Check if previous chord is dominant (V or V7) and next is tonic (I or i)
            // Try to detect from chord labels/analysis
            string prevLabel = TheoryChord.RecipeToRomanNumeral(prevEvent.Key, prevEvent.Recipe);
            string nextLabel = TheoryChord.RecipeToRomanNumeral(nextEvent.Key, nextEvent.Recipe);
            
            // Simple heuristic: check if previous is V/V7 and next is I/i
            // This is a minimal check - could be enhanced with proper function analysis
            bool prevIsDominant = prevLabel.Contains("V") && (prevLabel.Contains("7") || !prevLabel.Contains("m"));
            bool nextIsTonic = nextLabel.Contains("I") && !nextLabel.Contains("V") && !nextLabel.Contains("vi") && !nextLabel.Contains("iii");
            
            if (!prevIsDominant || !nextIsTonic)
            {
                // Not dominant-to-tonic motion - no penalty
                return 0f;
            }
            
            // Check if prevMidi is leading tone (scale degree 7) in the key
            int keyTonicPc = TheoryScale.GetDegreePitchClass(prevEvent.Key, 1); // Degree 1 = tonic
            int leadingTonePc = (keyTonicPc + 11) % 12; // Degree 7 = leading tone (11 semitones above tonic)
            
            int prevPc = (prevMidi % 12 + 12) % 12;
            int nextPc = (nextMidi % 12 + 12) % 12;
            int tonicPc = keyTonicPc;
            
            if (prevPc == leadingTonePc)
            {
                // This voice contains the leading tone
                if (nextPc != tonicPc)
                {
                    // Leading tone did not resolve to tonic - apply penalty
                    float penalty = 15.0f; // Large penalty
                    
                    // Especially penalize downward motion
                    if (nextMidi < prevMidi)
                    {
                        penalty += 10.0f; // Extra penalty for downward resolution
                    }
                    
                    if (s_debugTensionDetect)
                    {
                        string voiceName = "Voice"; // Could be enhanced to track voice name
                        string prevName = TheoryPitch.GetPitchNameFromMidi(prevMidi, prevEvent.Key);
                        string nextName = TheoryPitch.GetPitchNameFromMidi(nextMidi, nextEvent.Key);
                        int interval = nextMidi - prevMidi;
                        string intervalStr = interval > 0 ? $"+{interval}" : interval.ToString();
                        string expectedStr = $"expected: {leadingTonePc} → {tonicPc}";
                        
                        if (s_debugTensionVerbose)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_TRACE][RESOLUTION] {prevLabel} → {nextLabel}\n" +
                                $"  voice={voiceName} prev={prevMidi}({prevName},pc={prevPc}) next={nextMidi}({nextName},pc={nextPc}) " +
                                $"interval={intervalStr} ({interval} semitones) ❌\n" +
                                $"  {expectedStr}");
                        }
                    }
                    
                    return penalty;
                }
            }
            
            return 0f;
        }
        
        /// <summary>
        /// Computes a cost adjustment (negative = preference) for a soprano candidate based on requested tensions.
        /// Used in Play/NH paths when there's no fixed melody to prefer requested tensions in soprano.
        /// Priority: b9 > #11 > 9
        /// 
        /// FIX: Also includes natural 9 from chord extension (e.g., V9) even if not explicitly in RequestedExtensions.
        /// This ensures V9's natural 9 is eligible for soprano preference.
        /// </summary>
        public static float ComputeRequestedTensionSopranoPreference(
            ChordRecipe recipe,
            TheoryKey key,
            int sopranoCandidateMidi)
        {
            var req = recipe.RequestedExtensions;
            int sopranoPc = (sopranoCandidateMidi % 12 + 12) % 12;
            
            // Compute root PC
            int rootPc = TheoryScale.GetDegreePitchClass(key, recipe.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + recipe.RootSemitoneOffset + 12) % 12;
            if (rootPc < 0) rootPc += 12;
            
            // Build set of preferred extension pitch classes (requested tensions + present extension tones)
            var preferredExtensionPcs = new HashSet<int>();
            
            // Add explicitly requested tensions
            if (req.TensionFlat9) preferredExtensionPcs.Add((rootPc + 1) % 12);
            if (req.Tension9) preferredExtensionPcs.Add((rootPc + 2) % 12);
            if (req.TensionSharp9) preferredExtensionPcs.Add((rootPc + 3) % 12);
            if (req.TensionSharp11) preferredExtensionPcs.Add((rootPc + 6) % 12);
            
            // FIX: Also include natural 9 from chord extension (e.g., V9) even if not in RequestedExtensions
            // For dominant 9 chords (V9, etc.), the natural 9 is part of the chord extension
            // Check if this is a dominant 7th chord with natural 9 extension
            bool isDominant7th = recipe.Extension == ChordExtension.Seventh &&
                                recipe.SeventhQuality == SeventhQuality.Dominant7;
            bool hasNatural9Extension = req.Tension9; // Already checked above, but also check if it's implied by the chord
            
            // For V9 (dominant 7th + 9), include natural 9 even if RequestedExtensions.Tension9 is not explicitly set
            // This handles cases where V9 is parsed but Tension9 flag might not be set correctly
            if (isDominant7th && !req.TensionFlat9 && !req.TensionSharp9)
            {
                // If it's a dominant 7th and no altered 9th is specified, natural 9 is implied
                // Add it to the preferred set (this makes V9's 9th eligible for soprano preference)
                preferredExtensionPcs.Add((rootPc + 2) % 12);
            }
            
            // If no preferred extensions, return 0
            if (preferredExtensionPcs.Count == 0 && !req.Add9 && !req.Add11)
                return 0f;
            
            // Priority: b9 > #11 > 9
            if (preferredExtensionPcs.Contains((rootPc + 1) % 12) && sopranoPc == (rootPc + 1) % 12)
            {
                    return -3.0f; // Strong preference for b9
            }
            
            if (preferredExtensionPcs.Contains((rootPc + 6) % 12) && sopranoPc == (rootPc + 6) % 12)
            {
                // Validate: #11 only valid on major/maj7/dominant
                bool isValid = (recipe.Quality == ChordQuality.Major) ||
                              (recipe.Extension == ChordExtension.Seventh && 
                               (recipe.SeventhQuality == SeventhQuality.Major7 || 
                                recipe.SeventhQuality == SeventhQuality.Dominant7));
                if (isValid)
                {
                        return -2.5f; // Medium-strong preference for #11
                }
            }
            
            if (preferredExtensionPcs.Contains((rootPc + 2) % 12) && sopranoPc == (rootPc + 2) % 12)
            {
                    return -2.0f; // Medium preference for 9
            }
            
            // For add9/add11, apply smaller preference (they're not required in soprano)
            if (req.Add9)
            {
                int add9Pc = (rootPc + 2) % 12;
                if (sopranoPc == add9Pc)
                    return -0.5f; // Small preference
            }
            
            if (req.Add11)
            {
                int add11Pc = (rootPc + 5) % 12;
                if (sopranoPc == add11Pc)
                    return -0.5f; // Small preference
            }
            
            return 0f;
        }
        
        /// <summary>
        /// Gets the current 7th resolution avoidance penalty value.
        /// </summary>
        public static float GetSeventhResolutionAvoidPenaltyNormal() => seventhResolutionAvoidPenaltyNormal;
        
        /// <summary>
        /// Gets the current spacing preferred penalty value.
        /// </summary>
        public static float GetSpacingPreferredPenalty() => spacingPreferredPenalty;
        
        /// <summary>
        /// Gets the current spacing bass-tenor penalty value.
        /// </summary>
        public static float GetSpacingBassTenorPenalty() => spacingBassTenorPenalty;
        
        /// <summary>
        /// Sets the 11th tension heuristics parameters. Called from ChordLabController.
        /// </summary>
        public static void SetEleventhHeuristics(
            bool enable,
            float penalty_11_withThird_Maj,
            float penalty_11_withThird_Dom,
            float penalty_11_withThird_Min,
            float bonus_11_withoutThird,
            float penalty_sharp11_closeToThirdWithinOctave)
        {
            s_enableEleventhHeuristics = enable;
            s_penalty_11_withThird_Maj = penalty_11_withThird_Maj;
            s_penalty_11_withThird_Dom = penalty_11_withThird_Dom;
            s_penalty_11_withThird_Min = penalty_11_withThird_Min;
            s_bonus_11_withoutThird = bonus_11_withoutThird;
            s_penalty_sharp11_closeToThirdWithinOctave = penalty_sharp11_closeToThirdWithinOctave;
        }
        
        // Voice spacing soft penalties: applied as cost terms during candidate evaluation
        private const float SpacingLargePenalty = 200f;        // big but not infinite
        // These can be set from ChordLabController to allow Inspector adjustment
        private static float spacingPreferredPenalty = 40f;     // medium, for "not ideal but okay"
        private static float spacingBassTenorPenalty = 15f;     // small
        
        // 11th tension heuristics (soprano-only, v1)
        private static bool s_enableEleventhHeuristics = true;
        private static float s_penalty_11_withThird_Maj = 8f;
        private static float s_penalty_11_withThird_Dom = 6f;
        private static float s_penalty_11_withThird_Min = 0f;
        private static float s_bonus_11_withoutThird = -2f;
        private static float s_penalty_sharp11_closeToThirdWithinOctave = 3f;
        
        // Chord-tone coverage rules for SATB full search
        private const float MissingEssentialToneVeto = float.MaxValue; // we'll use hard veto
        private const int MaxDuplicateCountPerPc = 2;                   // no pitch class should appear 3+ times
        
        // Common tone 3rd→7th preference (for diatonic 7th-chord chains)
        private const float CommonThirdToSeventhBonus = -3.0f;
        
        // Leading tone rule softening when next chord needs its 7th
        private const float LeadingToneSoftenFactor = 0.1f; // Multiply leading-tone bonus by this when 7th coverage is at risk

        /// <summary>
        /// Gets default settings for Play button voicing continuity and register control.
        /// Voices indexed 0..3 = top (soprano) to bottom (bass).
        /// </summary>
        /// <returns>Default Play voicing settings with conservative ranges</returns>
        public static PlayVoicingSettings GetDefaultPlayVoicingSettings()
        {
            return new PlayVoicingSettings
            {
                MaxLeapSemitones = 9, // Maximum leap of a 6th
                // Voice 0 (top/soprano): C4 to G5
                // Voice 1 (alto): G3 to D5
                // Voice 2 (tenor): C3 to G4
                // Voice 3 (bass): E2 to C4
                MinMidiByVoice = new int[] { 60, 55, 48, 40 }, // [soprano, alto, tenor, bass]
                MaxMidiByVoice = new int[] { 79, 74, 67, 60 }  // [soprano, alto, tenor, bass]
            };
        }
        
        /// <summary>
        /// Sets the debug flag for tendency rule logging.
        /// </summary>
        public static void SetTendencyDebug(bool enabled)
        {
            enableTendencyDebug = enabled;
        }

        /// <summary>
        /// Gets the current state of the tendency debug flag.
        /// </summary>
        public static bool GetTendencyDebug()
        {
            return enableTendencyDebug;
        }
        
        /// <summary>
        /// Sets the augmented 5th debug flag.
        /// </summary>
        public static void SetAug5Debug(bool enabled)
        {
            s_enableAug5Debug = enabled;
        }
        
        /// <summary>
        /// Gets the augmented 5th debug flag.
        /// </summary>
        public static bool GetAug5Debug()
        {
            return s_enableAug5Debug;
        }
        
        /// <summary>
        /// Enable/disable #9 octave selection tracing (for G7#9 octave jump investigation).
        /// When enabled, logs compact traces at key checkpoints for step 0 chords requesting #9.
        /// </summary>
        public static void SetSharp9OctaveTrace(bool enabled)
        {
            s_debugSharp9OctaveTrace = enabled;
        }
        
        /// <summary>
        /// Get current #9 octave trace debug state.
        /// </summary>
        public static bool GetSharp9OctaveTrace()
        {
            return s_debugSharp9OctaveTrace;
        }
        
        /// <summary>
        /// Sets the debug flag for voicing path and weight logging.
        /// </summary>
        public static void SetVoicingPathDebug(bool enabled)
        {
            enableVoicingPathDebug = enabled;
        }
        
        /// <summary>
        /// Gets the current state of the voicing path debug flag.
        /// </summary>
        public static bool GetVoicingPathDebug()
        {
            return enableVoicingPathDebug;
        }
        
        /// <summary>
        /// Sets the debug flag for full search summary logging.
        /// </summary>
        public static void SetFullSearchDebugSummary(bool enabled)
        {
            enableFullSearchDebugSummary = enabled;
        }
        
        /// <summary>
        /// Sets the debug flag for tension detection logging.
        /// </summary>
        public static void SetDebugTensionDetect(bool enabled)
        {
            s_debugTensionDetect = enabled;
        }
        
        /// <summary>
        /// Gets the current state of the tension detection debug flag.
        /// </summary>
        public static bool GetDebugTensionDetect()
        {
            return s_debugTensionDetect;
        }
        
        /// <summary>
        /// Sets the verbose debug flag for tension detection logging.
        /// When enabled along with s_debugTensionDetect, shows detailed per-step/per-candidate traces.
        /// </summary>
        public static void SetDebugTensionVerbose(bool enabled)
        {
            s_debugTensionVerbose = enabled;
        }
        
        /// <summary>
        /// Gets the current state of the verbose tension detection debug flag.
        /// </summary>
        public static bool GetDebugTensionVerbose()
        {
            return s_debugTensionVerbose;
        }
        
        /// <summary>
        /// Gets the current state of the full search debug summary flag.
        /// </summary>
        public static bool GetFullSearchDebugSummary()
        {
            return enableFullSearchDebugSummary;
        }
        
        /// <summary>
        /// Sets the debug flag for hard constraint pruning counters.
        /// </summary>
        public static void SetHardPruneDebug(bool enabled)
        {
            s_enableHardPruneDebug = enabled;
        }
        
        /// <summary>
        /// Gets the current state of the hard prune debug flag.
        /// </summary>
        public static bool GetHardPruneDebug()
        {
            return s_enableHardPruneDebug;
        }
        
        /// <summary>
        /// Sets the flag to force full search for every chord in melody-constrained voicing.
        /// </summary>
        public static void SetUseFullSearchEveryChord(bool enabled)
        {
            s_useFullSearchEveryChord = enabled;
        }
        
        /// <summary>
        /// Gets the current state of the use full search every chord flag.
        /// </summary>
        public static bool GetUseFullSearchEveryChord()
        {
            return s_useFullSearchEveryChord;
        }
        
        /// <summary>
        /// Helper to check if we should trace a chord label.
        /// </summary>
        private static bool ShouldTrace(string label)
        {
            return label != null && (label.Contains("Ab7") || label.Contains("B7"));
        }
        
        /// <summary>
        /// Helper to log TRACE messages only when diags.EnableTrace is true.
        /// </summary>
        private static void TraceLog(string message, DiagnosticsCollector diags)
        {
            if (diags == null || !diags.EnableTrace) return;
            UnityEngine.Debug.Log(message);
        }
        
        /// <summary>
        /// Helper to check if we should trace a region by index (for narrow debugging).
        /// Requires diags.EnableTrace to be true.
        /// </summary>
        private static bool ShouldTraceRegion(int regionIndex, DiagnosticsCollector diags)
        {
            return diags != null && diags.EnableTrace && enableTraceNonChordDebug && (regionIndex == 2 || regionIndex == 5);
        }
        
        /// <summary>
        /// Helper to dump SATB with illegal PC flags.
        /// Only outputs if diags.EnableTrace is true.
        /// </summary>
        private static void TraceDumpSATB(
            string stage,
            int regionIndex,
            string chordLabel,
            string debugLabel,
            int[] satb,
            HashSet<int> allowedChordPcs,
            TheoryKey key,
            DiagnosticsCollector diags)
        {
            if (diags == null || !diags.EnableTrace) return;
            if (!ShouldTraceRegion(regionIndex, diags)) return;

            string[] voiceNames = { "Bass", "Tenor", "Alto", "Soprano" };
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            sb.AppendLine($"[TRACE SNAPSHOT] R{regionIndex} label='{debugLabel}' chord={chordLabel} :: {stage}");
            sb.AppendLine($"[TRACE SNAPSHOT] Allowed PCs: [{string.Join(",", allowedChordPcs.OrderBy(x => x))}]");

            // Print raw SATB array
            sb.AppendLine($"[TRACE SNAPSHOT] SATB=[{string.Join(",", satb)}]");

            // Print each voice with legality check
            for (int v = 0; v < satb.Length && v < voiceNames.Length; v++)
            {
                int midi = satb[v];
                int pc = ((midi % 12) + 12) % 12;
                string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, key);
                bool isLegal = allowedChordPcs.Contains(pc);
                string illegalFlag = isLegal ? "" : " [ILLEGAL]";

                sb.AppendLine($"[TRACE SNAPSHOT] v{v} {voiceNames[v]} midi={midi} name={pitchName} pc={pc}{illegalFlag}");
            }

            UnityEngine.Debug.Log(sb.ToString());
        }
        
        /// <summary>
        /// Helper to convert MIDI array to pitch class string.
        /// </summary>
        private static string MidiToPcs(int[] m)
        {
            return string.Join(",", m.Select(x => ((x % 12) + 12) % 12));
        }

        /// <summary>
        /// Voices a single chord into 3-4 parts using simple block voicing (close position).
        /// This is a heuristic v1 implementation - not full chorale rules.
        /// </summary>
        /// <param name="chordEvent">The chord event to voice</param>
        /// <param name="numVoices">Number of voices (3 or 4). Clamped to [3, 4] range.</param>
        /// <param name="bassOctave">Octave for the bass voice (default: 3, around MIDI 48)</param>
        /// <param name="upperMinMidi">Minimum MIDI note for upper voices (default: 55, around G3)</param>
        /// <param name="upperMaxMidi">Maximum MIDI note for upper voices (default: 80, around G5)</param>
        /// <returns>VoicedChord with bass and upper voices in close position</returns>
        public static VoicedChord VoiceFirstChord(
            ChordEvent chordEvent,
            int numVoices = 4,
            int bassOctave = 3,
            int upperMinMidi = 55,
            int upperMaxMidi = 80,
            ChordEvent? nextChordEvent = null,
            int chordIndex = -1,
            string originalToken = null)
        {
            // Clamp numVoices to valid range [3, 4]
            if (numVoices < 3) numVoices = 3;
            if (numVoices > 4) numVoices = 4;

            // STEP 0: DEFINITIVE CHECK - Does the chord-tone set include the 7th?
            // This single log will tell us if V9's recipe construction includes the 7th or not
            string step0Token = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
            var step0ChordTonePcs = GetChordTonePitchClasses(chordEvent);
            
            // Calculate root PC for display
            int step0RootPcForDisplay = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (step0RootPcForDisplay < 0) step0RootPcForDisplay = 0;
            step0RootPcForDisplay = (step0RootPcForDisplay + chordEvent.Recipe.RootSemitoneOffset) % 12;
            if (step0RootPcForDisplay < 0) step0RootPcForDisplay += 12;
            
            // Check if chord tones include 7th
            bool step0ContainsSeventhPc = step0ChordTonePcs.Count >= 4;
            int step0ExpectedSeventhPc = -1;
            string step0SeventhPcName = "none";
            
            if (step0ContainsSeventhPc)
            {
                step0ExpectedSeventhPc = step0ChordTonePcs[3];
                int step0RepresentativeMidi = 60 + step0ExpectedSeventhPc; // Use C4 as base
                step0SeventhPcName = TheoryPitch.GetPitchNameFromMidi(step0RepresentativeMidi, chordEvent.Key);
            }
            else if (chordEvent.Recipe.Quality == ChordQuality.Major || 
                     chordEvent.Recipe.Quality == ChordQuality.Minor ||
                     chordEvent.Recipe.Quality == ChordQuality.Diminished)
            {
                // For dominant chords, calculate what the 7th SHOULD be
                int step0SeventhInterval = 10; // Dominant 7th (b7)
                step0ExpectedSeventhPc = (step0RootPcForDisplay + step0SeventhInterval) % 12;
                int step0RepresentativeMidi = 60 + step0ExpectedSeventhPc;
                step0SeventhPcName = TheoryPitch.GetPitchNameFromMidi(step0RepresentativeMidi, chordEvent.Key);
            }
            
            var step0Req = chordEvent.Recipe.RequestedExtensions;
            var step0RequestedTensions = new List<string>();
            if (step0Req.TensionFlat9) step0RequestedTensions.Add("b9");
            if (step0Req.Tension9) step0RequestedTensions.Add("9");
            if (step0Req.TensionSharp9) step0RequestedTensions.Add("#9");
            if (step0Req.TensionSharp11) step0RequestedTensions.Add("#11");
            
            UnityEngine.Debug.Log(
                $"[STEP0_DEFINITIVE] token='{step0Token}' recipe check:\n" +
                $"  Quality={chordEvent.Recipe.Quality}, RootPC={step0RootPcForDisplay}\n" +
                $"  Extension={chordEvent.Recipe.Extension}, SeventhQuality={chordEvent.Recipe.SeventhQuality}\n" +
                $"  RequestedTensions=[{string.Join(",", step0RequestedTensions)}]\n" +
                $"  GetChordTonePitchClasses output: Count={step0ChordTonePcs.Count}, pcs=[{string.Join(",", step0ChordTonePcs)}]\n" +
                $"  containsSeventhPc={step0ContainsSeventhPc}, expectedSeventhPc={step0ExpectedSeventhPc} ({step0SeventhPcName})");

            // CHECKPOINT A (old): After parsing / chord recipe creation (for #9 trace)
            if (s_debugSharp9OctaveTrace && chordIndex == 0)
            {
                var req = chordEvent.Recipe.RequestedExtensions;
                if (req.TensionSharp9)
                {
                    int rootPcForTrace = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
                    if (rootPcForTrace < 0) rootPcForTrace = 0;
                    rootPcForTrace = (rootPcForTrace + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
                    if (rootPcForTrace < 0) rootPcForTrace += 12;
                    int sharp9PcForTrace = (rootPcForTrace + 3) % 12;
                    string chordLabel = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    string tensionFlags = $"b9={req.TensionFlat9} 9={req.Tension9} #9={req.TensionSharp9} #11={req.TensionSharp11}";
                    UnityEngine.Debug.Log(
                        $"[SHARP9_TRACE][PARSE] step=0 chord={chordLabel} rootPc={rootPcForTrace} sharp9Pc={sharp9PcForTrace} {tensionFlags}");
                }
            }

            // Debug logging: Entry point for VoiceFirstChord
            if (s_debugTensionDetect && chordIndex >= 0)
            {
                var req = chordEvent.Recipe.RequestedExtensions;
                var reqList = new List<string>();
                if (req.Sus4) reqList.Add("sus4");
                if (req.Add9) reqList.Add("add9");
                if (req.Add11) reqList.Add("add11");
                if (req.Tension9) reqList.Add("9");
                if (req.TensionFlat9) reqList.Add("b9");
                if (req.TensionSharp11) reqList.Add("#11");
                string reqStr = reqList.Count > 0 ? string.Join(",", reqList) : "none";
                string tokenStr = originalToken ?? "?";
                
                // High-level summary only (keep this visible)
                if (req.HasAny)
                {
                    UnityEngine.Debug.Log($"Chord {tokenStr}: requested tensions = [{reqStr}]");
                }
                
                // Verbose details (gated)
                if (s_debugTensionVerbose && s_debugTensionDetect)
                {
                    UnityEngine.Debug.Log(
                        $"[PLAY_DEBUG] === CHORD {chordIndex} (VoiceFirstChord) ===\n" +
                        $"  originalToken='{tokenStr}'\n" +
                        $"  RequestedExtensions=[{reqStr}]\n" +
                        $"  TensionFlat9={req.TensionFlat9}, Tension9={req.Tension9}, TensionSharp11={req.TensionSharp11}");
                }
            }

            // Compute bass voice: use inversion-aware bass pitch class
            int bassPc = GetBassPitchClassForChord(chordEvent.Key, chordEvent.Recipe);
            
            // Calculate MIDI note for bass in the specified octave
            // Start with C in the bass octave, then add semitones to reach the target pitch class
            int bassMidi = (bassOctave + 1) * 12 + bassPc;
            int bassVoice = bassMidi;

            // Calculate root pitch class directly from the recipe (regardless of inversion)
            int rootPc = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPc < 0)
            {
                rootPc = 0; // Fallback to C
            }
            rootPc = (rootPc + chordEvent.Recipe.RootSemitoneOffset) % 12;
            if (rootPc < 0) rootPc += 12;

            // Determine if this is a 7th chord
            bool hasSeventh = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                              chordEvent.Recipe.SeventhQuality != SeventhQuality.None;

            // Calculate intervals from root based on chord quality
            int thirdInterval, fifthInterval, seventhInterval = 0;
            
            switch (chordEvent.Recipe.Quality)
            {
                case ChordQuality.Major:
                    thirdInterval = 4;  // major third
                    fifthInterval = 7; // perfect fifth
                    break;
                case ChordQuality.Minor:
                    thirdInterval = 3;  // minor third
                    fifthInterval = 7;  // perfect fifth
                    break;
                case ChordQuality.Diminished:
                    thirdInterval = 3;  // minor third
                    fifthInterval = 6;  // diminished fifth
                    break;
                case ChordQuality.Augmented:
                    thirdInterval = 4;  // major third
                    fifthInterval = 8;  // augmented fifth
                    break;
                default:
                    thirdInterval = 4;
                    fifthInterval = 7;
                    break;
            }

            // Calculate 7th interval if present
            if (hasSeventh)
            {
                switch (chordEvent.Recipe.SeventhQuality)
                {
                    case SeventhQuality.Major7:
                        seventhInterval = 11; // major 7th
                        break;
                    case SeventhQuality.Minor7:
                    case SeventhQuality.Dominant7:
                    case SeventhQuality.HalfDiminished7:
                        seventhInterval = 10; // minor 7th
                        break;
                    case SeventhQuality.Diminished7:
                        seventhInterval = 9; // diminished 7th
                        break;
                    default:
                        seventhInterval = 10;
                        break;
                }
            }

            // Calculate pitch classes for each chord tone
            int thirdPc = (rootPc + thirdInterval) % 12;
            int fifthPc = (rootPc + fifthInterval) % 12;
            int seventhPc = hasSeventh ? (rootPc + seventhInterval) % 12 : -1;

            // Resolution-aware 7th placement: if the chord has a 7th and we know the next chord,
            // try to place the 7th at a MIDI height that allows downward step resolution
            int? resolutionAwareSeventhMidi = null;
            bool canLookAhead = hasSeventh && nextChordEvent.HasValue && seventhPc >= 0;
            
            if (canLookAhead)
            {
                var nextChord = nextChordEvent.Value;
                
                // Compute next chord's pitch classes (similar to current chord calculation)
                int nextRootPc = TheoryScale.GetDegreePitchClass(nextChord.Key, nextChord.Recipe.Degree);
                if (nextRootPc < 0) nextRootPc = 0;
                nextRootPc = (nextRootPc + nextChord.Recipe.RootSemitoneOffset) % 12;
                if (nextRootPc < 0) nextRootPc += 12;
                
                // Calculate intervals for next chord
                int nextThirdInterval, nextFifthInterval, nextSeventhInterval = 0;
                switch (nextChord.Recipe.Quality)
                {
                    case ChordQuality.Major:
                        nextThirdInterval = 4;
                        nextFifthInterval = 7;
                        break;
                    case ChordQuality.Minor:
                        nextThirdInterval = 3;
                        nextFifthInterval = 7;
                        break;
                    case ChordQuality.Diminished:
                        nextThirdInterval = 3;
                        nextFifthInterval = 6;
                        break;
                    case ChordQuality.Augmented:
                        nextThirdInterval = 4;
                        nextFifthInterval = 8;
                        break;
                    default:
                        nextThirdInterval = 4;
                        nextFifthInterval = 7;
                        break;
                }
                
                bool nextHasSeventh = nextChord.Recipe.Extension == ChordExtension.Seventh &&
                                     nextChord.Recipe.SeventhQuality != SeventhQuality.None;
                if (nextHasSeventh)
                {
                    switch (nextChord.Recipe.SeventhQuality)
                    {
                        case SeventhQuality.Major7:
                            nextSeventhInterval = 11;
                            break;
                        case SeventhQuality.Minor7:
                        case SeventhQuality.Dominant7:
                        case SeventhQuality.HalfDiminished7:
                            nextSeventhInterval = 10;
                            break;
                        case SeventhQuality.Diminished7:
                            nextSeventhInterval = 9;
                            break;
                        default:
                            nextSeventhInterval = 10;
                            break;
                    }
                }
                
                int nextThirdPc = (nextRootPc + nextThirdInterval) % 12;
                int nextFifthPc = (nextRootPc + nextFifthInterval) % 12;
                int nextSeventhPc = nextHasSeventh ? (nextRootPc + nextSeventhInterval) % 12 : -1;
                
                // Build list of next chord's pitch classes
                var nextChordPcs = new List<int> { nextRootPc, nextThirdPc, nextFifthPc };
                if (nextHasSeventh && nextSeventhPc >= 0)
                {
                    nextChordPcs.Add(nextSeventhPc);
                }
                var nextChordPcsSet = new HashSet<int>(nextChordPcs);
                
                // Compute valid resolution pitch classes (1-2 semitones down from the 7th)
                int resPcMinus1 = (seventhPc + 11) % 12;  // -1 semitone
                int resPcMinus2 = (seventhPc + 10) % 12;  // -2 semitones
                
                // Helper to check if next chord contains a pitch class
                bool NextChordContains(int pc)
                {
                    return nextChordPcsSet.Contains(pc);
                }
                
                // Check if the next chord contains either resolution pitch class
                bool hasValidResolution = NextChordContains(resPcMinus1) || NextChordContains(resPcMinus2);
                
                if (hasValidResolution)
                {
                    // Search for good 7th placements within the upper voice range
                    int mid = (upperMinMidi + upperMaxMidi) / 2;
                    
                    for (int midi = upperMinMidi; midi <= upperMaxMidi; midi++)
                    {
                        // Only consider MIDI notes with the 7th's pitch class
                        if ((midi % 12 + 12) % 12 != seventhPc)
                            continue;
                        
                        // Potential downward step resolutions
                        int candRes1 = midi - 1;
                        int candRes2 = midi - 2;
                        
                        // Check if candidate resolution 1 is valid (1 semitone down)
                        bool cand1Ok = candRes1 >= upperMinMidi && candRes1 <= upperMaxMidi;
                        if (cand1Ok)
                        {
                            int candRes1Pc = (candRes1 % 12 + 12) % 12;
                            cand1Ok = NextChordContains(candRes1Pc) && 
                                     (candRes1Pc == resPcMinus1 || candRes1Pc == resPcMinus2);
                        }
                        
                        // Check if candidate resolution 2 is valid (2 semitones down)
                        bool cand2Ok = candRes2 >= upperMinMidi && candRes2 <= upperMaxMidi;
                        if (cand2Ok)
                        {
                            int candRes2Pc = (candRes2 % 12 + 12) % 12;
                            cand2Ok = NextChordContains(candRes2Pc) && 
                                     (candRes2Pc == resPcMinus1 || candRes2Pc == resPcMinus2);
                        }
                        
                        if (cand1Ok || cand2Ok)
                        {
                            // Prefer placement closest to middle of the range for smoother spacing
                            if (!resolutionAwareSeventhMidi.HasValue ||
                                Math.Abs(midi - mid) < Math.Abs(resolutionAwareSeventhMidi.Value - mid))
                            {
                                resolutionAwareSeventhMidi = midi;
                            }
                        }
                    }
                    
                    if (resolutionAwareSeventhMidi.HasValue && enableTendencyDebug)
                    {
                        string seventhName = TheoryPitch.GetPitchNameFromMidi(resolutionAwareSeventhMidi.Value, chordEvent.Key);
                        var nextChordPcNames = new List<string>();
                        foreach (int pc in nextChordPcs)
                        {
                            // Find a representative MIDI note for this pitch class to get the name
                            int sampleMidi = (4 + 1) * 12 + pc; // Use octave 4 as sample
                            nextChordPcNames.Add(TheoryPitch.GetPitchNameFromMidi(sampleMidi, nextChord.Key));
                        }
                        UnityEngine.Debug.Log($"[FirstChord Debug] Resolution-aware 7th placement: chord={chordEvent.Recipe}, seventhPc={seventhPc}, chosenMidi={resolutionAwareSeventhMidi.Value} ({seventhName}), nextChord={nextChord.Recipe}, nextChordPcs=[{string.Join(",", nextChordPcNames)}]");
                    }
                }
            }

            // Calculate number of upper voices needed
            int upperVoices = numVoices - 1; // 2 or 3 upper voices

            // Build upper voices in close position
            var upperVoicesMidi = new List<int>();
            
            // Build candidate pitch classes (needed for debug logging and potential use)
            var chordTonePcsForDebug = GetChordTonePitchClasses(chordEvent);
            var candidatePcsForDebug = new HashSet<int>(chordTonePcsForDebug);
            var reqForDebug = chordEvent.Recipe.RequestedExtensions;
            if (reqForDebug.HasAny)
            {
                int rootPcForTensions = chordTonePcsForDebug[0];
                if (reqForDebug.TensionFlat9)
                {
                    candidatePcsForDebug.Add((rootPcForTensions + 1) % 12); // b9
                }
                else if (reqForDebug.Tension9)
                {
                    candidatePcsForDebug.Add((rootPcForTensions + 2) % 12); // 9
                }
                if (reqForDebug.TensionSharp11)
                {
                    candidatePcsForDebug.Add((rootPcForTensions + 6) % 12); // #11
                }
            }
            var availablePcsForDebug = new List<int>(candidatePcsForDebug);

            // Handle melody constraint if present
            if (chordEvent.MelodyMidi.HasValue)
            {
                int melodyMidi = chordEvent.MelodyMidi.Value;
                int melodyPc = (melodyMidi % 12 + 12) % 12;
                
                // Force soprano (highest voice) to melody note
                upperVoicesMidi.Add(melodyMidi);
                
                // Get chord tone pitch classes using GetChordTonePitchClasses (same as VoiceNextChord)
                var chordTonePcs = GetChordTonePitchClasses(chordEvent);
                
                // Build candidate pitch classes: chord tones + requested tensions (same as VoiceNextChord)
                var candidatePcs = new HashSet<int>(chordTonePcs);
                var req = chordEvent.Recipe.RequestedExtensions;
                if (req.HasAny)
                {
                    int rootPcForTensions = chordTonePcs[0]; // Root is first in GetChordTonePitchClasses
                    // Add requested tension PCs (mutually exclusive: b9 excludes 9)
                    if (req.TensionFlat9)
                    {
                        candidatePcs.Add((rootPcForTensions + 1) % 12); // b9
                        // Explicitly do NOT add natural 9
                    }
                    else if (req.Tension9)
                    {
                        candidatePcs.Add((rootPcForTensions + 2) % 12); // 9
                    }
                    if (req.TensionSharp11)
                    {
                        candidatePcs.Add((rootPcForTensions + 6) % 12); // #11
                    }
                }
                
                // Get available pitch classes (exclude melody to avoid duplicates)
                var availablePcs = new List<int>(candidatePcs);
                availablePcs.RemoveAll(pc => pc == melodyPc);
                
                // Debug logging: Show candidatePCs immediately after construction (WITH melody)
                if (s_debugTensionDetect && chordIndex >= 0)
                {
                    string candidatePcsStr = string.Join(",", candidatePcs.OrderBy(x => x));
                    // High-level summary (always on)
                    if (req.HasAny)
                    {
                        var reqList = new List<string>();
                        if (req.TensionFlat9) reqList.Add("b9");
                        if (req.Tension9) reqList.Add("9");
                        if (req.TensionSharp11) reqList.Add("#11");
                        string reqStr = string.Join(",", reqList);
                        UnityEngine.Debug.Log($"Chord {chordIndex}: requested tensions = [{reqStr}]");
                    }
                    
                    // Verbose details (gated)
                    if (s_debugTensionVerbose)
                    {
                        string availablePcsStr = string.Join(",", availablePcs.OrderBy(x => x));
                        UnityEngine.Debug.Log(
                            $"[PLAY_DEBUG] Chord {chordIndex} (WITH melody): candidatePCs=[{candidatePcsStr}]\n" +
                            $"  availablePcs (after removing melody)={availablePcsStr}\n" +
                            $"  RequestedExtensions.b9={req.TensionFlat9}, b9PC={(req.TensionFlat9 ? (chordTonePcs[0] + 1) % 12 : -1)}");
                    }
                }
                
                // Generate candidates below the melody note
                var candidates = GenerateCandidatesInRange(availablePcs, upperMinMidi, Math.Min(upperMaxMidi, melodyMidi - 1));
                
                // Check if the 7th is the melody note
                bool seventhIsMelody = hasSeventh && seventhPc >= 0 && seventhPc == melodyPc;
                
                // If we have resolution-aware 7th placement and 7th is not the melody, prefer it in candidates
                if (hasSeventh && !seventhIsMelody && resolutionAwareSeventhMidi.HasValue)
                {
                    int resolvedSeventhMidi = resolutionAwareSeventhMidi.Value;
                    // Only use resolution-aware placement if it's below the melody and in range
                    if (resolvedSeventhMidi < melodyMidi && 
                        resolvedSeventhMidi >= upperMinMidi && 
                        resolvedSeventhMidi <= upperMaxMidi &&
                        !candidates.Contains(resolvedSeventhMidi))
                    {
                        // Insert resolution-aware 7th at the front of candidates to prioritize it
                        candidates.Insert(0, resolvedSeventhMidi);
                    }
                }
                
                // Fill remaining upper voices (need upperVoices - 1 more, since melody takes one slot)
                int remainingVoices = upperVoices - 1;
                var usedPcs = new HashSet<int> { melodyPc };
                
                for (int i = 0; i < remainingVoices; i++)
                {
                    int bestCandidate = -1;
                    
                    // First, try to use candidates from the generated list
                    if (candidates.Count > 0)
                    {
                        foreach (int candidate in candidates)
                        {
                            if (candidate < melodyMidi && !upperVoicesMidi.Contains(candidate))
                            {
                                bestCandidate = candidate;
                                break; // Take first valid candidate (they're sorted)
                            }
                        }
                        
                        if (bestCandidate >= 0)
                        {
                            upperVoicesMidi.Add(bestCandidate);
                            candidates.Remove(bestCandidate);
                        }
                    }
                    
                    // If no candidate found, use fallback
                    if (bestCandidate < 0)
                    {
                        if (availablePcs.Count > 0)
                        {
                            // Try each available pitch class until we find one that can be placed correctly
                            bool foundFallback = false;
                            for (int pcIndex = 0; pcIndex < availablePcs.Count && !foundFallback; pcIndex++)
                            {
                                int fallbackPc = availablePcs[pcIndex];
                                int fallbackMidi = PlaceInMidRegister(fallbackPc, upperMinMidi, Math.Min(upperMaxMidi, melodyMidi - 1));
                                
                                // Verify the placed note actually has the correct pitch class
                                int placedPc = (fallbackMidi % 12 + 12) % 12;
                                if (placedPc != fallbackPc)
                                {
                                    // PlaceInMidRegister clamped to wrong pitch class, try adjacent octaves
                                    if (fallbackMidi >= upperMinMidi + 12)
                                    {
                                        fallbackMidi -= 12; // Try an octave lower
                                        placedPc = (fallbackMidi % 12 + 12) % 12;
                                    }
                                    else if (fallbackMidi <= Math.Min(upperMaxMidi, melodyMidi - 1) - 12)
                                    {
                                        fallbackMidi += 12; // Try an octave higher
                                        placedPc = (fallbackMidi % 12 + 12) % 12;
                                    }
                                }
                                
                                // Only use this fallback if it has the correct pitch class and is in range
                                if (placedPc == fallbackPc &&
                                    fallbackMidi >= upperMinMidi &&
                                    fallbackMidi < melodyMidi &&
                                    !upperVoicesMidi.Contains(fallbackMidi))
                                {
                                    upperVoicesMidi.Add(fallbackMidi);
                                    foundFallback = true;
                                }
                            }
                            
                            // If we still haven't found a valid fallback, try using GenerateCandidatesInRange
                            // which will find all valid octaves, even if they're outside the initial range
                            if (!foundFallback && availablePcs.Count > 0)
                            {
                                // Try each remaining available pitch class with expanded range
                                for (int pcIndex = 0; pcIndex < availablePcs.Count && !foundFallback; pcIndex++)
                                {
                                    int fallbackPc = availablePcs[pcIndex];
                                    // Expand range slightly to allow lower octaves
                                    int expandedMin = Math.Max(upperMinMidi - 12, 48);
                                    var expandedCandidates = GenerateCandidatesInRange(new List<int> { fallbackPc }, expandedMin, Math.Min(upperMaxMidi, melodyMidi - 1));
                                    foreach (int candidate in expandedCandidates)
                                    {
                                        // Sanity-check the pitch class matches
                                        int candPc = (candidate % 12 + 12) % 12;
                                        if (candPc == fallbackPc && candidate < melodyMidi && !upperVoicesMidi.Contains(candidate))
                                        {
                                            upperVoicesMidi.Add(candidate);
                                            foundFallback = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                // Original logic when no melody constraint
                // Get chord tone pitch classes using GetChordTonePitchClasses (same as VoiceNextChord)
                var chordTonePcs = GetChordTonePitchClasses(chordEvent);
                
                // Build candidate pitch classes: chord tones + requested tensions (same as VoiceNextChord)
                var candidatePcs = new HashSet<int>(chordTonePcs);
                var req = chordEvent.Recipe.RequestedExtensions;
                if (req.HasAny)
                {
                    int rootPcForTensions = chordTonePcs[0]; // Root is first in GetChordTonePitchClasses
                    // Add requested tension PCs (mutually exclusive: b9 excludes 9)
                    if (req.TensionFlat9)
                    {
                        candidatePcs.Add((rootPcForTensions + 1) % 12); // b9
                        // Explicitly do NOT add natural 9
                    }
                    else if (req.Tension9)
                    {
                        candidatePcs.Add((rootPcForTensions + 2) % 12); // 9
                    }
                    if (req.TensionSharp11)
                    {
                        candidatePcs.Add((rootPcForTensions + 6) % 12); // #11
                    }
                }
                
                // Convert to list for use in candidate generation
                var availablePcs = new List<int>(candidatePcs);
                
                // Debug logging: Show candidatePCs immediately after construction (NO melody)
                if (s_debugTensionDetect && chordIndex >= 0)
                {
                    string candidatePcsStr = string.Join(",", candidatePcs.OrderBy(x => x));
                    int b9Pc = req.TensionFlat9 ? (chordTonePcs[0] + 1) % 12 : -1;
                    UnityEngine.Debug.Log(
                        $"[PLAY_DEBUG] Chord {chordIndex} (NO melody): candidatePCs=[{candidatePcsStr}]\n" +
                        $"  RequestedExtensions.b9={req.TensionFlat9}, b9PC={b9Pc}\n" +
                        $"  Register limits: upperMinMidi={upperMinMidi}, upperMaxMidi={upperMaxMidi}, bassOctave={bassOctave}");
                    
                    // Generate ALL candidates from candidatePcs to see what's available
                    var allCandidates = GenerateCandidatesInRange(availablePcs, upperMinMidi, upperMaxMidi);
                    var b9Candidates = allCandidates.Where(m => (m % 12 + 12) % 12 == b9Pc).ToList();
                    
                    if (s_debugTensionVerbose)
                    {
                        UnityEngine.Debug.Log(
                            $"[PLAY_DEBUG] Chord {chordIndex} candidate enumeration:\n" +
                            $"  Total candidates from candidatePCs: {allCandidates.Count}\n" +
                            $"  Candidates with pc={b9Pc} (b9): {b9Candidates.Count}\n" +
                            $"  b9 candidate MIDI examples: {(b9Candidates.Count > 0 ? string.Join(",", b9Candidates.Take(5)) : "NONE")}\n" +
                            $"  All candidate MIDI range: {(allCandidates.Count > 0 ? $"{allCandidates.Min()}-{allCandidates.Max()}" : "NONE")}");
                    }
                }
                
                if (hasSeventh)
                {
                    // 7th chord voicing - use pitch classes from GetChordTonePitchClasses
                    // chordTonePcs order: [root, 3rd/4th (sus4), 5th, 7th, ...add-tones]
                    int thirdOrFourthPc = chordTonePcs.Count > 1 ? chordTonePcs[1] : thirdPc; // Use from GetChordTonePitchClasses (handles sus4)
                    int fifthPcFromChordTones = chordTonePcs.Count > 2 ? chordTonePcs[2] : fifthPc;
                    int seventhPcFromChordTones = (chordTonePcs.Count > 3) ? chordTonePcs[3] : seventhPc;
                    
                    // Determine 7th MIDI: use resolution-aware placement if available, otherwise use mid-register
                    int seventhMidi;
                    if (resolutionAwareSeventhMidi.HasValue)
                    {
                        seventhMidi = resolutionAwareSeventhMidi.Value;
                    }
                    else
                    {
                        seventhMidi = PlaceInMidRegister(seventhPcFromChordTones, upperMinMidi, upperMaxMidi);
                        
                        if (enableTendencyDebug && canLookAhead)
                        {
                            UnityEngine.Debug.Log($"[FirstChord Debug] No resolution-aware placement found, using mid-register for 7th: seventhPc={seventhPcFromChordTones}, midi={seventhMidi}");
                        }
                    }
                    
                    if (upperVoices == 2)
                    {
                        // 3 voices total: bass = root, upper = [3rd/4th, 7th]
                        upperVoicesMidi.Add(PlaceInMidRegister(thirdOrFourthPc, upperMinMidi, upperMaxMidi));
                        upperVoicesMidi.Add(seventhMidi);
                    }
                    else // upperVoices == 3
                    {
                        // 4 voices total: bass = root, upper = [3rd/4th, 5th, 7th]
                        upperVoicesMidi.Add(PlaceInMidRegister(thirdOrFourthPc, upperMinMidi, upperMaxMidi));
                        upperVoicesMidi.Add(PlaceInMidRegister(fifthPcFromChordTones, upperMinMidi, upperMaxMidi));
                        upperVoicesMidi.Add(seventhMidi);
                    }
                }
                else
                {
                    // Triad voicing - use pitch classes from GetChordTonePitchClasses
                    // chordTonePcs order: [root, 3rd/4th (sus4), 5th, ...add-tones]
                    int thirdOrFourthPc = chordTonePcs.Count > 1 ? chordTonePcs[1] : thirdPc; // Use from GetChordTonePitchClasses (handles sus4)
                    int fifthPcFromChordTones = chordTonePcs.Count > 2 ? chordTonePcs[2] : fifthPc;
                    
                    if (upperVoices == 2)
                    {
                        // 3 voices total: bass = root, upper = [3rd/4th, 5th]
                        upperVoicesMidi.Add(PlaceInMidRegister(thirdOrFourthPc, upperMinMidi, upperMaxMidi));
                        upperVoicesMidi.Add(PlaceInMidRegister(fifthPcFromChordTones, upperMinMidi, upperMaxMidi));
                    }
                    else // upperVoices == 3
                    {
                        // 4 voices total: bass = root, upper = [3rd/4th, 5th, root+12]
                        upperVoicesMidi.Add(PlaceInMidRegister(thirdOrFourthPc, upperMinMidi, upperMaxMidi));
                        upperVoicesMidi.Add(PlaceInMidRegister(fifthPcFromChordTones, upperMinMidi, upperMaxMidi));
                        
                        // Add root an octave above, ensuring it fits in range and is above the 5th
                        int rootOctaveAbove = PlaceInMidRegister(rootPc, upperMinMidi, upperMaxMidi);
                        // If root in mid register is below or equal to the 5th, move it up an octave
                        if (rootOctaveAbove <= upperVoicesMidi[upperVoicesMidi.Count - 1])
                        {
                            rootOctaveAbove += 12;
                            // Clamp to max if needed
                            if (rootOctaveAbove > upperMaxMidi)
                            {
                                rootOctaveAbove -= 12;
                            }
                        }
                        upperVoicesMidi.Add(rootOctaveAbove);
                    }
                }
            }

            // Ensure upper voices are strictly ascending
            // If there's a melody, treat that as the soprano and keep it as the top voice.
            if (chordEvent.MelodyMidi.HasValue)
            {
                int sopranoMidi = chordEvent.MelodyMidi.Value;

                // Sort all the upper voices first
                upperVoicesMidi.Sort();

                // Find the melody/soprano in the sorted list
                int idx = upperVoicesMidi.IndexOf(sopranoMidi);
                if (idx >= 0 && idx != upperVoicesMidi.Count - 1)
                {
                    // Move the soprano to the end so it is the highest voice
                    upperVoicesMidi.RemoveAt(idx);
                    upperVoicesMidi.Add(sopranoMidi);
                }
            }
            else
            {
                upperVoicesMidi.Sort();
            }

            // Assemble final voicing: bass + upper voices
            var allVoices = new List<int> { bassVoice };
            allVoices.AddRange(upperVoicesMidi);
            var voicesArray = allVoices.ToArray();
            
            // CHECKPOINT B: Right before voicing selection begins (after initial voicing construction)
            if (s_debugTensionDetect && chordIndex >= 0)
            {
                string token = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                var chordTonePcs = GetChordTonePitchClasses(chordEvent);
                var req = chordEvent.Recipe.RequestedExtensions;
                
                // Determine required tones (root, 3rd, 7th for 7th chords)
                var requiredTonePcs = new List<int>();
                if (chordTonePcs.Count >= 1) requiredTonePcs.Add(chordTonePcs[0]); // Root
                if (chordTonePcs.Count >= 2) requiredTonePcs.Add(chordTonePcs[1]); // 3rd
                if (chordTonePcs.Count >= 4) requiredTonePcs.Add(chordTonePcs[3]); // 7th
                
                var realizedPcs = new HashSet<int>();
                foreach (int midi in voicesArray)
                    realizedPcs.Add((midi % 12 + 12) % 12);
                
                var missingRequired = new List<int>();
                foreach (int requiredPc in requiredTonePcs)
                {
                    if (!realizedPcs.Contains(requiredPc))
                        missingRequired.Add(requiredPc);
                }
                
                bool hasSeventhInChordTones = chordTonePcs.Count >= 4;
                int seventhPcFromChordTones = hasSeventhInChordTones ? chordTonePcs[3] : -1;
                bool seventhPresentInVoicing = seventhPcFromChordTones >= 0 && realizedPcs.Contains(seventhPcFromChordTones);
                
                UnityEngine.Debug.Log(
                    $"[CHECKPOINT_B] step={chordIndex} token='{token}' BEFORE_VOICING_SELECTION:\n" +
                    $"  chordTonePcs=[{string.Join(",", chordTonePcs)}]\n" +
                    $"  requiredTonePcs=[{string.Join(",", requiredTonePcs)}] (root,3rd,7th)\n" +
                    $"  initialVoicingMIDI=[{string.Join(",", voicesArray)}]\n" +
                    $"  realizedPCs=[{string.Join(",", realizedPcs.OrderBy(x => x))}]\n" +
                    $"  hasSeventhInChordTones={hasSeventhInChordTones}, seventhPc={seventhPcFromChordTones}, seventhPresentInVoicing={seventhPresentInVoicing}\n" +
                    $"  missingRequiredTones=[{string.Join(",", missingRequired)}]");
            }
            
            // CHECKPOINT 1: After initial voicing creation
            bool? seventhWasPresent = null;
            LogSeventhCheckpoint("AfterInitialVoicing", chordIndex >= 0 ? chordIndex : 0, chordEvent, voicesArray, false, ref seventhWasPresent);
            
                // Debug logging: BEFORE FixChordToneCoverage - per-voice candidate availability
                if (s_debugTensionVerbose && s_debugTensionDetect && chordIndex >= 0)
                {
                    var req = chordEvent.Recipe.RequestedExtensions;
                    int b9Pc = req.TensionFlat9 ? (rootPc + 1) % 12 : -1;
                    
                    int tenorMidi = voicesArray.Length > 1 ? voicesArray[1] : -1;
                    int altoMidi = voicesArray.Length > 2 ? voicesArray[2] : -1;
                    int sopranoMidi = voicesArray.Length > 3 ? voicesArray[3] : -1;
                    int bassRangeMin = bassOctave * 12;
                    int bassRangeMax = (bassOctave + 1) * 12;
                    
                    UnityEngine.Debug.Log(
                        $"[PLAY_DEBUG] Chord {chordIndex} BEFORE FixChordToneCoverage - per-voice analysis:\n" +
                        $"  Initial voicing: B={voicesArray[0]}, T={tenorMidi}, A={altoMidi}, S={sopranoMidi}\n" +
                        $"  Register limits: bassOctave={bassOctave} (bass range ~{bassRangeMin}-{bassRangeMax}), upperMinMidi={upperMinMidi}, upperMaxMidi={upperMaxMidi}\n" +
                        $"  candidatePCs available: [{string.Join(",", candidatePcsForDebug.OrderBy(x => x))}]");
                    
                    // For each upper voice, show candidate availability
                    for (int v = 1; v < voicesArray.Length; v++)
                    {
                        string voiceName = v == 1 ? "Tenor" : v == 2 ? "Alto" : "Soprano";
                        int currentMidi = voicesArray[v];
                        int currentPc = (currentMidi % 12 + 12) % 12;
                        
                        // Generate candidates for this voice's range (approximate: tenor/alto/soprano ranges)
                        // Use the full upper range since we don't have per-voice ranges in VoiceFirstChord
                        var voiceCandidates = GenerateCandidatesInRange(availablePcsForDebug, upperMinMidi, upperMaxMidi);
                        var b9VoiceCandidates = voiceCandidates.Where(m => (m % 12 + 12) % 12 == b9Pc).ToList();
                        
                        string b9Examples = b9VoiceCandidates.Count > 0 ? string.Join(",", b9VoiceCandidates.Take(5)) : "NONE";
                        string candidateRange = voiceCandidates.Count > 0 ? $"{voiceCandidates.Min()}-{voiceCandidates.Max()}" : "NONE";
                        
                        UnityEngine.Debug.Log(
                            $"[PLAY_DEBUG]   {voiceName} (voice {v}): current={currentMidi} (pc={currentPc})\n" +
                            $"    Total candidates in range [{upperMinMidi}-{upperMaxMidi}]: {voiceCandidates.Count}\n" +
                            $"    Candidates with pc={b9Pc} (b9): {b9VoiceCandidates.Count}\n" +
                            $"    b9 candidate examples: {b9Examples}\n" +
                            $"    Candidate MIDI range: {candidateRange}");
                    }
                }
            
            // Compute spacing penalty for complete SATB voicing (for diagnostics)
            if (voicesArray.Length >= 4)
            {
                int candidateBass = voicesArray[0];
                int candidateTenor = voicesArray[1];
                int candidateAlto = voicesArray[2];
                int candidateSoprano = voicesArray[3];
                
                float spacingPenalty = GetSpacingPenalty(candidateBass, candidateTenor, candidateAlto, candidateSoprano);
                if (spacingPenalty != 0f && GetTendencyDebug())
                {
                    UnityEngine.Debug.Log(
                        $"[Spacing Soft] VoiceFirstChord: B={candidateBass}, T={candidateTenor}, A={candidateAlto}, S={candidateSoprano}, penalty={spacingPenalty}");
                }
            }
            
            // No locked resolutions for the first chord (no previous chord to resolve from)
            // If we have a melody, never allow coverage to overwrite the soprano (melody) voice.
            bool hasMelody = chordEvent.MelodyMidi.HasValue;
            bool fixCoverageCalled = false;
            if (hasMelody)
            {
                fixCoverageCalled = true;
                FixChordToneCoverage(
                    chordEvent,
                    voicesArray,
                    numVoices,
                    upperMinMidi,
                    upperMaxMidi,
                    protectSoprano: true,
                    lockedResolutionVoices: null,
                    stepIndex: chordIndex >= 0 ? chordIndex : 0);
            }
            else
            {
                fixCoverageCalled = true;
                FixChordToneCoverage(
                    chordEvent,
                    voicesArray,
                    numVoices,
                    upperMinMidi,
                    upperMaxMidi,
                    protectSoprano: false,
                    lockedResolutionVoices: null,
                    stepIndex: chordIndex >= 0 ? chordIndex : 0);
            }
            
            // CHECKPOINT 2: After FixChordToneCoverage
            LogSeventhCheckpoint("AfterFixChordToneCoverage", chordIndex >= 0 ? chordIndex : 0, chordEvent, voicesArray, seventhWasPresent ?? false, ref seventhWasPresent);
            
            // REGRESSION DIAGNOSTIC: Stage 2 - Post-FixChordToneCoverage
            LogRequiredChordTonesDiagnostic("PostFixCoverage", chordIndex >= 0 ? chordIndex : 0, chordEvent, voicesArray, originalToken);
            
            // AUG5_SNAP: Log state after FixChordToneCoverage (gated by debug flag)
            if (s_enableAug5Debug && chordIndex == 2 && voicesArray != null && voicesArray.Length >= 4) // chord IV in repro
            {
                string roman = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                string bassName = TheoryPitch.GetPitchNameFromMidi(voicesArray[0], chordEvent.Key);
                string tenorName = TheoryPitch.GetPitchNameFromMidi(voicesArray[1], chordEvent.Key);
                string altoName = TheoryPitch.GetPitchNameFromMidi(voicesArray[2], chordEvent.Key);
                string sopranoName = TheoryPitch.GetPitchNameFromMidi(voicesArray[3], chordEvent.Key);
                UnityEngine.Debug.Log(
                    $"[AUG5_SNAP] stage=PostFixCoverage chordIndex={chordIndex} roman={roman} SATB=[Bass={voicesArray[0]}({bassName}), Tenor={voicesArray[1]}({tenorName}), Alto={voicesArray[2]}({altoName}), Soprano={voicesArray[3]}({sopranoName})]");
            }
            
            // STAGE SNAPSHOT: PostFixCoverage for diminished triads
            if (chordEvent.Recipe.Quality == ChordQuality.Diminished)
            {
                bool dimTriadHasSeventh = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                                          chordEvent.Recipe.SeventhQuality != SeventhQuality.None;
                if (!dimTriadHasSeventh) // Only triads, not dim7
                {
                    var dimTriadChordTonePcs = GetChordTonePitchClasses(chordEvent);
                    if (dimTriadChordTonePcs != null && dimTriadChordTonePcs.Count >= 3)
                    {
                        int dimTriadRootPc = dimTriadChordTonePcs[0];
                        int dimTriadThirdPc = dimTriadChordTonePcs[1];
                        int dimTriadFifthPc = dimTriadChordTonePcs[2];
                        int dimTriadThirdInterval = (dimTriadThirdPc - dimTriadRootPc + 12) % 12;
                        int dimTriadFifthInterval = (dimTriadFifthPc - dimTriadRootPc + 12) % 12;
                        if (dimTriadThirdInterval == 3 && dimTriadFifthInterval == 6) // Valid dim triad
                        {
                            var requiredIdentityPcs = new HashSet<int> { dimTriadRootPc, dimTriadThirdPc, dimTriadFifthPc };
                            string label = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            LogStageSnapshot_DimTriad(
                                "PostFixCoverage",
                                chordIndex >= 0 ? chordIndex : 0,
                                originalToken ?? label,
                                label,
                                voicesArray,
                                requiredIdentityPcs,
                                chordEvent.Key);
                        }
                    }
                }
            }
            
            // CRITICAL: In SATB-with-melody mode, enforce strict ordering after coverage fix
            // Repair ordering violations by pitch adjustment (not lane swap) to preserve lane identity
            if (hasMelody && voicesArray != null && voicesArray.Length >= 4)
            {
                bool hasViolation = ViolatesVoiceOrdering(voicesArray);
                if (hasViolation)
                {
                    // Get chord tone pitch classes for repair
                    var chordTonePcs = GetChordTonePitchClasses(chordEvent);
                    var requiredPcsSet = chordTonePcs != null ? new HashSet<int>(chordTonePcs) : null;
                    
                    // Build min/max arrays for each voice
                    int[] minMidiByVoice = new int[4];
                    int[] maxMidiByVoice = new int[4];
                    minMidiByVoice[0] = bassOctave * 12; // Bass
                    maxMidiByVoice[0] = (bassOctave + 1) * 12 - 1;
                    minMidiByVoice[1] = upperMinMidi; // Tenor
                    maxMidiByVoice[1] = upperMaxMidi;
                    minMidiByVoice[2] = upperMinMidi; // Alto
                    maxMidiByVoice[2] = upperMaxMidi;
                    minMidiByVoice[3] = upperMinMidi; // Soprano
                    maxMidiByVoice[3] = upperMaxMidi;
                    
                    // Attempt repair by pitch adjustment
                    bool repaired = RepairOrderingByPitchAdjustment(voicesArray, minMidiByVoice, maxMidiByVoice, requiredPcsSet, chordEvent, chordIndex);
                    
                    if (repaired)
                    {
                        // Log repair success for chord IV
                        if (chordIndex == 2)
                        {
                            string roman = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            string bassName = TheoryPitch.GetPitchNameFromMidi(voicesArray[0], chordEvent.Key);
                            string tenorName = TheoryPitch.GetPitchNameFromMidi(voicesArray[1], chordEvent.Key);
                            string altoName = TheoryPitch.GetPitchNameFromMidi(voicesArray[2], chordEvent.Key);
                            string sopranoName = TheoryPitch.GetPitchNameFromMidi(voicesArray[3], chordEvent.Key);
                            UnityEngine.Debug.Log(
                                $"[ORDERING_REPAIR] After repair chordIndex={chordIndex} roman={roman}: " +
                                $"B={voicesArray[0]}({bassName}) T={voicesArray[1]}({tenorName}) A={voicesArray[2]}({altoName}) S={voicesArray[3]}({sopranoName})");
                        }
                    }
                    
                    // Enforce strict ordering (will attempt repair if still violated)
                    EnforceVoiceOrderingBTAS(voicesArray, minMidiByVoice, maxMidiByVoice, requiredPcsSet, true); // strictMode=true
                }
            }
            
            // CHECKPOINT C: Right after FixChordToneCoverage / repair passes
            if (s_debugTensionDetect && chordIndex >= 0)
            {
                string token = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                var chordTonePcs = GetChordTonePitchClasses(chordEvent);
                
                var realizedPcs = new HashSet<int>();
                var voiceDetails = new List<string>();
                for (int i = 0; i < voicesArray.Length && i < 4; i++)
                {
                    int midi = voicesArray[i];
                    int pc = (midi % 12 + 12) % 12;
                    realizedPcs.Add(pc);
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                    voiceDetails.Add($"{voiceName}={midi}({pitchName},pc={pc})");
                }
                
                // Check which required tones are present/missing
                var requiredTonePcs = new List<int>();
                if (chordTonePcs.Count >= 1) requiredTonePcs.Add(chordTonePcs[0]); // Root
                if (chordTonePcs.Count >= 2) requiredTonePcs.Add(chordTonePcs[1]); // 3rd
                if (chordTonePcs.Count >= 4) requiredTonePcs.Add(chordTonePcs[3]); // 7th
                
                var presentRequired = new List<int>();
                var missingRequired = new List<int>();
                foreach (int requiredPc in requiredTonePcs)
                {
                    if (realizedPcs.Contains(requiredPc))
                        presentRequired.Add(requiredPc);
                    else
                        missingRequired.Add(requiredPc);
                }
                
                bool hasSeventhInChordTones = chordTonePcs.Count >= 4;
                int seventhPcFromChordTones = hasSeventhInChordTones ? chordTonePcs[3] : -1;
                bool seventhPresentInVoicing = seventhPcFromChordTones >= 0 && realizedPcs.Contains(seventhPcFromChordTones);
                
                UnityEngine.Debug.Log(
                    $"[CHECKPOINT_C] step={chordIndex} token='{token}' AFTER_FIX_COVERAGE:\n" +
                    $"  chordTonePcs=[{string.Join(",", chordTonePcs)}]\n" +
                    $"  requiredTonePcs=[{string.Join(",", requiredTonePcs)}] (root,3rd,7th)\n" +
                    $"  voicesMIDI=[{string.Join(",", voicesArray)}]\n" +
                    $"  voiceDetails: {string.Join(" ", voiceDetails)}\n" +
                    $"  realizedPCs=[{string.Join(",", realizedPcs.OrderBy(x => x))}]\n" +
                    $"  hasSeventhInChordTones={hasSeventhInChordTones}, seventhPc={seventhPcFromChordTones}, seventhPresentInVoicing={seventhPresentInVoicing}\n" +
                    $"  presentRequired=[{string.Join(",", presentRequired)}], missingRequired=[{string.Join(",", missingRequired)}]");
            }
            
            // CRITICAL FIX: Post-enforcement invariant guard for first chord
            // Ensure B <= T <= A <= S after FixChordToneCoverage
            if (chordIndex == 0 && voicesArray.Length >= 2)
            {
                bool hasViolation = ViolatesVoiceOrdering(voicesArray);
                
                if (hasViolation)
                {
                    int bassMidiCurrent = voicesArray.Length > 0 ? voicesArray[0] : -1;
                    int tenorMidiCurrent = voicesArray.Length > 1 ? voicesArray[1] : -1;
                    int altoMidiCurrent = voicesArray.Length > 2 ? voicesArray[2] : -1;
                    int sopranoMidiCurrent = voicesArray.Length > 3 ? voicesArray[3] : -1;
                    
                    UnityEngine.Debug.LogWarning(
                        $"[VOICE_ORDERING] First chord (chordIndex=0) has voice crossing after FixChordToneCoverage:\n" +
                        $"  B={bassMidiCurrent} T={tenorMidiCurrent} A={altoMidiCurrent} S={sopranoMidiCurrent}\n" +
                        $"  Attempting correction...");
                    
                    bool corrected = CorrectVoiceOrdering(voicesArray, upperMinMidi, upperMaxMidi);
                    
                    if (corrected)
                    {
                        int bassMidiAfter = voicesArray.Length > 0 ? voicesArray[0] : -1;
                        int tenorMidiAfter = voicesArray.Length > 1 ? voicesArray[1] : -1;
                        int altoMidiAfter = voicesArray.Length > 2 ? voicesArray[2] : -1;
                        int sopranoMidiAfter = voicesArray.Length > 3 ? voicesArray[3] : -1;
                        UnityEngine.Debug.Log(
                            $"[VOICE_ORDERING] Correction applied:\n" +
                            $"  B={bassMidiAfter} T={tenorMidiAfter} A={altoMidiAfter} S={sopranoMidiAfter}");
                    }
                    else
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[VOICE_ORDERING] Could not correct voice crossing - no legal octave shift available");
                    }
                    
                    #if UNITY_EDITOR
                    if (ViolatesVoiceOrdering(voicesArray))
                    {
                        UnityEngine.Debug.LogError(
                            $"[VOICE_ORDERING] CRITICAL: First chord still has voice crossing after correction attempt!");
                    }
                    #endif
                }
            }
            
            // DIAGNOSTIC: Exit trace immediately after VoiceFirstChord calls FixChordToneCoverage (stepIndex==0)
            if (chordIndex == 0 && chordEvent.Recipe.RequestedExtensions.HasAny)
            {
                var req = chordEvent.Recipe.RequestedExtensions;
                int requiredB9Pc = req.TensionFlat9 ? (rootPc + 1) % 12 : -1;
                
                var exitVoices = new List<string>();
                var exitPcs = new List<int>();
                for (int i = 0; i < voicesArray.Length && i < 4; i++)
                {
                    int midi = voicesArray[i];
                    int pc = (midi % 12 + 12) % 12;
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    exitVoices.Add($"{voiceName}={midi}(pc={pc})");
                    exitPcs.Add(pc);
                }
                
                bool b9Present = requiredB9Pc >= 0 && exitPcs.Contains(requiredB9Pc);
                string b9Status = requiredB9Pc >= 0 ? (b9Present ? "PRESENT" : "MISSING") : "N/A";
                
                UnityEngine.Debug.Log(
                    $"[EXIT_TRACE_VoiceFirstChord_AfterFixCoverage] === AFTER FixChordToneCoverage in VoiceFirstChord (chordIndex=0) ===\n" +
                    $"  voices MIDI array (BTAS): [{string.Join(", ", voicesArray)}]\n" +
                    $"  pitch classes: [{string.Join(", ", exitPcs)}]\n" +
                    $"  voice details: {string.Join(" ", exitVoices)}\n" +
                    $"  requiredB9Pc={requiredB9Pc}, b9Status={b9Status}\n" +
                    $"  rootPc={rootPc}, RequestedExtensions.b9={req.TensionFlat9}");
            }
            
            // Debug logging: AFTER FixChordToneCoverage
            if (s_debugTensionVerbose && s_debugTensionDetect && chordIndex >= 0)
            {
                var pcsAfter = new HashSet<int>();
                foreach (int m in voicesArray)
                    pcsAfter.Add((m % 12 + 12) % 12);
                string pcsAfterStr = string.Join(",", pcsAfter.OrderBy(x => x));
                var req = chordEvent.Recipe.RequestedExtensions;
                int b9Pc = (rootPc + 1) % 12;
                bool b9Present = pcsAfter.Contains(b9Pc);
                UnityEngine.Debug.Log(
                    $"[PLAY_DEBUG] Chord {chordIndex} AFTER FixChordToneCoverage:\n" +
                    $"  FixChordToneCoverage called={fixCoverageCalled}\n" +
                    $"  voicesArray=[{string.Join(",", voicesArray)}]\n" +
                    $"  finalRealizedPCs=[{pcsAfterStr}]\n" +
                    $"  RequestedExtensions.b9={req.TensionFlat9}, b9PC={b9Pc}, b9Present={b9Present}");
            }
            
            // Compute spacing penalty after FixChordToneCoverage (for diagnostics)
            if (voicesArray.Length >= 4)
            {
                int finalBass = voicesArray[0];
                int finalTenor = voicesArray[1];
                int finalAlto = voicesArray[2];
                int finalSoprano = voicesArray[3];
                
                float spacingPenalty = GetSpacingPenalty(finalBass, finalTenor, finalAlto, finalSoprano);
                if (spacingPenalty != 0f && GetTendencyDebug())
                {
                    UnityEngine.Debug.Log(
                        $"[Spacing Soft] VoiceFirstChord after FixChordToneCoverage: B={finalBass}, T={finalTenor}, A={finalAlto}, S={finalSoprano}, penalty={spacingPenalty}");
                }
            }
            
            // Debug: ensure the soprano still matches the melody on the first chord
            if (chordEvent.MelodyMidi.HasValue && voicesArray.Length >= 4 && GetTendencyDebug())
            {
                int melodyPc = ((chordEvent.MelodyMidi.Value % 12) + 12) % 12;
                int sopranoMidi = voicesArray[voicesArray.Length - 1];
                int sopranoPc = ((sopranoMidi % 12) + 12) % 12;
                
                if (melodyPc != sopranoPc)
                {
                    UnityEngine.Debug.LogWarning(
                        $"[FirstChord Debug] Soprano pitch class mismatch after coverage: melodyPc={melodyPc}, sopranoPc={sopranoPc}, melodyMidi={chordEvent.MelodyMidi.Value}, sopranoMidi={sopranoMidi}");
                }
            }

            // Final validation: check for voice crossing (debug/assertion only - should never trigger after fixes)
            if (!ValidateVoiceOrder(voicesArray, out string validationError))
            {
                if (enableTendencyDebug)
                {
                    UnityEngine.Debug.LogWarning($"[Voice Crossing] Final validation failed in VoiceFirstChord: {validationError}");
                }
            }

            // Final validation: check for hard spacing violations (debug/assertion only - should never trigger after fixes)
            if (voicesArray.Length >= 4)
            {
                int finalBassMidi = voicesArray[0];
                int finalTenorMidi = voicesArray[1];
                int finalAltoMidi = voicesArray[2];
                int finalSopranoMidi = voicesArray[3];
                
                if (ViolatesHardSpacing(finalBassMidi, finalTenorMidi, finalAltoMidi, finalSopranoMidi))
                {
                    if (GetTendencyDebug())
                    {
                        UnityEngine.Debug.LogWarning($"[Spacing Final Check] Chosen voicing violates hard spacing in VoiceFirstChord: B={finalBassMidi}, T={finalTenorMidi}, A={finalAltoMidi}, S={finalSopranoMidi}");
                    }
                }
            }

            // CRITICAL FIX: Enforce strict SATB ordering after first-chord voicing
            // This ensures Alto > Soprano violations are corrected via octave-only shifts
            // Use strict mode when melody is present (SATB-with-melody-lock)
            EnforceVoiceOrderingBTAS(voicesArray, null, null, null, hasMelody);
            
            // CHECKPOINT 3: After EnforceVoiceOrderingBTAS
            LogSeventhCheckpoint("AfterEnforceVoiceOrderingBTAS", chordIndex >= 0 ? chordIndex : 0, chordEvent, voicesArray, seventhWasPresent ?? false, ref seventhWasPresent);
            
            // CHECKPOINT D: After ordering/octave correction
            if (s_debugSharp9OctaveTrace && chordIndex == 0)
            {
                var req = chordEvent.Recipe.RequestedExtensions;
                if (req.TensionSharp9)
                {
                    string chordLabel = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    // rootPc is already declared above in VoiceFirstChord, compute sharp9Pc from it
                    int sharp9PcForTrace = (rootPc + 3) % 12;
                    int b = voicesArray.Length > 0 ? voicesArray[0] : -1;
                    int t = voicesArray.Length > 1 ? voicesArray[1] : -1;
                    int a = voicesArray.Length > 2 ? voicesArray[2] : -1;
                    int s = voicesArray.Length > 3 ? voicesArray[3] : -1;
                    bool containsPc10 = false;
                    string laneWithSharp9 = "none";
                    int midiWithSharp9 = -1;
                    for (int v = 0; v < voicesArray.Length; v++)
                    {
                        int voicePc = (voicesArray[v] % 12 + 12) % 12;
                        if (voicePc == sharp9PcForTrace)
                        {
                            containsPc10 = true;
                            laneWithSharp9 = v == 0 ? "B" : v == 1 ? "T" : v == 2 ? "A" : "S";
                            midiWithSharp9 = voicesArray[v];
                            break;
                        }
                    }
                    string pitchName = midiWithSharp9 >= 0 ? TheoryPitch.GetPitchNameFromMidi(midiWithSharp9, chordEvent.Key) : "none";
                    UnityEngine.Debug.Log(
                        $"[SHARP9_TRACE][POST_ORDER] step=0 chord={chordLabel} B={b} T={t} A={a} S={s} containsPc{sharp9PcForTrace}={containsPc10} laneWithSharp9={laneWithSharp9} midi={midiWithSharp9}({pitchName})");
                }
            }
            
            // CRITICAL: Check BTAS invariant after all post-processing
            if (voicesArray != null && voicesArray.Length >= 2)
            {
                string chordLabel = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                CheckAndLogBTASInvariant(voicesArray, chordIndex, chordLabel);
            }
            
            // Debug assert: verify ordering is never violated after first-chord voicing
            #if UNITY_EDITOR
            if (ViolatesVoiceOrdering(voicesArray))
            {
                UnityEngine.Debug.LogError(
                    $"[VOICE_ORDERING_ASSERT] CRITICAL: Voice ordering violation after VoiceFirstChord (chordIndex={chordIndex})!\n" +
                    $"  Voices (BTAS): [{string.Join(", ", voicesArray)}]\n" +
                    $"  Bass={voicesArray[0]}, Tenor={voicesArray[1]}, Alto={voicesArray[2]}, Soprano={voicesArray[3]}\n" +
                    $"  Violations: B>T={voicesArray[0] > voicesArray[1]}, T>A={voicesArray[1] > voicesArray[2]}, A>S={voicesArray[2] > voicesArray[3]}");
            }
            #endif
            
            // ENFORCEMENT: Ensure required 7th is present before returning (strict invariant)
            EnsureRequiredSeventhPresent(
                chordEvent,
                voicesArray,
                numVoices,
                upperMinMidi,
                upperMaxMidi,
                protectSoprano: hasMelody,
                stepIndex: chordIndex >= 0 ? chordIndex : 0);
            
            // CHECKPOINT 4: Before return (final check)
            LogSeventhCheckpoint("BeforeReturn", chordIndex >= 0 ? chordIndex : 0, chordEvent, voicesArray, seventhWasPresent ?? false, ref seventhWasPresent);
            
            // CHECKPOINT D: Final voicing before return
            if (s_debugTensionDetect && chordIndex >= 0)
            {
                string token = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                var chordTonePcs = GetChordTonePitchClasses(chordEvent);
                
                var realizedPcs = new HashSet<int>();
                var voiceDetails = new List<string>();
                for (int i = 0; i < voicesArray.Length && i < 4; i++)
                {
                    int midi = voicesArray[i];
                    int pc = (midi % 12 + 12) % 12;
                    realizedPcs.Add(pc);
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                    voiceDetails.Add($"{voiceName}={midi}({pitchName},pc={pc})");
                }
                
                bool hasSeventhInChordTones = chordTonePcs.Count >= 4;
                int seventhPcFromChordTones = hasSeventhInChordTones ? chordTonePcs[3] : -1;
                bool seventhPresentInVoicing = seventhPcFromChordTones >= 0 && realizedPcs.Contains(seventhPcFromChordTones);
                
                var missingRequired = new List<int>();
                if (chordTonePcs.Count >= 1 && !realizedPcs.Contains(chordTonePcs[0])) missingRequired.Add(chordTonePcs[0]);
                if (chordTonePcs.Count >= 2 && !realizedPcs.Contains(chordTonePcs[1])) missingRequired.Add(chordTonePcs[1]);
                if (chordTonePcs.Count >= 4 && !realizedPcs.Contains(chordTonePcs[3])) missingRequired.Add(chordTonePcs[3]);
                
                UnityEngine.Debug.Log(
                    $"[CHECKPOINT_D] step={chordIndex} token='{token}' FINAL_VOICING:\n" +
                    $"  chordTonePcs=[{string.Join(",", chordTonePcs)}]\n" +
                    $"  voicesMIDI=[{string.Join(",", voicesArray)}]\n" +
                    $"  voiceDetails: {string.Join(" ", voiceDetails)}\n" +
                    $"  realizedPCs=[{string.Join(",", realizedPcs.OrderBy(x => x))}]\n" +
                    $"  hasSeventhInChordTones={hasSeventhInChordTones}, seventhPc={seventhPcFromChordTones}, seventhPresentInVoicing={seventhPresentInVoicing}\n" +
                    $"  missingRequiredTones=[{string.Join(",", missingRequired)}]");
            }
            
            // CHECKPOINT 0: Log voicing array after first-chord tension placement (before VoicedChord creation)
            var reqForCheckpoint0 = chordEvent.Recipe.RequestedExtensions;
            bool hasB9ForCheckpoint0 = reqForCheckpoint0.TensionFlat9;
            bool shouldLogCheckpoint0 = hasB9ForCheckpoint0 || 
                                      (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano && reqForCheckpoint0.TensionFlat9);
            
            if (shouldLogCheckpoint0 && voicesArray.Length >= 4)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                UnityEngine.Debug.Log(
                    $"[CHECKPOINT_AFTER_FIRST_CHORD_PLACEMENT] step={chordIndex} chord={chordLabel} (VoiceFirstChord, after tension placement)\n" +
                    $"  SATB MIDI array: [{string.Join(", ", voicesArray)}]");
            }
            
            // DIAGNOSTIC: Exit trace before committing/storing first chord voicing (chordIndex==0)
            VoicedChord result = new VoicedChord
            {
                TimeBeats = chordEvent.TimeBeats,
                VoicesMidi = voicesArray
            };
            
            // CHECKPOINT 0b: Log voicing array after creating VoicedChord (VoiceFirstChord return)
            if (shouldLogCheckpoint0 && result.VoicesMidi != null && result.VoicesMidi.Length >= 4)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                UnityEngine.Debug.Log(
                    $"[CHECKPOINT_AFTER_VOICEDCHORD_FIRST] step={chordIndex} chord={chordLabel} (VoiceFirstChord return)\n" +
                    $"  VoicedChord.VoicesMidi: [{string.Join(", ", result.VoicesMidi)}]");
            }
            
            if (chordIndex == 0 && chordEvent.Recipe.RequestedExtensions.HasAny)
            {
                var req = chordEvent.Recipe.RequestedExtensions;
                int requiredB9Pc = req.TensionFlat9 ? (rootPc + 1) % 12 : -1;
                
                var exitVoices = new List<string>();
                var exitPcs = new List<int>();
                for (int i = 0; i < result.VoicesMidi.Length && i < 4; i++)
                {
                    int midi = result.VoicesMidi[i];
                    int pc = (midi % 12 + 12) % 12;
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    exitVoices.Add($"{voiceName}={midi}(pc={pc})");
                    exitPcs.Add(pc);
                }
                
                bool b9Present = requiredB9Pc >= 0 && exitPcs.Contains(requiredB9Pc);
                string b9Status = requiredB9Pc >= 0 ? (b9Present ? "PRESENT" : "MISSING") : "N/A";
                
                UnityEngine.Debug.Log(
                    $"[EXIT_TRACE_VoiceFirstChord_BeforeReturn] === BEFORE RETURN from VoiceFirstChord (chordIndex=0) ===\n" +
                    $"  VoicedChord.VoicesMidi (BTAS): [{string.Join(", ", result.VoicesMidi)}]\n" +
                    $"  pitch classes: [{string.Join(", ", exitPcs)}]\n" +
                    $"  voice details: {string.Join(" ", exitVoices)}\n" +
                    $"  requiredB9Pc={requiredB9Pc}, b9Status={b9Status}\n" +
                    $"  rootPc={rootPc}, RequestedExtensions.b9={req.TensionFlat9}");
            }
            
            return result;
        }

        /// <summary>
        /// Convenience wrapper for voicing a single chord event with default parameters.
        /// </summary>
        /// <param name="chordEvent">The chord event to voice</param>
        /// <returns>VoicedChord with default voicing (4 voices)</returns>
        public static VoicedChord VoiceSingleEvent(ChordEvent chordEvent)
        {
            return VoiceFirstChord(chordEvent);
        }

        /// <summary>
        /// Builds a list of ChordEvent objects from a list of ChordRecipe objects.
        /// Useful for converting parsed recipes into events for voice-leading.
        /// </summary>
        /// <param name="key">The key context for all chords</param>
        /// <param name="recipes">List of chord recipes to convert</param>
        /// <param name="startBeat">Starting beat time for the first chord (default: 0f)</param>
        /// <param name="beatStep">Beat increment between chords (default: 1f)</param>
        /// <returns>List of ChordEvent objects with incremental TimeBeats</returns>
        public static List<ChordEvent> BuildChordEventsFromRecipes(
            TheoryKey key,
            IList<ChordRecipe> recipes,
            float startBeat = 0f,
            float beatStep = 1f)
        {
            var events = new List<ChordEvent>(recipes.Count);
            float t = startBeat;
            foreach (var recipe in recipes)
            {
                events.Add(new ChordEvent
                {
                    Key = key,
                    Recipe = recipe,
                    TimeBeats = t,
                    MelodyMidi = null // Phase 1: no melody locking yet
                });
                t += beatStep;
            }
            return events;
        }

        /// <summary>
        /// Voices a progression of chords with basic voice-leading.
        /// Tier 1 heuristic: keeps common tones in same voices when possible,
        /// otherwise moves each voice to the nearest chord tone in the new chord.
        /// </summary>
        /// <param name="events">Sequence of chord events to voice</param>
        /// <param name="numVoices">Number of voices (3 or 4). Clamped to [3, 4] range.</param>
        /// <param name="bassOctave">Octave for the bass voice (default: 3, around MIDI 48)</param>
        /// <param name="upperMinMidi">Minimum MIDI note for upper voices (default: 55, around G3)</param>
        /// <param name="upperMaxMidi">Maximum MIDI note for upper voices (default: 80, around G5)</param>
        /// <returns>List of VoicedChord, one per input event</returns>
        public static List<VoicedChord> VoiceLeadProgression(
            IList<ChordEvent> events,
            int numVoices = 4,
            int bassOctave = 3,
            int upperMinMidi = 55,
            int upperMaxMidi = 80,
            DiagnosticsCollector diags = null,
            IReadOnlyDictionary<int, string> regionDebugLabels = null)
        {
            // Trace: Log entry into voicing engine for Play path
            if (s_debugTensionDetect && events != null)
            {
                for (int i = 0; i < events.Count; i++)
                {
                    var req = events[i].Recipe.RequestedExtensions;
                    if (req.HasAny)
                    {
                        var reqList = new List<string>();
                        if (req.Sus4) reqList.Add("sus4");
                        if (req.Add9) reqList.Add("add9");
                        if (req.Add11) reqList.Add("add11");
                        if (req.Tension9) reqList.Add("9");
                        if (req.TensionFlat9) reqList.Add("b9");
                        if (req.TensionSharp11) reqList.Add("#11");
                        string reqStr = reqList.Count > 0 ? string.Join(",", reqList) : "none";
                        string label = regionDebugLabels != null && regionDebugLabels.ContainsKey(i) 
                            ? regionDebugLabels[i] 
                            : TheoryChord.RecipeToRomanNumeral(events[i].Key, events[i].Recipe);
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_TRACE] step={i} voicingEngineEntry label='{label}' requested=[{reqStr}]");
                    }
                }
            }
            
            // Trace logging removed - use VoiceLeadRegions trace instead
            var result = new List<VoicedChord>();

            if (events == null || events.Count == 0)
            {
                return result;
            }

            // Voice the first chord using the standard block voicing with one-step lookahead for resolution-aware 7th placement
            var nextChordEvent = events.Count > 1 ? (ChordEvent?)events[1] : null;
            string firstToken = regionDebugLabels != null && regionDebugLabels.ContainsKey(0) 
                ? regionDebugLabels[0] 
                : TheoryChord.RecipeToRomanNumeral(events[0].Key, events[0].Recipe);
            var firstVoiced = VoiceFirstChord(events[0], numVoices, bassOctave, upperMinMidi, upperMaxMidi, nextChordEvent: nextChordEvent, chordIndex: 0, originalToken: firstToken);
            
            // Debug instrumentation: log first chord after VoiceFirstChord
            if (GetTendencyDebug())
            {
                var firstVoices = firstVoiced.VoicesMidi;
                var pcs = new List<int>();
                foreach (int m in firstVoices)
                    pcs.Add((m % 12 + 12) % 12);

                string chordName = $"{events[0].Key} {events[0].Recipe}";
                string pcsStr = string.Join(",", pcs);
                UnityEngine.Debug.Log(
                    $"[FirstChord Debug] After VoiceFirstChord for {chordName}: " +
                    $"voices=[{string.Join(",", firstVoices)}], pcs=[{pcsStr}]");

                // Log chord tone pitch classes
                var chordTonePcs = GetChordTonePitchClasses(events[0]);
                string chordTonesStr = string.Join(",", chordTonePcs);
                UnityEngine.Debug.Log(
                    $"[FirstChord Debug] chordTonePcs=[{chordTonesStr}]");
            }

            result.Add(firstVoiced);

            // CRITICAL FIX: Get play settings for incremental continuity adjustment
            // This must be declared before the loop so it's available for all iterations
            var playSettings = GetDefaultPlayVoicingSettings();
            
            // Apply continuity adjustment to first chord immediately (if not already done)
            if (result.Count > 0 && result[0].VoicesMidi != null)
            {
                var firstChordList = new List<VoicedChord> { result[0] };
                var firstEventList = new List<ChordEvent> { events[0] };
                AdjustPlayVoicingForContinuity(firstChordList, playSettings, firstEventList);
                result[0] = firstChordList[0];
                
                // CRITICAL: Check BTAS invariant after continuity adjustment for first chord
                if (result[0].VoicesMidi != null && result[0].VoicesMidi.Length >= 2)
                {
                    CheckAndLogBTASInvariant(result[0].VoicesMidi, 0, firstToken);
                }
                
                // CHECKPOINT: After continuity adjustment (first chord in progression)
                // Note: We don't track wasPresentEarlier here since continuity adjustment may have modified the voicing
                // Just log current state - the enforcement will ensure 7th is present
                bool? seventhWasPresentFirst = null;
                LogSeventhCheckpoint("AfterContinuityAdjustment", 0, events[0], result[0].VoicesMidi, false, ref seventhWasPresentFirst);
                
                // REGRESSION DIAGNOSTIC: Stage 3 - Post-continuity adjustment (final output)
                LogRequiredChordTonesDiagnostic("PostContinuityAdjustment", 0, events[0], result[0].VoicesMidi, firstToken);
                
                // AUG5_SNAP: Log state after continuity adjustment (ALWAYS emit for chordIndex=2, even if stage does nothing)
                if (result.Count > 2 && result[2].VoicesMidi != null && result[2].VoicesMidi.Length >= 4) // chord IV (index 2)
                {
                    string roman = TheoryChord.RecipeToRomanNumeral(events[2].Key, events[2].Recipe);
                    var voices = result[2].VoicesMidi;
                    if (s_enableAug5Debug)
                    {
                        string bassName = TheoryPitch.GetPitchNameFromMidi(voices[0], events[2].Key);
                        string tenorName = TheoryPitch.GetPitchNameFromMidi(voices[1], events[2].Key);
                        string altoName = TheoryPitch.GetPitchNameFromMidi(voices[2], events[2].Key);
                        string sopranoName = TheoryPitch.GetPitchNameFromMidi(voices[3], events[2].Key);
                        UnityEngine.Debug.Log(
                            $"[AUG5_SNAP] stage=PostContinuityAdjustment chordIndex=2 roman={roman} SATB=[Bass={voices[0]}({bassName}), Tenor={voices[1]}({tenorName}), Alto={voices[2]}({altoName}), Soprano={voices[3]}({sopranoName})]");
                    }
                }
                
                // STAGE SNAPSHOT: PostContinuityAdjust for diminished triads (first chord)
                if (events[0].Recipe.Quality == ChordQuality.Diminished)
                {
                    bool dimTriadHasSeventh = events[0].Recipe.Extension == ChordExtension.Seventh &&
                                              events[0].Recipe.SeventhQuality != SeventhQuality.None;
                    if (!dimTriadHasSeventh) // Only triads, not dim7
                    {
                        var dimTriadChordTonePcs = GetChordTonePitchClasses(events[0]);
                        if (dimTriadChordTonePcs != null && dimTriadChordTonePcs.Count >= 3)
                        {
                            int dimTriadRootPc = dimTriadChordTonePcs[0];
                            int dimTriadThirdPc = dimTriadChordTonePcs[1];
                            int dimTriadFifthPc = dimTriadChordTonePcs[2];
                            int dimTriadThirdInterval = (dimTriadThirdPc - dimTriadRootPc + 12) % 12;
                            int dimTriadFifthInterval = (dimTriadFifthPc - dimTriadRootPc + 12) % 12;
                            if (dimTriadThirdInterval == 3 && dimTriadFifthInterval == 6) // Valid dim triad
                            {
                                var requiredIdentityPcs = new HashSet<int> { dimTriadRootPc, dimTriadThirdPc, dimTriadFifthPc };
                                string label = firstToken ?? TheoryChord.RecipeToRomanNumeral(events[0].Key, events[0].Recipe);
                                LogStageSnapshot_DimTriad(
                                    "PostContinuityAdjust",
                                    0,
                                    firstToken ?? label,
                                    label,
                                    result[0].VoicesMidi,
                                    requiredIdentityPcs,
                                    events[0].Key);
                            }
                        }
                    }
                }
                
                // ENFORCEMENT: Ensure required 7th is still present after continuity adjustment
                if (result[0].VoicesMidi != null)
                {
                    EnsureRequiredSeventhPresent(
                        events[0],
                        result[0].VoicesMidi,
                        numVoices,
                        upperMinMidi,
                        upperMaxMidi,
                        protectSoprano: events[0].MelodyMidi.HasValue,
                        stepIndex: 0);
                }
            }

            // Voice each subsequent chord with voice-leading from the previous
            for (int i = 1; i < events.Count; i++)
            {
                var previousVoiced = result[i - 1];
                var previousEvent = events[i - 1];
                var current = events[i];
                // stepIndex should match region index (0-based), so use i (not i+1)
                
                // Get token for passing to VoiceNextChord
                string token = regionDebugLabels != null && regionDebugLabels.ContainsKey(i) 
                    ? regionDebugLabels[i] 
                    : TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                
                // Trace: Log entry into Play path voicing
                if (s_debugTensionDetect && !current.MelodyMidi.HasValue)
                {
                    var req = current.Recipe.RequestedExtensions;
                    int rootPc = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                    if (rootPc < 0) rootPc = 0;
                    rootPc = (rootPc + current.Recipe.RootSemitoneOffset + 12) % 12;
                    if (rootPc < 0) rootPc += 12;
                    
                    var requestedList = new List<string>();
                    var tensionPcs = new Dictionary<string, int>();
                    if (req.Tension9) { requestedList.Add("9"); tensionPcs["9"] = (rootPc + 2) % 12; }
                    if (req.TensionFlat9) { requestedList.Add("b9"); tensionPcs["b9"] = (rootPc + 1) % 12; }
                    if (req.TensionSharp11) { requestedList.Add("#11"); tensionPcs["#11"] = (rootPc + 6) % 12; }
                    
                    string quality = current.Recipe.Quality.ToString();
                    if (current.Recipe.Extension == ChordExtension.Seventh) quality += "7";
                    string requestedStr = requestedList.Count > 0 ? string.Join(",", requestedList) : "none";
                    string tensionPcsStr = string.Join(" ", tensionPcs.Select(kvp => $"{kvp.Key}:{kvp.Value}"));
                    
                    if (s_debugTensionVerbose)
                    {
                        UnityEngine.Debug.Log(
                            $"[PLAY_TRACE] step={i} token='{token}' rootPc={rootPc} quality={quality} " +
                            $"requested=[{requestedStr}] tensionPcs={{ {tensionPcsStr} }} policy={s_extensionPlacementMode}");
                    }
                }
                // DIAGNOSTIC: Log prevMidi used for step 1 (should be post-continuity, i.e., 68 not 80)
                if (i == 1 && previousEvent.Recipe.RequestedExtensions.HasAny)
                {
                    int prevSopranoMidi = previousVoiced.VoicesMidi.Length > 3 ? previousVoiced.VoicesMidi[3] : -1;
                    UnityEngine.Debug.Log(
                        $"[INCREMENTAL_CONTINUITY] === Before voicing step 1 ===\n" +
                        $"  prevMidi_postContinuity (soprano)={prevSopranoMidi} ({TheoryPitch.GetPitchNameFromMidi(prevSopranoMidi, previousEvent.Key)})\n" +
                        $"  previousVoiced.VoicesMidi (BTAS): [{string.Join(", ", previousVoiced.VoicesMidi)}]");
                }
                
                var nextVoiced = VoiceNextChord(previousVoiced, previousEvent, current, numVoices, bassOctave, upperMinMidi, upperMaxMidi, stepIndex: i, diags: diags, regionDebugLabel: token);
                
                // CRITICAL FIX: Apply continuity adjustment immediately after voicing each chord
                // This ensures the next chord uses the adjusted voicing as its "previous" reference
                // Pass the full result list so AdjustPlayVoicingForContinuity can use prevMidi from previous adjusted chords
                var allChordsSoFar = new List<VoicedChord>(result);
                allChordsSoFar.Add(nextVoiced);
                var allEventsSoFar = events.Take(i + 2).ToList(); // Include previous events + current event
                AdjustPlayVoicingForContinuity(allChordsSoFar, playSettings, allEventsSoFar);
                nextVoiced = allChordsSoFar[allChordsSoFar.Count - 1];  // Get the adjusted version
                
                // STAGE SNAPSHOT: PostContinuityAdjust for diminished triads
                if (current.Recipe.Quality == ChordQuality.Diminished)
                {
                    bool dimTriadHasSeventh = current.Recipe.Extension == ChordExtension.Seventh &&
                                              current.Recipe.SeventhQuality != SeventhQuality.None;
                    if (!dimTriadHasSeventh) // Only triads, not dim7
                    {
                        var dimTriadChordTonePcs = GetChordTonePitchClasses(current);
                        if (dimTriadChordTonePcs != null && dimTriadChordTonePcs.Count >= 3)
                        {
                            int dimTriadRootPc = dimTriadChordTonePcs[0];
                            int dimTriadThirdPc = dimTriadChordTonePcs[1];
                            int dimTriadFifthPc = dimTriadChordTonePcs[2];
                            int dimTriadThirdInterval = (dimTriadThirdPc - dimTriadRootPc + 12) % 12;
                            int dimTriadFifthInterval = (dimTriadFifthPc - dimTriadRootPc + 12) % 12;
                            if (dimTriadThirdInterval == 3 && dimTriadFifthInterval == 6) // Valid dim triad
                            {
                                var requiredIdentityPcs = new HashSet<int> { dimTriadRootPc, dimTriadThirdPc, dimTriadFifthPc };
                                string chordToken = token ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                string label = token ?? chordToken;
                                LogStageSnapshot_DimTriad(
                                    "PostContinuityAdjust",
                                    i,
                                    chordToken,
                                    label,
                                    nextVoiced.VoicesMidi,
                                    requiredIdentityPcs,
                                    current.Key);
                            }
                        }
                    }
                }
                
                // Update result list with adjusted voicings (all chords may have been adjusted)
                for (int j = 0; j < allChordsSoFar.Count - 1; j++)
                {
                    result[j] = allChordsSoFar[j];
                }
                
                // CRITICAL: Check BTAS invariant after continuity adjustment
                if (nextVoiced.VoicesMidi != null && nextVoiced.VoicesMidi.Length >= 2)
                {
                    CheckAndLogBTASInvariant(nextVoiced.VoicesMidi, i, token);
                }
                
                // CHECKPOINT: After continuity adjustment (progression)
                bool? seventhWasPresentCont = null;
                LogSeventhCheckpoint("AfterContinuityAdjustment", i, current, nextVoiced.VoicesMidi, false, ref seventhWasPresentCont);
                
                // ENFORCEMENT: Ensure required 7th is still present after continuity adjustment
                if (nextVoiced.VoicesMidi != null)
                {
                    EnsureRequiredSeventhPresent(
                        current,
                        nextVoiced.VoicesMidi,
                        numVoices,
                        upperMinMidi,
                        upperMaxMidi,
                        protectSoprano: current.MelodyMidi.HasValue,
                        stepIndex: i);
                }
                
                // DIAGNOSTIC: Log after adjusting step 1
                if (i == 1 && events[0].Recipe.RequestedExtensions.HasAny)
                {
                    int chosenSopranoMidi = nextVoiced.VoicesMidi.Length > 3 ? nextVoiced.VoicesMidi[3] : -1;
                    int prevSopranoMidi = previousVoiced.VoicesMidi.Length > 3 ? previousVoiced.VoicesMidi[3] : -1;
                    int strictTargetMidi = prevSopranoMidi - 1;
                    bool isStrictStep = (chosenSopranoMidi == strictTargetMidi);
                    
                    UnityEngine.Debug.Log(
                        $"[INCREMENTAL_CONTINUITY] === After adjusting step 1 ===\n" +
                        $"  prevMidi_postContinuity={prevSopranoMidi} ({TheoryPitch.GetPitchNameFromMidi(prevSopranoMidi, previousEvent.Key)})\n" +
                        $"  strictTargetMidi={strictTargetMidi} ({TheoryPitch.GetPitchNameFromMidi(strictTargetMidi, current.Key)})\n" +
                        $"  chosen soprano midi={chosenSopranoMidi} ({TheoryPitch.GetPitchNameFromMidi(chosenSopranoMidi, current.Key)})\n" +
                        $"  isStrictStep={isStrictStep} (expected: true for 68→67)");
                }
                
                result.Add(nextVoiced);
                
                // Trace: Log final result after voicing
                if (s_debugTensionDetect && !current.MelodyMidi.HasValue)
                {
                    var req = current.Recipe.RequestedExtensions;
                    if (req.HasAny)
                    {
                        int rootPc = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                        if (rootPc < 0) rootPc = 0;
                        rootPc = (rootPc + current.Recipe.RootSemitoneOffset + 12) % 12;
                        if (rootPc < 0) rootPc += 12;
                        
                        // CRITICAL FIX: For step 0, use the actual realized voicing from result[0], not nextVoiced
                        // nextVoiced is from VoiceNextChord which processes step i (starting at 1), not step 0
                        // NOTE: This loop starts at i=1, so i==0 should never occur here, but keeping as safeguard
                        VoicedChord voicingToCheck = nextVoiced;
                        if (i == 0)
                        {
                            // For step 0, use the first chord from result (which was returned by VoiceFirstChord)
                            voicingToCheck = result[0];
                            
                            UnityEngine.Debug.LogWarning(
                                $"[GUARD_WARNING] step=0 detected in loop (should not happen - loop starts at i=1). " +
                                $"Using result[0] (from VoiceFirstChord) instead of nextVoiced " +
                                $"(result[0].VoicesMidi=[{string.Join(", ", result[0].VoicesMidi)}], " +
                                $"nextVoiced.VoicesMidi=[{string.Join(", ", nextVoiced.VoicesMidi)}])");
                        }
                        
                        // DIAGNOSTIC: Entry trace at start of tension detect
                        if (i == 0 && current.Recipe.RequestedExtensions.HasAny)
                        {
                            var reqForTrace = current.Recipe.RequestedExtensions;
                            int requiredB9Pc = reqForTrace.TensionFlat9 ? (rootPc + 1) % 12 : -1;
                            
                            var traceVoices = new List<string>();
                            var tracePcs = new List<int>();
                            for (int v = 0; v < voicingToCheck.VoicesMidi.Length && v < 4; v++)
                            {
                                int midi = voicingToCheck.VoicesMidi[v];
                                int pc = (midi % 12 + 12) % 12;
                                string voiceName = v == 0 ? "B" : v == 1 ? "T" : v == 2 ? "A" : "S";
                                traceVoices.Add($"{voiceName}={midi}(pc={pc})");
                                tracePcs.Add(pc);
                            }
                            
                            bool b9Present = requiredB9Pc >= 0 && tracePcs.Contains(requiredB9Pc);
                            string b9Status = requiredB9Pc >= 0 ? (b9Present ? "PRESENT" : "MISSING") : "N/A";
                            
                            UnityEngine.Debug.Log(
                                $"[EXIT_TRACE_TensionDetect_Start] === START OF TENSION DETECT (step=0) ===\n" +
                                $"  Reading from voicingToCheck.VoicesMidi (BTAS): [{string.Join(", ", voicingToCheck.VoicesMidi)}]\n" +
                                $"  pitch classes: [{string.Join(", ", tracePcs)}]\n" +
                                $"  voice details: {string.Join(" ", traceVoices)}\n" +
                                $"  requiredB9Pc={requiredB9Pc}, b9Status={b9Status}\n" +
                                $"  rootPc={rootPc}, RequestedExtensions.b9={reqForTrace.TensionFlat9}");
                            
                            // GUARD: Assert that voicingToCheck matches result[0] for step 0
                            if (i == 0 && !voicingToCheck.VoicesMidi.SequenceEqual(result[0].VoicesMidi))
                            {
                                UnityEngine.Debug.LogError(
                                    $"[GUARD_ERROR] step=0: voicingToCheck.VoicesMidi != result[0].VoicesMidi!\n" +
                                    $"  voicingToCheck: [{string.Join(", ", voicingToCheck.VoicesMidi)}]\n" +
                                    $"  result[0]: [{string.Join(", ", result[0].VoicesMidi)}]");
                            }
                        }
                        
                        var realizedPcs = new HashSet<int>();
                        var voiceNotes = new List<string>();
                        var voicePcs = new List<int>();
                        for (int v = 0; v < voicingToCheck.VoicesMidi.Length && v < 4; v++)
                        {
                            int midi = voicingToCheck.VoicesMidi[v];
                            int pc = (midi % 12 + 12) % 12;
                            realizedPcs.Add(pc);
                            string voiceName = v == 0 ? "B" : v == 1 ? "T" : v == 2 ? "A" : "S";
                            voiceNotes.Add($"{voiceName}={midi}");
                            voicePcs.Add(pc);
                        }
                        
                        var satisfied = new List<string>();
                        var unsatisfied = new List<string>();
                        
                        if (req.TensionFlat9)
                        {
                            int b9Pc = (rootPc + 1) % 12;
                            int ninePc = (rootPc + 2) % 12;
                            if (realizedPcs.Contains(b9Pc))
                            {
                                satisfied.Add("b9");
                            }
                            else
                            {
                                if (realizedPcs.Contains(ninePc))
                                {
                                    unsatisfied.Add($"b9 (natural9={ninePc} found instead) ❌");
                                }
                                else
                                {
                                    unsatisfied.Add("b9");
                                }
                            }
                        }
                        if (req.Tension9)
                        {
                            int ninePc = (rootPc + 2) % 12;
                            if (realizedPcs.Contains(ninePc))
                                satisfied.Add("9");
                            else
                                unsatisfied.Add("9");
                        }
                        if (req.TensionSharp9)
                        {
                            int sharp9Pc = (rootPc + 3) % 12;
                            int ninePc = (rootPc + 2) % 12;
                            int b9Pc = (rootPc + 1) % 12;
                            if (realizedPcs.Contains(sharp9Pc))
                            {
                                satisfied.Add("#9");
                            }
                            else
                            {
                                if (realizedPcs.Contains(ninePc))
                                {
                                    unsatisfied.Add($"#9 (natural9={ninePc} found instead) ❌");
                                }
                                else if (realizedPcs.Contains(b9Pc))
                                {
                                    unsatisfied.Add($"#9 (b9={b9Pc} found instead) ❌");
                                }
                                else
                                {
                                    unsatisfied.Add("#9");
                                }
                            }
                        }
                        if (req.TensionSharp11)
                        {
                            int sharp11Pc = (rootPc + 6) % 12;
                            if (realizedPcs.Contains(sharp11Pc))
                                satisfied.Add("#11");
                            else
                                unsatisfied.Add("#11");
                        }
                        
                        string realizedStr = string.Join(",", realizedPcs.OrderBy(x => x));
                        string voicesStr = string.Join(" ", voiceNotes);
                        string satisfiedStr = satisfied.Count > 0 ? string.Join(",", satisfied) : "none";
                        string unsatisfiedStr = unsatisfied.Count > 0 ? string.Join(",", unsatisfied) : "none";
                        
                        if (s_debugTensionVerbose)
                        {
                            UnityEngine.Debug.Log(
                                $"[PLAY_TRACE] step={i} after voicing:\n" +
                                $"  voices: {voicesStr}\n" +
                                $"  realizedPCs=[{realizedStr}]\n" +
                                $"  satisfied=[{satisfiedStr}]\n" +
                                $"  unsatisfied=[{unsatisfiedStr}]");
                        }
                    }
                }
            }

            // NOTE: Continuity adjustment is now applied incrementally inside the voicing loop
            // This ensures each chord uses the post-continuity voicing of the previous chord
            // No need to apply it again here - all chords have already been adjusted
            
            // CRITICAL FIX: Tension detection for step 0 AFTER AdjustPlayVoicingForContinuity
            // This ensures we use the final voicing that will be used for playback/UI
            // This is the SINGLE SOURCE OF TRUTH for Play mode tension satisfaction
            // Any other tension detection (e.g., in ChordLabController) is ANALYSIS_ONLY and must not overwrite this
            if (s_debugTensionDetect && result.Count > 0 && !events[0].MelodyMidi.HasValue)
            {
                var req = events[0].Recipe.RequestedExtensions;
                if (req.HasAny)
                {
                    int rootPc = TheoryScale.GetDegreePitchClass(events[0].Key, events[0].Recipe.Degree);
                    if (rootPc < 0) rootPc = 0;
                    rootPc = (rootPc + events[0].Recipe.RootSemitoneOffset + 12) % 12;
                    if (rootPc < 0) rootPc += 12;
                    
                    // Use the final realized voicing from result[0] (after AdjustPlayVoicingForContinuity)
                    var realizedPcs = new HashSet<int>();
                    var voiceNotes = new List<string>();
                    var voicePcs = new List<int>();
                    for (int v = 0; v < result[0].VoicesMidi.Length && v < 4; v++)
                    {
                        int midi = result[0].VoicesMidi[v];
                        int pc = (midi % 12 + 12) % 12;
                        realizedPcs.Add(pc);
                        string voiceName = v == 0 ? "B" : v == 1 ? "T" : v == 2 ? "A" : "S";
                        voiceNotes.Add($"{voiceName}={midi}");
                        voicePcs.Add(pc);
                    }
                    
                    var satisfied = new List<string>();
                    var unsatisfied = new List<string>();
                    
                    if (req.TensionFlat9)
                    {
                        int b9Pc = (rootPc + 1) % 12;
                        int ninePc = (rootPc + 2) % 12;
                        if (realizedPcs.Contains(b9Pc))
                        {
                            satisfied.Add("b9");
                        }
                        else
                        {
                            if (realizedPcs.Contains(ninePc))
                            {
                                unsatisfied.Add($"b9 (natural9={ninePc} found instead) ❌");
                            }
                            else
                            {
                                unsatisfied.Add("b9");
                            }
                        }
                    }
                    if (req.Tension9)
                    {
                        int ninePc = (rootPc + 2) % 12;
                        if (realizedPcs.Contains(ninePc))
                            satisfied.Add("9");
                        else
                            unsatisfied.Add("9");
                    }
                    if (req.TensionSharp9)
                    {
                        int sharp9Pc = (rootPc + 3) % 12;
                        int ninePc = (rootPc + 2) % 12;
                        int b9Pc = (rootPc + 1) % 12;
                        if (realizedPcs.Contains(sharp9Pc))
                        {
                            satisfied.Add("#9");
                        }
                        else
                        {
                            if (realizedPcs.Contains(ninePc))
                            {
                                unsatisfied.Add($"#9 (natural9={ninePc} found instead) ❌");
                            }
                            else if (realizedPcs.Contains(b9Pc))
                            {
                                unsatisfied.Add($"#9 (b9={b9Pc} found instead) ❌");
                            }
                            else
                            {
                                unsatisfied.Add("#9");
                            }
                        }
                    }
                    if (req.TensionSharp11)
                    {
                        int sharp11Pc = (rootPc + 6) % 12;
                        if (realizedPcs.Contains(sharp11Pc))
                            satisfied.Add("#11");
                        else
                            unsatisfied.Add("#11");
                    }
                    
                    string realizedStr = string.Join(",", realizedPcs.OrderBy(x => x));
                    string voicesStr = string.Join(" ", voiceNotes);
                    string satisfiedStr = satisfied.Count > 0 ? string.Join(",", satisfied) : "none";
                    string unsatisfiedStr = unsatisfied.Count > 0 ? string.Join(",", unsatisfied) : "none";
                    
                    string token = regionDebugLabels != null && regionDebugLabels.ContainsKey(0) 
                        ? regionDebugLabels[0] 
                        : TheoryChord.RecipeToRomanNumeral(events[0].Key, events[0].Recipe);
                    
                    // SINGLE SOURCE OF TRUTH: This is the ONLY tension detection that drives Play mode satisfaction
                    // Any other tension detection (e.g., ChordLabController analysis) is ANALYSIS_ONLY and must not overwrite this
                    
                    UnityEngine.Debug.Log(
                        $"[TENSION_DETECT] step=0 mode=Play token='{token}' " +
                        $"midi=[{string.Join(",", result[0].VoicesMidi)}] " +
                        $"realizedPCs=[{realizedStr}] " +
                        $"satisfied=[{satisfiedStr}] unsatisfied=[{unsatisfiedStr}] " +
                        $"(SINGLE_SOURCE_OF_TRUTH for Play mode satisfaction)");
                    
                    // GUARD: Verify b9 is present if requested (after final adjustment)
                    if (req.TensionFlat9)
                    {
                        int b9Pc = (rootPc + 1) % 12;
                        if (!realizedPcs.Contains(b9Pc))
                        {
                            UnityEngine.Debug.LogError(
                                $"[GUARD_ERROR] step=0: b9 requested but missing after AdjustPlayVoicingForContinuity! " +
                                $"result[0].VoicesMidi=[{string.Join(", ", result[0].VoicesMidi)}], " +
                                $"realizedPCs=[{realizedStr}], requiredB9Pc={b9Pc}");
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Voices a progression of chords with basic voice-leading, respecting melody constraints.
        /// When MelodyMidi is set on a ChordEvent, the soprano (highest voice) will be locked to that MIDI note.
        /// </summary>
        /// <param name="events">Sequence of chord events to voice</param>
        /// <param name="numVoices">Number of voices (3 or 4). Clamped to [3, 4] range.</param>
        /// <param name="rootOctave">Octave for calculating upper voice ranges (default: 4)</param>
        /// <param name="bassOctave">Octave for the bass voice (default: 3, around MIDI 48)</param>
        /// <param name="upperMinMidi">Minimum MIDI note for upper voices (default: 60, around C4)</param>
        /// <param name="upperMaxMidi">Maximum MIDI note for upper voices (default: 76, around E5)</param>
        /// <returns>List of VoicedChord, one per input event</returns>
        public static List<VoicedChord> VoiceLeadProgressionWithMelody(
            IList<ChordEvent> events,
            int numVoices = 4,
            int rootOctave = 4,
            int bassOctave = 3,
            int upperMinMidi = 60,
            int upperMaxMidi = 76,
            DiagnosticsCollector diags = null,
            IReadOnlyDictionary<int, string> regionDebugLabels = null)
        {
            var result = new List<VoicedChord>();

            if (events == null || events.Count == 0)
            {
                return result;
            }

            // Voice the first chord using the standard block voicing (with melody support)
            // Voice the first chord using the standard block voicing with one-step lookahead for resolution-aware 7th placement
            var nextChordEvent = events.Count > 1 ? (ChordEvent?)events[1] : null;
            string firstToken = regionDebugLabels != null && regionDebugLabels.ContainsKey(0) 
                ? regionDebugLabels[0] 
                : TheoryChord.RecipeToRomanNumeral(events[0].Key, events[0].Recipe);
            var firstVoiced = VoiceFirstChord(events[0], numVoices, bassOctave, upperMinMidi, upperMaxMidi, nextChordEvent: nextChordEvent, chordIndex: 0, originalToken: firstToken);
            
            // Debug instrumentation: log first chord after VoiceFirstChord
            if (GetTendencyDebug())
            {
                var firstVoices = firstVoiced.VoicesMidi;
                var pcs = new List<int>();
                foreach (int m in firstVoices)
                    pcs.Add((m % 12 + 12) % 12);

                string chordName = $"{events[0].Key} {events[0].Recipe}";
                string pcsStr = string.Join(",", pcs);
                UnityEngine.Debug.Log(
                    $"[FirstChord Debug] After VoiceFirstChord for {chordName}: " +
                    $"voices=[{string.Join(",", firstVoices)}], pcs=[{pcsStr}]");

                // Log chord tone pitch classes
                var chordTonePcs = GetChordTonePitchClasses(events[0]);
                string chordTonesStr = string.Join(",", chordTonePcs);
                UnityEngine.Debug.Log(
                    $"[FirstChord Debug] chordTonePcs=[{chordTonesStr}]");
            }

            result.Add(firstVoiced);

            // Voice each subsequent chord with voice-leading from the previous
            for (int i = 1; i < events.Count; i++)
            {
                var previousVoiced = result[i - 1];
                var previousEvent = events[i - 1];
                var current = events[i];
                // stepIndex should match region index (0-based), so use i (not i+1)
                string debugLabel = regionDebugLabels != null && regionDebugLabels.ContainsKey(i) ? regionDebugLabels[i] : null;
                var nextVoiced = VoiceNextChord(previousVoiced, previousEvent, current, numVoices, bassOctave, upperMinMidi, upperMaxMidi, stepIndex: i, diags: diags, regionDebugLabel: debugLabel);
                
                // CRITICAL: Check BTAS invariant after voicing each chord (SATB path)
                if (nextVoiced.VoicesMidi != null && nextVoiced.VoicesMidi.Length >= 2)
                {
                    string chordLabel = debugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                    CheckAndLogBTASInvariant(nextVoiced.VoicesMidi, i, chordLabel);
                }
                
                result.Add(nextVoiced);
            }
            
            // CRITICAL: Check BTAS invariant for first chord (SATB path)
            if (result.Count > 0 && result[0].VoicesMidi != null && result[0].VoicesMidi.Length >= 2)
            {
                CheckAndLogBTASInvariant(result[0].VoicesMidi, 0, firstToken);
            }
            
            // AUG5_SNAP: Log state before returning from VoiceLeadProgressionWithMelody (for chord IV only)
            if (result.Count > 2 && result[2].VoicesMidi != null && result[2].VoicesMidi.Length >= 4) // chord IV (index 2)
            {
                string roman = regionDebugLabels != null && regionDebugLabels.ContainsKey(2) ? regionDebugLabels[2] : TheoryChord.RecipeToRomanNumeral(events[2].Key, events[2].Recipe);
                if (roman == "F" || roman == "IV")
                {
                    if (s_enableAug5Debug)
                    {
                        var voices = result[2].VoicesMidi;
                        string bassName = TheoryPitch.GetPitchNameFromMidi(voices[0], events[2].Key);
                        string tenorName = TheoryPitch.GetPitchNameFromMidi(voices[1], events[2].Key);
                        string altoName = TheoryPitch.GetPitchNameFromMidi(voices[2], events[2].Key);
                        string sopranoName = TheoryPitch.GetPitchNameFromMidi(voices[3], events[2].Key);
                        UnityEngine.Debug.Log(
                            $"[AUG5_SNAP] stage=BeforeReturn chordIndex=2 roman={roman} SATB=[Bass={voices[0]}({bassName}), Tenor={voices[1]}({tenorName}), Alto={voices[2]}({altoName}), Soprano={voices[3]}({sopranoName})] source=VoiceLeadProgressionWithMelody.return");
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Voices a progression of chord regions using timeline-based representation.
        /// This is an adapter method that extracts ChordEvents from regions and calls
        /// the appropriate voicing method based on melody constraints.
        /// </summary>
        /// <param name="key">The key context (for validation/debugging; each region's ChordEvent also has a key)</param>
        /// <param name="spec">Timeline specification (ticksPerQuarter, tempo, time signature)</param>
        /// <param name="regions">List of chord regions with timeline information</param>
        /// <param name="useMelodyConstraint">If true, uses VoiceLeadProgressionWithMelody; otherwise uses VoiceLeadProgression</param>
        /// <param name="numVoices">Number of voices (3 or 4). Default: 4</param>
        /// <param name="rootOctave">Octave for calculating upper voice ranges (default: 4, used when useMelodyConstraint is true)</param>
        /// <param name="bassOctave">Octave for the bass voice (default: 3)</param>
        /// <param name="upperMinMidi">Minimum MIDI note for upper voices (default: 55 for non-melody, 60 for melody)</param>
        /// <param name="upperMaxMidi">Maximum MIDI note for upper voices (default: 80 for non-melody, 76 for melody)</param>
        /// <returns>List of VoicedChord, one per input region</returns>
        public static List<VoicedChord> VoiceLeadRegions(
            TheoryKey key,
            TimelineSpec spec,
            IReadOnlyList<ChordRegion> regions,
            bool useMelodyConstraint,
            int numVoices = 4,
            int rootOctave = 4,
            int bassOctave = 3,
            int upperMinMidi = -1, // -1 means use default based on useMelodyConstraint
            int upperMaxMidi = -1, // -1 means use default based on useMelodyConstraint
            Diagnostics.DiagnosticsCollector diags = null) // Optional diagnostics collector
        {
            // Null safety: create default spec if null
            if (spec == null)
            {
                UnityEngine.Debug.LogWarning("[VoiceLeadRegions] TimelineSpec is null, creating default spec with ticksPerQuarter=4");
                spec = new TimelineSpec();
            }

            // Extract ChordEvents from regions
            var chordEvents = regions.Select(r => r.chordEvent).ToList();

            // Debug logging - use spec.ticksPerQuarter
            int ticksPerQuarter = spec.ticksPerQuarter;
            UnityEngine.Debug.Log($"[VoiceLeadRegions] Processing {regions.Count} regions, ticksPerQuarter={ticksPerQuarter} (from spec)");
            TraceLog($"[TRACE] Entered VoiceLeadRegions with {regions.Count} regions, useMelodyConstraint={useMelodyConstraint}", diags);
            if (regions.Count > 0)
            {
                var first = regions[0];
                var last = regions[regions.Count - 1];
                UnityEngine.Debug.Log($"[VoiceLeadRegions] First region: startTick={first.startTick}, durationTicks={first.durationTicks}, label='{first.debugLabel}'");
                UnityEngine.Debug.Log($"[VoiceLeadRegions] Last region: startTick={last.startTick}, durationTicks={last.durationTicks}, label='{last.debugLabel}'");
            }

            // Add diagnostic events for each region (if collector provided)
            if (diags != null)
            {
                for (int i = 0; i < regions.Count; i++)
                {
                    var region = regions[i];
                    string label = region.debugLabel ?? $"Chord {i + 1}";
                    diags.Add(i, Diagnostics.DiagSeverity.Info, Diagnostics.DiagCode.VOICING_START, $"Voicing {label} in {key}");
                }
            }

            // Use default MIDI ranges if not specified
            int actualUpperMinMidi = upperMinMidi >= 0 ? upperMinMidi : (useMelodyConstraint ? 60 : 55);
            int actualUpperMaxMidi = upperMaxMidi >= 0 ? upperMaxMidi : (useMelodyConstraint ? 76 : 80);

            // Build mapping from region index to debugLabel
            var regionDebugLabels = new Dictionary<int, string>();
            for (int i = 0; i < regions.Count; i++)
            {
                if (!string.IsNullOrEmpty(regions[i].debugLabel))
                {
                    regionDebugLabels[i] = regions[i].debugLabel;
                }
            }

            // Call appropriate voicing method
            List<VoicedChord> result;
            if (useMelodyConstraint)
            {
                result = VoiceLeadProgressionWithMelody(
                    chordEvents,
                    numVoices,
                    rootOctave,
                    bassOctave,
                    actualUpperMinMidi,
                    actualUpperMaxMidi,
                    diags,
                    regionDebugLabels);
            }
            else
            {
                result = VoiceLeadProgression(
                    chordEvents,
                    numVoices,
                    bassOctave,
                    actualUpperMinMidi,
                    actualUpperMaxMidi,
                    diags,
                    regionDebugLabels);
            }

            // Add completion diagnostic events (if collector provided)
            // This serves as a tripwire to verify regionIndex wiring is correct
            if (diags != null && result != null)
            {
                for (int i = 0; i < result.Count && i < regions.Count; i++)
                {
                    var voiced = result[i];
                    if (voiced.VoicesMidi != null && voiced.VoicesMidi.Length > 0)
                    {
                        string midiList = string.Join(", ", voiced.VoicesMidi);
                        diags.Add(i, Diagnostics.DiagSeverity.Info, Diagnostics.DiagCode.VOICING_DONE, $"SATB: [{midiList}]");
                        // Tripwire: verify regionIndex wiring (only when trace is enabled)
                        if (diags != null && diags.EnableTrace)
                        {
                            diags.Add(i, Diagnostics.DiagSeverity.Info, "VOICED_REGION", $"Voiced region {i} SATB=[{midiList}]");
                        }
                        
                        // Post-voicing coverage audit
                        string label = regions[i].debugLabel ?? $"Chord {i + 1}";
                        Diagnostics.ChordCoverageAudit.Audit(i, label, regions[i].chordEvent, voiced.VoicesMidi, diags);
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Builds upper voices (Tenor, Alto, Soprano) for a chord that has a melody,
        /// using a full SATB candidate search with spacing constraints.
        /// Returns true on success; false if no valid candidate is found.
        /// </summary>
        private static bool TryBuildUpperVoicesWithMelodyFullSearch(
            ChordEvent previousEvent,
            ChordEvent current,
            int numVoices,
            int bassVoice,
            int upperMinMidi,
            int upperMaxMidi,
            int[] prevUpper,                       // previous upper voices (Tenor, Alto, [Soprano])
            VoiceTendencyInfo[] tendencyInfos,     // same length as prevUpper
            ChordFunctionProfile previousAnalysis,
            ChordFunctionProfile currentAnalysis,
            int targetSopranoMidi,                 // already range-adjusted melody for this chord
            List<int> chordTonePcs,
            out List<int> upperVoices,            // will contain Tenor, Alto
            out Dictionary<int, int> voiceSelectionMap,
            int stepIndex = -1,
            DiagnosticsCollector diags = null)
        {
            upperVoices = new List<int>();
            voiceSelectionMap = new Dictionary<int, int>();
            
            // Debug: Log voicing path and effective weights
            if (enableVoicingPathDebug)
            {
                string stepStr = stepIndex >= 0 ? $" step={stepIndex}" : "";
                UnityEngine.Debug.Log(
                    $"[VOICING PATH] MELODY_FULL_SEARCH{stepStr}\n" +
                    $"  Movement: enable={s_enableMovementWeighting}, weight={s_movementWeightInnerVoices:F3}\n" +
                    $"  Compactness: TB={compactnessWeightTenorBass:F3}, AT={compactnessWeightAltoTenor:F3}\n" +
                    $"  Compression: enable={s_enableCompressionCost}, targetAT={s_targetAltoTenorGap}, targetSA={s_targetSopAltoGap}, weightAT={s_compressionWeightAT:F3}, weightSA={s_compressionWeightSA:F3}\n" +
                    $"  Register: enable={s_enableRegisterGravity}, tenorCenter={s_tenorRegisterCenter}, altoCenter={s_altoRegisterCenter}, tenorWeight={s_tenorRegisterWeight:F3}, altoWeight={s_altoRegisterWeight:F3}\n" +
                    $"  7th Resolution: bonus={seventhResolutionDownStepBonusNormal:F3}, avoidPenalty={seventhResolutionAvoidPenaltyNormal:F3}"
                );
            }
            
            // TRACE 1: Entry to TryBuildUpperVoicesWithMelodyFullSearch
            if (enableTraceLogs && diags != null && diags.EnableTrace)
            {
                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                if (ShouldTrace(label))
                {
                    string expectedPCs = string.Join(",", chordTonePcs);
                    TraceLog($"[TRACE Entry] R{stepIndex} {label} Entry to TryBuildUpperVoicesWithMelodyFullSearch, expected chord tone PCs=[{expectedPCs}]", diags);
                }
            }
            
            // Debug: Log the compactness weights being used (read fresh from static fields)
            if (GetTendencyDebug())
            {
                UnityEngine.Debug.Log(
                    $"[SATB FullSearch] Using compactness weights: " +
                    $"TB={compactnessWeightTenorBass}, AT={compactnessWeightAltoTenor}");
            }
            
            int melodyMidi = current.MelodyMidi.Value;
            int melodyPc = (melodyMidi % 12 + 12) % 12;
            
            // Inner voices should avoid doubling the soprano pitch class if possible
            var innerPcs = new List<int>(chordTonePcs);
            innerPcs.RemoveAll(pc => pc == melodyPc);
            if (innerPcs.Count == 0)
            {
                // If the chord is just the melody PC (or analysis failed), allow it back in
                innerPcs.AddRange(chordTonePcs);
            }
            
            // Define ranges for Tenor and Alto
            // Determine a permissive lower bound for Tenor:
            // - Let tenor dip up to an octave below upperMinMidi
            // - But never below our absolute tenor floor (E3)
            // NOTE: We still enforce tenor > bass via hard filters later.
            int minFromBass = bassVoice + 1;
            int minFromUpper = upperMinMidi - 12;
            
            // Allow going below upperMinMidi when the bass is high.
            // We will clamp against TenorAbsoluteMinMidi to avoid going too low.
            int tenorMin = Math.Min(minFromBass, minFromUpper);
            tenorMin = Math.Max(tenorMin, TenorAbsoluteMinMidi);
            
            int tenorMax = targetSopranoMidi - 1; // Tenor strictly below soprano
            
            // Debug logging for tenor range
            if (GetTendencyDebug())
            {
                UnityEngine.Debug.Log(
                    $"[Tenor Range Debug] Step {stepIndex}: bass={bassVoice}, upperMin={upperMinMidi}, tenorMin={tenorMin}, tenorMax={tenorMax}");
            }
            int altoMin = upperMinMidi;           // Alto generally stays in upper register
            int altoMax = targetSopranoMidi - 1;  // Alto strictly below soprano
            
            // Generate candidate lists for Tenor and Alto
            var tenorCandidatesRaw = GenerateCandidatesInRange(innerPcs, tenorMin, tenorMax);
            var tenorCandidates = tenorCandidatesRaw
                .Where(m => m > bassVoice && m < targetSopranoMidi)
                .Distinct()
                .ToList();
            
            var altoCandidatesRaw = GenerateCandidatesInRange(innerPcs, altoMin, altoMax);
            var altoCandidates = altoCandidatesRaw
                .Where(m => m > bassVoice && m < targetSopranoMidi)
                .Distinct()
                .ToList();
            
            // TRACE: Candidate generation for melody path
            if (enableTraceLogs && diags != null && diags.EnableTrace)
            {
                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                if (ShouldTrace(label))
                {
                    TraceLog($"[TRACE] R{stepIndex} {label}: Entered candidate selection (melody path)", diags);
                    string tenorList = string.Join(",", tenorCandidates);
                    string altoList = string.Join(",", altoCandidates);
                    TraceLog($"[TRACE] R{stepIndex} {label}: Generated candidates per voice:", diags);
                    TraceLog($"[TRACE]   Tenor: [{tenorList}]", diags);
                    TraceLog($"[TRACE]   Alto: [{altoList}]", diags);
                    TraceLog($"[TRACE]   Soprano: [{targetSopranoMidi}] (melody)", diags);
                }
            }
            
            if (tenorCandidates.Count == 0 || altoCandidates.Count == 0)
            {
                // No search space – signal failure so caller can fall back
                return false;
            }
            
            // Get previous voice positions
            int prevTenor = prevUpper.Length > 0 ? prevUpper[0] : tenorMin;
            int prevAlto = prevUpper.Length > 1 ? prevUpper[1] : altoMin;
            
            float bestCost = float.MaxValue;
            float bestCompactnessCost = float.MaxValue;
            int bestTenor = -1;
            int bestAlto = -1;
            
            // Track last best candidate costs for coverage veto logging
            float lastBestMoveCost = 0f;
            float lastBestCompactCost = 0f;
            float lastBestTendCost = 0f;
            float lastBestTotalCost = float.MaxValue;
            
            // Debug: Track candidate counts and cost breakdowns
            int validCandidatesCount = 0;
            float secondBestCost = float.MaxValue;
            float bestMoveCost = 0f;
            float bestWeightedMoveCost = 0f;
            float bestCompactnessCostDebug = 0f;
            float bestTendCost = 0f;
            float bestRegisterPenalty = 0f;
            float bestCompressionPenalty = 0f;
            
            // Track top 3 candidates for V9 logging (gated)
            var topCandidates = new List<(int tenor, int alto, float totalCost, float sopranoTensionBonus)>();
            float secondBestMoveCost = 0f;
            float secondBestWeightedMoveCost = 0f;
            float secondBestCompactnessCost = 0f;
            float secondBestTendCost = 0f;
            float secondBestRegisterPenalty = 0f;
            float secondBestCompressionPenalty = 0f;
            
            // Debug: Track spacing rejections
            int spacingRejectionsGapTB = 0;
            int spacingRejectionsGapAT = 0;
            int spacingRejectionsGapSA = 0;
            int spacingRejectionsOrdering = 0;
            
            // Debug: Track hard constraint pruning
            int generatedCandidates = 0;
            int rejectedByHardSpacingPreferred = 0;
            int rejectedByHardSpacingBassTenor = 0;
            int rejectedOtherHard = 0;
            int scoredCandidates = 0;
            
            // Enumerate all (Tenor, Alto) pairs and apply structural constraints first
            foreach (int tenor in tenorCandidates)
            {
                    if (tenor <= bassVoice)
                    {
                        if (enableFullSearchDebugSummary) spacingRejectionsOrdering++;
                        // Debug: This tenor rejects all alto combinations
                        if (s_enableHardPruneDebug)
                        {
                            generatedCandidates += altoCandidates.Count;
                            rejectedOtherHard += altoCandidates.Count;
                        }
                        continue;
                    }
                
                int gapTB = tenor - bassVoice;
                    if (gapTB > MaxTenorBassInterval)
                    {
                        if (enableFullSearchDebugSummary) spacingRejectionsGapTB++;
                        // Debug: This tenor rejects all alto combinations
                        if (s_enableHardPruneDebug)
                        {
                            generatedCandidates += altoCandidates.Count;
                            rejectedByHardSpacingBassTenor += altoCandidates.Count;
                        }
                        continue;
                    }
                
                foreach (int alto in altoCandidates)
                {
                    // Debug: Count generated candidates (each tenor-alto pair)
                    if (s_enableHardPruneDebug)
                    {
                        generatedCandidates++;
                    }
                    
                    if (alto < tenor)
                    {
                        if (enableFullSearchDebugSummary) spacingRejectionsOrdering++;
                        if (s_enableHardPruneDebug) rejectedOtherHard++;
                        continue; // ordering Tenor ≤ Alto
                    }
                    if (alto >= targetSopranoMidi)
                    {
                        if (enableFullSearchDebugSummary) spacingRejectionsGapSA++;
                        if (s_enableHardPruneDebug) rejectedOtherHard++;
                        continue;
                    }
                    
                    int gapAT = alto - tenor;
                    if (gapAT > MaxAltoTenorInterval)
                    {
                        if (enableFullSearchDebugSummary) spacingRejectionsGapAT++;
                        if (s_enableHardPruneDebug) rejectedByHardSpacingPreferred++;
                        continue;
                    }
                    
                    int gapSA = targetSopranoMidi - alto;
                    if (gapSA > MaxSopranoAltoInterval)
                    {
                        if (enableFullSearchDebugSummary) spacingRejectionsGapSA++;
                        if (s_enableHardPruneDebug) rejectedByHardSpacingPreferred++;
                        continue;
                    }
                    
                    // At this point we have a structurally valid SATB stack (spacing-wise)
                    
                    // Build full candidate voicing for coverage tests
                    int[] candidateVoices = new int[4] { bassVoice, tenor, alto, targetSopranoMidi };
                    
                    // Pitch classes for chord tones
                    int rootPc = chordTonePcs.Count > 0 ? chordTonePcs[0] : -1;
                    int thirdPc = chordTonePcs.Count > 1 ? chordTonePcs[1] : -1;
                    int fifthPc = chordTonePcs.Count > 2 ? chordTonePcs[2] : -1;
                    int seventhPc = chordTonePcs.Count > 3 ? chordTonePcs[3] : -1;
                    
                    // Determine whether this chord *has* a 7th in the recipe
                    bool chordHasSeventh =
                        current.Recipe.Extension == ChordExtension.Seventh &&
                        current.Recipe.SeventhQuality != SeventhQuality.None;
                    
                    // Collect pc -> count for the candidate chord
                    var pcCounts = new Dictionary<int, int>();
                    foreach (int m in candidateVoices)
                    {
                        int pc = (m % 12 + 12) % 12;
                        if (!pcCounts.TryGetValue(pc, out int cnt)) cnt = 0;
                        pcCounts[pc] = cnt + 1;
                    }
                    
                    // Helper to test presence
                    bool HasPc(int pc) => pc >= 0 && pcCounts.ContainsKey(pc);
                    
                    // Essential-tone coverage using priority system:
                    // 1) Root must be present (Required)
                    // 2) Third must be present (Required)
                    // 3) Fifth must be present only if it has Required priority (altered 5ths like #5, b5)
                    // 4) If chord has a 7th, at least one voice must have the 7th (Required)
                    bool hasRoot = HasPc(rootPc);
                    bool hasThird = HasPc(thirdPc);
                    bool hasSeventh = HasPc(seventhPc);
                    
                    // Check fifth priority - only require it if it's Required (altered 5th)
                    // For simple chords, fifth is Optional and can be omitted
                    bool fifthRequired = false;
                    bool hasFifth = HasPc(fifthPc);
                    if (fifthPc >= 0)
                    {
                        // Determine if fifth is required based on chord quality
                        // Diminished or Augmented triads have required 5ths
                        bool hasAlteredFifth = current.Recipe.Quality == ChordQuality.Diminished || 
                                              current.Recipe.Quality == ChordQuality.Augmented;
                        fifthRequired = hasAlteredFifth;
                    }
                    
                    bool coverageOk =
                        hasRoot &&
                        (thirdPc < 0 || hasThird) &&
                        (!fifthRequired || hasFifth) &&
                        (!chordHasSeventh || hasSeventh);
                    
                    // Pitch-class diversity: avoid "C, C, C, E"
                    // Require at least min(3, chordTonePcs.Count) distinct chord-tone pcs
                    int distinctChordPcsPresent = 0;
                    foreach (var kvp in pcCounts)
                    {
                        int pc = kvp.Key;
                        if (chordTonePcs.Contains(pc))
                            distinctChordPcsPresent++;
                    }
                    int requiredDistinct = Math.Min(3, chordTonePcs.Count);
                    bool diversityOk = distinctChordPcsPresent >= requiredDistinct;
                    
                    // Limit over-duplication: check max count of any pitch class
                    int maxCount = 0;
                    foreach (var kvp in pcCounts)
                    {
                        maxCount = Math.Max(maxCount, kvp.Value);
                    }
                    
                    // For triads: strict duplicate limit (max 2 copies of any pitch class)
                    // For 7th chords: use MaxDuplicateCountPerPc (also 2)
                    bool duplicateOk;
                    if (chordHasSeventh)
                    {
                        duplicateOk = maxCount <= MaxDuplicateCountPerPc;
                    }
                    else
                    {
                        // Triads: no pitch class can appear 3 or more times
                        duplicateOk = maxCount <= 2;
                    }
                    
                    // Final coverage check: different rules for triads vs 7th chords
                    bool essentialCoverageOk = coverageOk; // Root + 3rd present (and 7th if required)
                    
                    if (chordHasSeventh)
                    {
                        // For 7th chords: all checks must pass (coverage, diversity, duplicate)
                        if (!coverageOk || !diversityOk || !duplicateOk)
                        {
                            // Hard veto this (tenor, alto) pair
                            if (s_enableHardPruneDebug) rejectedOtherHard++;
                            if (GetTendencyDebug())
                            {
                                string chordName = $"{current.Key} {current.Recipe}";
                                string lastBestInfo = (lastBestTotalCost < float.MaxValue) 
                                    ? $", lastBest: move={lastBestMoveCost:F2}, compact={lastBestCompactCost:F2}, tend={lastBestTendCost:F2}, total={lastBestTotalCost:F2}"
                                    : "";
                                UnityEngine.Debug.Log(
                                    $"[SATB FullSearch Coverage Veto] B={bassVoice}, T={tenor}, A={alto}, S={targetSopranoMidi} " +
                                    $"for {chordName}: coverageOk={coverageOk}, diversityOk={diversityOk}, duplicateOk={duplicateOk}{lastBestInfo}");
                            }
                            continue; // skip to next candidate
                        }
                    }
                    else
                    {
                        // For triads: only require essential coverage (root + 3rd) and no tripled notes
                        // Diversity is soft (5th is optional, but we prefer it when available)
                        if (!essentialCoverageOk || !duplicateOk)
                        {
                            // Triads: only fail if essential coverage fails or we have triple notes
                            // (root+3rd OK, 5th optional; but no pitch class 3+ times)
                            if (s_enableHardPruneDebug) rejectedOtherHard++;
                            if (GetTendencyDebug())
                            {
                                string chordName = $"{current.Key} {current.Recipe}";
                                string lastBestInfo = (lastBestTotalCost < float.MaxValue) 
                                    ? $", lastBest: move={lastBestMoveCost:F2}, compact={lastBestCompactCost:F2}, tend={lastBestTendCost:F2}, total={lastBestTotalCost:F2}"
                                    : "";
                                UnityEngine.Debug.Log(
                                    $"[SATB FullSearch Coverage Veto] B={bassVoice}, T={tenor}, A={alto}, S={targetSopranoMidi} " +
                                    $"for {chordName}: coverageOk={coverageOk}, diversityOk={diversityOk}, duplicateOk={duplicateOk}, maxCount={maxCount}{lastBestInfo}");
                            }
                            continue; // skip to next candidate
                        }
                        
                        // diversityOk is *soft* for triads – just log it if you like
                        if (GetTendencyDebug() && !diversityOk)
                        {
                            string chordName = $"{current.Key} {current.Recipe}";
                            UnityEngine.Debug.Log(
                                $"[SATB FullSearch Triad] B={bassVoice}, T={tenor}, A={alto}, S={targetSopranoMidi} " +
                                $"for {chordName}: coverageOk={coverageOk}, diversityOk={diversityOk}, duplicateOk={duplicateOk}, maxCount={maxCount} (diversity soft for triads)");
                        }
                    }
                    
                    // NO DOUBLED TENSIONS VETO: Tensions/extensions may appear in at most ONE voice
                    // Build tension pitch class set for this chord
                    var tensionPcSet = new HashSet<int>();
                    var reqForDoubledTensionCheck = current.Recipe.RequestedExtensions;
                    int rootPcForTension = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                    if (rootPcForTension < 0) rootPcForTension = 0;
                    rootPcForTension = (rootPcForTension + current.Recipe.RootSemitoneOffset + 12) % 12;
                    if (rootPcForTension < 0) rootPcForTension += 12;
                    
                    // Add requested tensions (b9, 9, #9, #11, etc.)
                    if (reqForDoubledTensionCheck.TensionFlat9) tensionPcSet.Add((rootPcForTension + 1) % 12);
                    if (reqForDoubledTensionCheck.Tension9) tensionPcSet.Add((rootPcForTension + 2) % 12);
                    if (reqForDoubledTensionCheck.TensionSharp9) tensionPcSet.Add((rootPcForTension + 3) % 12);
                    if (reqForDoubledTensionCheck.TensionSharp11) tensionPcSet.Add((rootPcForTension + 6) % 12);
                    if (reqForDoubledTensionCheck.Add9) tensionPcSet.Add((rootPcForTension + 2) % 12);
                    if (reqForDoubledTensionCheck.Add11) tensionPcSet.Add((rootPcForTension + 5) % 12);
                    
                    // Also include natural 9 from dominant 7th extensions (e.g., V9)
                    // This handles cases where V9 has natural 9 but Tension9 flag might not be set
                    if (chordHasSeventh && current.Recipe.SeventhQuality == SeventhQuality.Dominant7 && 
                        !reqForDoubledTensionCheck.TensionFlat9 && !reqForDoubledTensionCheck.TensionSharp9)
                    {
                        // For dominant 7th, natural 9 is part of the extension (V9 = V7 + 9)
                        tensionPcSet.Add((rootPcForTension + 2) % 12);
                    }
                    
                    // Check if any tension PC appears more than once in the candidate voicing
                    bool hasDoubledTension = false;
                    int doubledTensionPc = -1;
                    var tensionOccurrences = new Dictionary<int, List<string>>(); // pc -> list of voice names
                    
                    foreach (int tensionPc in tensionPcSet)
                    {
                        int count = 0;
                        var voicesWithTension = new List<string>();
                        
                        for (int v = 0; v < candidateVoices.Length; v++)
                        {
                            int voicePc = (candidateVoices[v] % 12 + 12) % 12;
                            if (voicePc == tensionPc)
                            {
                                count++;
                                string voiceName = v == 0 ? "Bass" : v == 1 ? "Tenor" : v == 2 ? "Alto" : "Soprano";
                                voicesWithTension.Add(voiceName);
                            }
                        }
                        
                        if (count > 1)
                        {
                            hasDoubledTension = true;
                            doubledTensionPc = tensionPc;
                            tensionOccurrences[tensionPc] = voicesWithTension;
                            break; // Found a doubled tension, no need to check others
                        }
                    }
                    
                    if (hasDoubledTension)
                    {
                        // Hard veto: doubled tension detected
                        if (s_enableHardPruneDebug) rejectedOtherHard++;
                        
                        string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        string voicesStr = string.Join(",", tensionOccurrences[doubledTensionPc]);
                        string tensionName = "";
                        if (doubledTensionPc == (rootPcForTension + 1) % 12) tensionName = "b9";
                        else if (doubledTensionPc == (rootPcForTension + 2) % 12) tensionName = "9";
                        else if (doubledTensionPc == (rootPcForTension + 3) % 12) tensionName = "#9";
                        else if (doubledTensionPc == (rootPcForTension + 6) % 12) tensionName = "#11";
                        else tensionName = $"pc={doubledTensionPc}";
                        
                        if (GetTendencyDebug())
                        {
                            UnityEngine.Debug.Log(
                                $"[NO_DOUBLE_TENSION] Reject: tension {tensionName} (pc={doubledTensionPc}) occurs {tensionOccurrences[doubledTensionPc].Count}x " +
                                $"(voices: {voicesStr}) in chord {chordName} " +
                                $"B={bassVoice}, T={tenor}, A={alto}, S={targetSopranoMidi}");
                        }
                        continue; // skip to next candidate
                    }
                    
                    // Score each candidate with a simple cost function
                    // Movement cost: keep Tenor/Alto close to previous Tenor/Alto
                    float moveCost = Math.Abs(tenor - prevTenor) + Math.Abs(alto - prevAlto);
                    
                    // Optional tendency cost: reuse existing ComputeTendencyCostAdjustment
                    float tendCost = 0f;
                    if (tendencyInfos != null && tendencyInfos.Length > 0)
                    {
                        var tenorInfo = tendencyInfos[0];
                        tendCost += ComputeTendencyCostAdjustment(
                            tenorInfo, tenor, current.Key,
                            previousEvent.Recipe, current.Recipe,
                            previousAnalysis, currentAnalysis,
                            isSoprano: false, nextMelodyMidi: current.MelodyMidi,
                            voiceMinMidi: tenorMin, voiceMaxMidi: tenorMax);
                    }
                    
                    if (tendencyInfos != null && tendencyInfos.Length > 1)
                    {
                        var altoInfo = tendencyInfos[1];
                        tendCost += ComputeTendencyCostAdjustment(
                            altoInfo, alto, current.Key,
                            previousEvent.Recipe, current.Recipe,
                            previousAnalysis, currentAnalysis,
                            isSoprano: false, nextMelodyMidi: current.MelodyMidi,
                            voiceMinMidi: altoMin, voiceMaxMidi: altoMax);
                    }
                    
                    // Hard spacing already guaranteed: tenor > bass, alto >= tenor, gaps within Max* intervals.
                    // gapTB and gapAT are already computed above for spacing checks, so we can reuse them
                    
                    // Soft compactness: prefer smaller gaps, but don't force anything.
                    float compactnessCost =
                        gapTB * compactnessWeightTenorBass +
                        gapAT * compactnessWeightAltoTenor;
                    
                    // 1) Movement weighting
                    float weightedMoveCost = moveCost;
                    if (s_enableMovementWeighting)
                    {
                        weightedMoveCost *= s_movementWeightInnerVoices;
                    }
                    
                    // 2) Register gravity: pull Tenor/Alto toward preferred centres
                    float registerPenalty = 0f;
                    if (s_enableRegisterGravity)
                    {
                        // Distance from preferred centres in semitones
                        float tenorDist = Math.Abs(tenor - s_tenorRegisterCenter);
                        float altoDist = Math.Abs(alto - s_altoRegisterCenter);
                        registerPenalty += tenorDist * s_tenorRegisterWeight;
                        registerPenalty += altoDist * s_altoRegisterWeight;
                    }
                    
                    // 3) Compression incentive: penalise very wide inner spacing
                    float compressionPenalty = 0f;
                    if (s_enableCompressionCost)
                    {
                        // gapAT and gapSA are already computed above for spacing checks
                        if (gapAT > s_targetAltoTenorGap)
                        {
                            compressionPenalty += (gapAT - s_targetAltoTenorGap) * s_compressionWeightAT;
                        }
                        if (gapSA > s_targetSopAltoGap)
                        {
                            compressionPenalty += (gapSA - s_targetSopAltoGap) * s_compressionWeightSA;
                        }
                    }
                    
                    // 5) 11th tension heuristics (soprano-only, v1)
                    float eleventhTensionAdjustment = 0f;
                    if (s_enableEleventhHeuristics)
                    {
                        eleventhTensionAdjustment = ComputeEleventhTensionCostAdjustment(
                            current, targetSopranoMidi, bassVoice, tenor, alto, chordTonePcs);
                    }
                    
                    // 6) Extension placement policy (requested extensions)
                    float extensionPlacementAdjustment = ComputeExtensionPlacementCostAdjustment(
                        current, targetSopranoMidi, tenor, alto, null, false, false, false, chordTonePcs);
                    
                    // 7) Add-tone bonus (optional color tones - reward inclusion, no penalty for omission)
                    float addToneBonus = ComputeAddToneBonus(
                        current, targetSopranoMidi, tenor, alto, null, false, false, false);
                    
                    // 8) Soprano tension preference (style preference, not enforcement)
                    // Only apply when melody is NOT active (soprano is not protected/fixed by melody)
                    float sopranoTensionPreferenceBonus = 0f;
                    float rawPreference = 0f;
                    if (!current.MelodyMidi.HasValue && s_preferRequestedTensionInSopranoWeight > 0f)
                    {
                        rawPreference = ComputeRequestedTensionSopranoPreference(
                            current.Recipe, current.Key, targetSopranoMidi);
                        sopranoTensionPreferenceBonus = rawPreference * s_preferRequestedTensionInSopranoWeight;
                    }
                    
                    float totalCost = weightedMoveCost + compactnessCost + tendCost + registerPenalty + compressionPenalty + eleventhTensionAdjustment + extensionPlacementAdjustment + addToneBonus + sopranoTensionPreferenceBonus;
                    
                    // INSTRUMENTATION: Debug logging for V9 and extension 9 chords
                    if (!current.MelodyMidi.HasValue && s_preferRequestedTensionInSopranoWeight > 0f)
                    {
                        var req = current.Recipe.RequestedExtensions;
                        bool hasB9 = req.TensionFlat9;
                        bool shouldLog = hasB9 || 
                                        (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano && req.TensionFlat9);
                        
                        if (shouldLog)
                        {
                            string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                            int sopranoPc = (targetSopranoMidi % 12 + 12) % 12;
                            
                            // Build requested tension PC list
                            int rootPcForLog = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                            if (rootPcForLog < 0) rootPcForLog = 0;
                            rootPcForLog = (rootPcForLog + current.Recipe.RootSemitoneOffset + 12) % 12;
                            if (rootPcForLog < 0) rootPcForLog += 12;
                            
                            var requestedTensionPcs = new List<int>();
                            var requestedTensionNames = new List<string>();
                            if (req.TensionFlat9) { requestedTensionPcs.Add((rootPcForLog + 1) % 12); requestedTensionNames.Add("b9"); }
                            if (req.Tension9) { requestedTensionPcs.Add((rootPcForLog + 2) % 12); requestedTensionNames.Add("9"); }
                            if (req.TensionSharp9) { requestedTensionPcs.Add((rootPcForLog + 3) % 12); requestedTensionNames.Add("#9"); }
                            if (req.TensionSharp11) { requestedTensionPcs.Add((rootPcForLog + 6) % 12); requestedTensionNames.Add("#11"); }
                            
                            string tensionPcsStr = requestedTensionPcs.Count > 0 
                                ? string.Join(",", requestedTensionPcs) 
                                : "none";
                            string tensionNamesStr = requestedTensionNames.Count > 0 
                                ? string.Join(",", requestedTensionNames) 
                                : "none";
                            
                            bool bonusApplied = sopranoTensionPreferenceBonus != 0f;
                            string sopranoName = TheoryPitch.GetPitchNameFromMidi(targetSopranoMidi, current.Key);
                            
                            UnityEngine.Debug.Log(
                                $"[SOPRANO_TENSION_BONUS] step={stepIndex} chord={chordLabel}\n" +
                                $"  requestedTensions=[{tensionNamesStr}] (pcs=[{tensionPcsStr}])\n" +
                                $"  soprano={sopranoName}({targetSopranoMidi}, pc={sopranoPc})\n" +
                                $"  bonusApplied={bonusApplied}, rawPreference={rawPreference:F2}, weightedBonus={sopranoTensionPreferenceBonus:F2}\n" +
                                $"  totalCost={totalCost:F2}");
                        }
                    }
                    
                    // Debug: Count valid candidates
                    if (enableFullSearchDebugSummary)
                    {
                        validCandidatesCount++;
                    }
                    
                    // Debug: Count scored candidates (survived all hard checks)
                    if (s_enableHardPruneDebug)
                    {
                        scoredCandidates++;
                    }
                    
                    // Log candidate evaluation (after all hard filters pass, before comparison)
                    if (GetTendencyDebug())
                    {
                        UnityEngine.Debug.Log(
                            $"[SATB FullSearch Candidate] B={bassVoice}, T={tenor}, A={alto}, S={targetSopranoMidi} | " +
                            $"gapTB={gapTB}, gapAT={gapAT}, gapSA={gapSA} | " +
                            $"move={moveCost:F2}, moveW={weightedMoveCost:F2}, compact={compactnessCost:F2}, " +
                            $"reg={registerPenalty:F2}, compress={compressionPenalty:F2}, tend={tendCost:F2}, " +
                            $"sopTension={sopranoTensionPreferenceBonus:F2}, total={totalCost:F2}");
                    }
                    
                    // Track top candidates for V9 logging (gated)
                    var reqForTopLog = current.Recipe.RequestedExtensions;
                    bool hasExtension9ForLog = reqForTopLog.Tension9 || reqForTopLog.TensionFlat9 || reqForTopLog.TensionSharp9;
                    bool shouldTrackTopCandidates = hasExtension9ForLog || 
                                                   s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano ||
                                                   (current.Recipe.Extension == ChordExtension.Seventh && current.Recipe.Degree == 5); // V9
                    
                    if (shouldTrackTopCandidates)
                    {
                        // Insert candidate into sorted list (keep top 3)
                        topCandidates.Add((tenor, alto, totalCost, sopranoTensionPreferenceBonus));
                        topCandidates.Sort((a, b) => a.totalCost.CompareTo(b.totalCost));
                        if (topCandidates.Count > 3)
                            topCandidates.RemoveAt(topCandidates.Count - 1);
                    }
                    
                    if (totalCost < bestCost)
                    {
                        // Move current best to second best
                        if (enableFullSearchDebugSummary && bestCost < float.MaxValue)
                        {
                            secondBestCost = bestCost;
                            secondBestMoveCost = bestMoveCost;
                            secondBestWeightedMoveCost = bestWeightedMoveCost;
                            secondBestCompactnessCost = bestCompactnessCostDebug;
                            secondBestTendCost = bestTendCost;
                            secondBestRegisterPenalty = bestRegisterPenalty;
                            secondBestCompressionPenalty = bestCompressionPenalty;
                        }
                        
                        // Update best candidate
                        if (GetTendencyDebug())
                        {
                            UnityEngine.Debug.Log(
                                $"[SATB FullSearch Best] B={bassVoice}, T={tenor}, A={alto}, S={targetSopranoMidi} | " +
                                $"gapTB={gapTB}, gapAT={gapAT}, gapSA={gapSA} | " +
                                $"move={moveCost:F2}, moveW={weightedMoveCost:F2}, compact={compactnessCost:F2}, " +
                                $"reg={registerPenalty:F2}, compress={compressionPenalty:F2}, tend={tendCost:F2}, " +
                                $"sopTension={sopranoTensionPreferenceBonus:F2}, total={totalCost:F2}");
                        }
                        bestCost = totalCost;
                        bestCompactnessCost = compactnessCost;
                        bestTenor = tenor;
                        bestAlto = alto;
                        
                        // Debug: Store best cost breakdown
                        if (enableFullSearchDebugSummary)
                        {
                            bestMoveCost = moveCost;
                            bestWeightedMoveCost = weightedMoveCost;
                            bestCompactnessCostDebug = compactnessCost;
                            bestTendCost = tendCost;
                            bestRegisterPenalty = registerPenalty;
                            bestCompressionPenalty = compressionPenalty;
                        }
                        
                        // Track for coverage veto logging
                        lastBestMoveCost = moveCost;
                        lastBestCompactCost = compactnessCost;
                        lastBestTendCost = tendCost;
                        lastBestTotalCost = totalCost;
                    }
                    else if (enableFullSearchDebugSummary && totalCost < secondBestCost)
                    {
                        // Update second best
                        secondBestCost = totalCost;
                        secondBestMoveCost = moveCost;
                        secondBestWeightedMoveCost = weightedMoveCost;
                        secondBestCompactnessCost = compactnessCost;
                        secondBestTendCost = tendCost;
                        secondBestRegisterPenalty = registerPenalty;
                        secondBestCompressionPenalty = compressionPenalty;
                    }
                }
            }
            
            // Debug: Log hard constraint pruning summary
            if (s_enableHardPruneDebug)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                string summary = $"[HARD_PRUNE] step={stepIndex} gen={generatedCandidates} scored={scoredCandidates} rejPref={rejectedByHardSpacingPreferred} rejBT={rejectedByHardSpacingBassTenor} rejOther={rejectedOtherHard}";
                
                // Optional: If scoredCandidates <= 3, also print chosen voicing
                if (scoredCandidates <= 3 && bestTenor >= 0 && bestAlto >= 0)
                {
                    summary += $" chosen B={bassVoice} T={bestTenor} A={bestAlto} S={targetSopranoMidi} label={chordLabel}";
                }
                
                UnityEngine.Debug.Log(summary);
            }
            
            // Debug: Log full search summary
            if (enableFullSearchDebugSummary)
            {
                if (validCandidatesCount <= 1)
                {
                    UnityEngine.Debug.Log($"[FULL_SEARCH] step={stepIndex} DEGENERATE: only {validCandidatesCount} valid candidate");
                }
                else
                {
                    string secondBestStr = (secondBestCost < float.MaxValue) ? $" second={secondBestCost:F2}" : "";
                    UnityEngine.Debug.Log(
                        $"[FULL_SEARCH] step={stepIndex} valid={validCandidatesCount} best={bestCost:F2}{secondBestStr} chosen T={bestTenor} A={bestAlto} (B={bassVoice} S={targetSopranoMidi})"
                    );
                    
                    // Log cost breakdowns
                    UnityEngine.Debug.Log(
                        $"  best breakdown: move={bestMoveCost:F1} wMove={bestWeightedMoveCost:F1} comp={bestCompactnessCostDebug:F1} tend={bestTendCost:F1} reg={bestRegisterPenalty:F1} compr={bestCompressionPenalty:F1} total={bestCost:F2}"
                    );
                    
                    if (secondBestCost < float.MaxValue)
                    {
                        UnityEngine.Debug.Log(
                            $"  2nd breakdown: move={secondBestMoveCost:F1} wMove={secondBestWeightedMoveCost:F1} comp={secondBestCompactnessCost:F1} tend={secondBestTendCost:F1} reg={secondBestRegisterPenalty:F1} compr={secondBestCompressionPenalty:F1} total={secondBestCost:F2}"
                        );
                    }
                    
                    // Log spacing rejections
                    if (spacingRejectionsGapTB > 0 || spacingRejectionsGapAT > 0 || spacingRejectionsGapSA > 0 || spacingRejectionsOrdering > 0)
                    {
                        UnityEngine.Debug.Log(
                            $"  spacing rejections: gapTB={spacingRejectionsGapTB} gapAT={spacingRejectionsGapAT} gapSA={spacingRejectionsGapSA} ordering={spacingRejectionsOrdering}"
                        );
                    }
                }
            }
            
            // INSTRUMENTATION: Log top 3 candidates for V9 before final selection (gated)
            var reqForFinalLog = current.Recipe.RequestedExtensions;
            bool hasB9ForFinalLog = reqForFinalLog.TensionFlat9;
            bool shouldLogTopCandidates = hasB9ForFinalLog || 
                                       (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano && reqForFinalLog.TensionFlat9);
            
            if (shouldLogTopCandidates && topCandidates.Count > 0)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                int rootPcForFinalLog = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                if (rootPcForFinalLog < 0) rootPcForFinalLog = 0;
                rootPcForFinalLog = (rootPcForFinalLog + current.Recipe.RootSemitoneOffset + 12) % 12;
                if (rootPcForFinalLog < 0) rootPcForFinalLog += 12;
                
                var requestedTensionPcsForLog = new List<int>();
                var requestedTensionNamesForLog = new List<string>();
                if (reqForFinalLog.TensionFlat9) { requestedTensionPcsForLog.Add((rootPcForFinalLog + 1) % 12); requestedTensionNamesForLog.Add("b9"); }
                if (reqForFinalLog.Tension9) { requestedTensionPcsForLog.Add((rootPcForFinalLog + 2) % 12); requestedTensionNamesForLog.Add("9"); }
                if (reqForFinalLog.TensionSharp9) { requestedTensionPcsForLog.Add((rootPcForFinalLog + 3) % 12); requestedTensionNamesForLog.Add("#9"); }
                if (reqForFinalLog.TensionSharp11) { requestedTensionPcsForLog.Add((rootPcForFinalLog + 6) % 12); requestedTensionNamesForLog.Add("#11"); }
                
                string tensionPcsStr = requestedTensionPcsForLog.Count > 0 
                    ? string.Join(",", requestedTensionPcsForLog) 
                    : "none";
                string tensionNamesStr = requestedTensionNamesForLog.Count > 0 
                    ? string.Join(",", requestedTensionNamesForLog) 
                    : "none";
                
                UnityEngine.Debug.Log(
                    $"[TOP_CANDIDATES] step={stepIndex} chord={chordLabel} BEFORE final selection\n" +
                    $"  requestedTensions=[{tensionNamesStr}] (pcs=[{tensionPcsStr}])\n" +
                    $"  PreferRequestedTensionInSopranoWeight={s_preferRequestedTensionInSopranoWeight:F2}\n" +
                    $"  Top {Math.Min(3, topCandidates.Count)} candidates:");
                
                for (int i = 0; i < Math.Min(3, topCandidates.Count); i++)
                {
                    var cand = topCandidates[i];
                    int sopranoPc = (targetSopranoMidi % 12 + 12) % 12;
                    bool bonusApplied = cand.sopranoTensionBonus != 0f;
                    string sopranoName = TheoryPitch.GetPitchNameFromMidi(targetSopranoMidi, current.Key);
                    
                    UnityEngine.Debug.Log(
                        $"    #{i+1}: T={cand.tenor} A={cand.alto} S={targetSopranoMidi}({sopranoName},pc={sopranoPc}) " +
                        $"bonusApplied={bonusApplied} bonus={cand.sopranoTensionBonus:F2} totalCost={cand.totalCost:F2}");
                }
            }
            
            // Return the chosen voicing
            if (bestTenor < 0 || bestAlto < 0)
            {
                // No candidate survived spacing+coverage checks
                if (GetTendencyDebug())
                {
                    UnityEngine.Debug.LogWarning(
                        $"[SATB FullSearch] No candidate satisfied spacing+coverage at step {stepIndex}; " +
                        $"falling back to incremental voicing.");
                }
                return false;
            }
            
            // TRACE: Log selected voices for melody path
            if (enableTraceLogs && diags != null && diags.EnableTrace)
            {
                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                if (ShouldTrace(label))
                {
                    string tenorName = TheoryPitch.GetPitchNameFromMidi(bestTenor, current.Key);
                    string altoName = TheoryPitch.GetPitchNameFromMidi(bestAlto, current.Key);
                    string sopranoName = TheoryPitch.GetPitchNameFromMidi(targetSopranoMidi, current.Key);
                    TraceLog($"[TRACE] R{stepIndex} {label}: Selected voices (melody path) - Tenor={bestTenor}→{tenorName}, Alto={bestAlto}→{altoName}, Soprano={targetSopranoMidi}→{sopranoName}", diags);
                }
            }
            
            upperVoices.Add(bestTenor);
            upperVoices.Add(bestAlto);
            
            // Debug logging for chosen tenor
            if (GetTendencyDebug())
            {
                UnityEngine.Debug.Log(
                    $"[Tenor Range Debug] Step {stepIndex}: tenorChosen={bestTenor}");
            }
            
            // CHECKPOINT 1: Log voicing array immediately after solver selection (before any post-processing)
            var reqForCheckpoint = current.Recipe.RequestedExtensions;
            bool hasExtension9ForCheckpoint = reqForCheckpoint.Tension9 || reqForCheckpoint.TensionFlat9 || reqForCheckpoint.TensionSharp9;
            bool shouldLogCheckpoint = hasExtension9ForCheckpoint || 
                                      s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano ||
                                      (current.Recipe.Extension == ChordExtension.Seventh && current.Recipe.Degree == 5); // V9
            
            if (shouldLogCheckpoint)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                int[] checkpointVoices = new int[4] { bassVoice, bestTenor, bestAlto, targetSopranoMidi };
                UnityEngine.Debug.Log(
                    $"[CHECKPOINT_AFTER_SOLVER] step={stepIndex} chord={chordLabel}\n" +
                    $"  SATB MIDI array: [{string.Join(", ", checkpointVoices)}] (B={bassVoice}, T={bestTenor}, A={bestAlto}, S={targetSopranoMidi})");
            }
            
            // Step 5 debug logging: log final chosen voicing with chord tone analysis
            if (GetTendencyDebug() && stepIndex == 5)
            {
                int[] finalVoices = new int[4] { bassVoice, bestTenor, bestAlto, targetSopranoMidi };
                var finalPcCounts = new Dictionary<int, int>();
                foreach (int m in finalVoices)
                {
                    int pc = (m % 12 + 12) % 12;
                    if (!finalPcCounts.TryGetValue(pc, out int cnt)) cnt = 0;
                    finalPcCounts[pc] = cnt + 1;
                }
                
                // Get chord tone pitch classes for labeling
                int rootPcForLog = chordTonePcs.Count > 0 ? chordTonePcs[0] : -1;
                int thirdPcForLog = chordTonePcs.Count > 1 ? chordTonePcs[1] : -1;
                int fifthPcForLog = chordTonePcs.Count > 2 ? chordTonePcs[2] : -1;
                int seventhPcForLog = chordTonePcs.Count > 3 ? chordTonePcs[3] : -1;
                
                string chordTones = "";
                int maxCountForLog = 0;
                foreach (var kvp in finalPcCounts)
                {
                    int pc = kvp.Key;
                    string toneName = "";
                    if (pc == rootPcForLog) toneName = "Root";
                    else if (pc == thirdPcForLog) toneName = "3rd";
                    else if (pc == fifthPcForLog) toneName = "5th";
                    else if (pc == seventhPcForLog) toneName = "7th";
                    else toneName = $"PC{pc}";
                    chordTones += $"{toneName}(x{kvp.Value}) ";
                    maxCountForLog = Math.Max(maxCountForLog, kvp.Value);
                }
                
                // Recompute coverage/diversity/duplicate for logging
                bool hasRootForLog = rootPcForLog >= 0 && finalPcCounts.ContainsKey(rootPcForLog);
                bool hasThirdForLog = thirdPcForLog >= 0 && finalPcCounts.ContainsKey(thirdPcForLog);
                bool hasSeventhForLog = seventhPcForLog >= 0 && finalPcCounts.ContainsKey(seventhPcForLog);
                bool chordHasSeventhForLog = current.Recipe.Extension == ChordExtension.Seventh &&
                                             current.Recipe.SeventhQuality != SeventhQuality.None;
                bool coverageOkForLog = hasRootForLog &&
                                       (thirdPcForLog < 0 || hasThirdForLog) &&
                                       (!chordHasSeventhForLog || hasSeventhForLog);
                
                int distinctChordPcsForLog = 0;
                foreach (var kvp in finalPcCounts)
                {
                    if (chordTonePcs.Contains(kvp.Key))
                        distinctChordPcsForLog++;
                }
                int requiredDistinctForLog = Math.Min(3, chordTonePcs.Count);
                bool diversityOkForLog = distinctChordPcsForLog >= requiredDistinctForLog;
                bool duplicateOkForLog = maxCountForLog <= 2;
                
                UnityEngine.Debug.Log(
                    $"[Step 5 Final] Full search used: true, B={bassVoice}, T={bestTenor}, A={bestAlto}, S={targetSopranoMidi}, " +
                    $"chord tones: {chordTones}, maxCount={maxCountForLog}, " +
                    $"coverageOk={coverageOkForLog}, diversityOk={diversityOkForLog}, duplicateOk={duplicateOkForLog}");
            }
            
            // For 7th-resolution enforcement later, map previous indices to new MIDI values
            // Explicitly map index 0 → Tenor and index 1 → Alto
            if (prevUpper.Length > 0)
                voiceSelectionMap[0] = bestTenor; // previous Tenor -> new Tenor
            if (prevUpper.Length > 1)
                voiceSelectionMap[1] = bestAlto;  // previous Alto -> new Alto
            
            if (GetTendencyDebug())
            {
                // Recalculate values for the final chosen candidate
                int finalGapTB = bestTenor - bassVoice;
                int finalGapAT = bestAlto - bestTenor;
                int finalGapSA = targetSopranoMidi - bestAlto;
                
                // Reuse prevTenor and prevAlto from earlier in the method
                float finalMoveCost = Math.Abs(bestTenor - prevTenor) + Math.Abs(bestAlto - prevAlto);
                
                float finalTendCost = 0f;
                if (tendencyInfos != null && tendencyInfos.Length > 0)
                {
                    var tenorInfo = tendencyInfos[0];
                    finalTendCost += ComputeTendencyCostAdjustment(
                        tenorInfo, bestTenor, current.Key,
                        previousEvent.Recipe, current.Recipe,
                        previousAnalysis, currentAnalysis,
                        isSoprano: false, nextMelodyMidi: current.MelodyMidi,
                        voiceMinMidi: tenorMin, voiceMaxMidi: tenorMax);
                }
                if (tendencyInfos != null && tendencyInfos.Length > 1)
                {
                    var altoInfo = tendencyInfos[1];
                    finalTendCost += ComputeTendencyCostAdjustment(
                        altoInfo, bestAlto, current.Key,
                        previousEvent.Recipe, current.Recipe,
                        previousAnalysis, currentAnalysis,
                        isSoprano: false, nextMelodyMidi: current.MelodyMidi,
                        voiceMinMidi: altoMin, voiceMaxMidi: altoMax);
                }
                
                float finalWeightedMoveCost = finalMoveCost;
                if (s_enableMovementWeighting)
                {
                    finalWeightedMoveCost *= s_movementWeightInnerVoices;
                }
                
                float finalCompactCost = finalGapTB * compactnessWeightTenorBass + finalGapAT * compactnessWeightAltoTenor;
                
                float finalRegisterPenalty = 0f;
                if (s_enableRegisterGravity)
                {
                    float tenorDist = Math.Abs(bestTenor - s_tenorRegisterCenter);
                    float altoDist = Math.Abs(bestAlto - s_altoRegisterCenter);
                    finalRegisterPenalty += tenorDist * s_tenorRegisterWeight;
                    finalRegisterPenalty += altoDist * s_altoRegisterWeight;
                }
                
                float finalCompressionPenalty = 0f;
                if (s_enableCompressionCost)
                {
                    if (finalGapAT > s_targetAltoTenorGap)
                    {
                        finalCompressionPenalty += (finalGapAT - s_targetAltoTenorGap) * s_compressionWeightAT;
                    }
                    if (finalGapSA > s_targetSopAltoGap)
                    {
                        finalCompressionPenalty += (finalGapSA - s_targetSopAltoGap) * s_compressionWeightSA;
                    }
                }
                
                UnityEngine.Debug.Log(
                    $"[SATB FullSearch Chosen] B={bassVoice}, T={bestTenor}, A={bestAlto}, S={targetSopranoMidi} | " +
                    $"gapTB={finalGapTB}, gapAT={finalGapAT}, gapSA={finalGapSA} | " +
                    $"move={finalMoveCost:F2}, moveW={finalWeightedMoveCost:F2}, compact={finalCompactCost:F2}, " +
                    $"reg={finalRegisterPenalty:F2}, compress={finalCompressionPenalty:F2}, tend={finalTendCost:F2}, total={bestCost:F2}");
            }
            
            return true;
        }

        /// <summary>
        /// Builds upper voices (Tenor, Alto) for a chord with melody using incremental selection.
        /// This is the fallback method when full SATB search fails.
        /// </summary>
        private static void BuildUpperVoicesIncrementalWithMelody(
            ChordEvent previousEvent,
            ChordEvent current,
            int numVoices,
            int bassVoice,
            int upperMinMidi,
            int upperMaxMidi,
            List<int> prevUpper,
            VoiceTendencyInfo[] tendencyInfos,
            ChordFunctionProfile previousAnalysis,
            ChordFunctionProfile currentAnalysis,
            int targetSopranoMidi,
            List<int> chordTonePcs,
            List<int> upperVoices,
            Dictionary<int, int> voiceSelectionMap,
            int stepIndex,
            DiagnosticsCollector diags = null)
        {
            // AUG5_DBG: Track which voice (if any) held the augmented 5th in the previous chord
            int prevAug5VoiceIndex = -1;
            int prevAug5Midi = -1;
            int prevAug5Pc = -1;
            int targetResolutionPc = -1; // A = 9 in C major
            if (s_enableAug5Debug && previousEvent.Recipe.Quality == ChordQuality.Augmented)
            {
                var prevChordTonePcs = GetChordTonePitchClasses(previousEvent);
                if (prevChordTonePcs != null && prevChordTonePcs.Count >= 3)
                {
                    int prevRootPc = prevChordTonePcs[0];
                    int prevFifthPc = prevChordTonePcs[2];
                    if (ChordTensionHelper.IsAugmentedFifth(previousEvent.Recipe, ChordToneRole.Fifth))
                    {
                        prevAug5Pc = prevFifthPc;
                        targetResolutionPc = (prevAug5Pc + 1) % 12; // +1 semitone resolution
                        
                        // Find which voice in prevUpper has the aug5
                        for (int v = 0; v < prevUpper.Count; v++)
                        {
                            int prevMidi = prevUpper[v];
                            int prevPc = (prevMidi % 12 + 12) % 12;
                            if (prevPc == prevAug5Pc)
                            {
                                prevAug5VoiceIndex = v;
                                prevAug5Midi = prevMidi;
                                break;
                            }
                        }
                    }
                }
            }
            
            int melodyMidi = current.MelodyMidi.Value;
            int melodyPc = (melodyMidi % 12 + 12) % 12;
            
            // Remove melody pitch class from available pool to avoid duplicates in inner voices
            var availablePcs = new List<int>(chordTonePcs);
            availablePcs.RemoveAll(pc => pc == melodyPc);
            
            // Compute permissive lower bound for Tenor (same logic as full SATB search)
            int minFromBass = bassVoice + 1;
            int minFromUpper = upperMinMidi - 12;
            int tenorMin = Math.Min(minFromBass, minFromUpper);
            tenorMin = Math.Max(tenorMin, TenorAbsoluteMinMidi);
            
            // Generate candidates below the melody note (for inner voices only)
            // Use permissive tenor range for initial candidate generation
            // (Alto will be filtered from this list later)
            var candidates = GenerateCandidatesInRange(availablePcs, tenorMin, Math.Min(upperMaxMidi, targetSopranoMidi - 1));
            
            // Fill remaining upper voices (need numVoices - 2 more: one for bass, one for melody)
            int remainingVoices = numVoices - 2;
            var usedCandidates = new HashSet<int> { melodyMidi };
            
            // NO DOUBLED TENSIONS: Build tension set and tracking for this chord step
            var tensionPcSetForIncremental = new HashSet<int>();
            var tensionPcsAlreadyChosen = new HashSet<int>();
            var reqForIncremental = current.Recipe.RequestedExtensions;
            int rootPcForIncremental = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
            if (rootPcForIncremental < 0) rootPcForIncremental = 0;
            rootPcForIncremental = (rootPcForIncremental + current.Recipe.RootSemitoneOffset + 12) % 12;
            if (rootPcForIncremental < 0) rootPcForIncremental += 12;
            
            if (reqForIncremental.TensionFlat9) tensionPcSetForIncremental.Add((rootPcForIncremental + 1) % 12);
            if (reqForIncremental.Tension9) tensionPcSetForIncremental.Add((rootPcForIncremental + 2) % 12);
            if (reqForIncremental.TensionSharp9) tensionPcSetForIncremental.Add((rootPcForIncremental + 3) % 12);
            if (reqForIncremental.TensionSharp11) tensionPcSetForIncremental.Add((rootPcForIncremental + 6) % 12);
            if (reqForIncremental.Add9) tensionPcSetForIncremental.Add((rootPcForIncremental + 2) % 12);
            if (reqForIncremental.Add11) tensionPcSetForIncremental.Add((rootPcForIncremental + 5) % 12);
            
            // Include natural 9 from dominant 7th extensions (e.g., V9)
            bool chordHasSeventhForIncremental = current.Recipe.Extension == ChordExtension.Seventh &&
                                               current.Recipe.SeventhQuality != SeventhQuality.None;
            if (chordHasSeventhForIncremental && current.Recipe.SeventhQuality == SeventhQuality.Dominant7 && 
                !reqForIncremental.TensionFlat9 && !reqForIncremental.TensionSharp9)
            {
                tensionPcSetForIncremental.Add((rootPcForIncremental + 2) % 12);
            }
            
            // Try to preserve common tones from previous chord, but below melody
            // Use float costs with tendency adjustments for voice-leading
            for (int voiceIdx = 0; voiceIdx < prevUpper.Count && remainingVoices > 0; voiceIdx++)
            {
                int prevVoice = prevUpper[voiceIdx];
                int prevPc = (prevVoice % 12 + 12) % 12;
                
                // Determine which voice we're selecting based on how many we've already selected
                // voiceIdx=0, upperVoices.Count=0 -> selecting Tenor (first upper voice)
                // voiceIdx=1, upperVoices.Count=1 -> selecting Alto (second upper voice)
                bool isSelectingTenor = (upperVoices.Count == 0);
                bool isSelectingAlto = (upperVoices.Count == 1);
                string voiceLabel = isSelectingTenor ? "Tenor" : isSelectingAlto ? "Alto" : $"Voice{voiceIdx}";
                
                // LANE_MAP_DBG: Log which lane we think we're filling and the index we're appending to
                string fillingLane = isSelectingTenor ? "Tenor" : isSelectingAlto ? "Alto" : $"Voice{voiceIdx}";
                int upperVoicesAddIndex = upperVoices.Count;
                
                // Get known voices for spacing checks
                int knownTenor = isSelectingTenor ? -1 : (upperVoices.Count > 0 ? upperVoices[0] : -1);
                int knownAlto = isSelectingAlto ? -1 : (upperVoices.Count > 1 ? upperVoices[1] : -1);
                int knownSoprano = targetSopranoMidi;
                bool hasSoprano = true;
                
                int bestNote = -1;
                float bestCost = float.MaxValue;
                float chosenBaseCost = 0f;
                float chosenTendAdjust = 0f;
                
                // Spacing-aware candidate tracking
                float bestCostWithSpacing = float.MaxValue;
                int bestMidiWithSpacing = -1;
                float bestCostNoSpacing = float.MaxValue;
                int bestMidiNoSpacing = -1;
                
                // Get tendency info for this voice (gracefully handle if index out of range)
                var tendencyInfo = voiceIdx < tendencyInfos.Length ? tendencyInfos[voiceIdx] : new VoiceTendencyInfo { midiNote = prevVoice };
                
                // NAT9 DIAGNOSTIC: Check if this is a natural 9 resolution case
                bool isNat9Case = false;
                int nat9NinePc = -1;
                int nat9DownTargetPc = -1;
                int nat9UpTargetPc = -1;
                int nat9DownTargetMidi = -1;
                int nat9UpTargetMidi = -1;
                var nat9CandidatesToLog = new List<(int midi, float cost, float weightedMoveCost, float compactnessCost, float tendAdjust, float registerPenalty, float compressionPenalty, float commonThirdToSeventhAdjust, float extensionPlacementAdjustment, float addToneBonus, bool isDownTarget, bool isUpTarget, bool isChosen)>();
                if (stepIndex == 1)
                {
                    var prevReqExt = previousEvent.Recipe.RequestedExtensions;
                    int prevRootPcForNat9 = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                    if (prevRootPcForNat9 < 0) prevRootPcForNat9 = 0;
                    prevRootPcForNat9 = (prevRootPcForNat9 + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                    if (prevRootPcForNat9 < 0) prevRootPcForNat9 += 12;
                    bool prevIsDominant = (previousEvent.Recipe.Extension == ChordExtension.Seventh &&
                                          previousEvent.Recipe.SeventhQuality == SeventhQuality.Dominant7) ||
                                         (previousEvent.Recipe.Quality == ChordQuality.Major && 
                                          previousEvent.Recipe.Extension == ChordExtension.None);
                    bool prevHasNatural9 = (prevReqExt.HasAny && prevReqExt.Tension9 && !prevReqExt.TensionFlat9) ||
                                          (prevIsDominant && prevPc == (prevRootPcForNat9 + 2) % 12);
                    
                    if (prevHasNatural9 && prevPc == (prevRootPcForNat9 + 2) % 12)
                    {
                        isNat9Case = true;
                        nat9NinePc = (prevRootPcForNat9 + 2) % 12;
                        nat9DownTargetPc = (nat9NinePc + 10) % 12;  // -2 semitones
                        nat9UpTargetPc = (nat9NinePc + 2) % 12;     // +2 semitones
                        nat9DownTargetMidi = prevVoice - 2;
                        nat9UpTargetMidi = prevVoice + 2;
                    }
                }
                
                // Build voice-specific candidate list, starting with normal candidates
                var voiceCandidates = new List<int>(candidates);
                
                // AUG5_DBG: Hard constraint - Augmented 5th resolution enforcement
                // If previous chord had aug5 in this voice, and next chord supports targetPC, filter candidates
                bool shouldEnforceAug5Resolution = (prevAug5VoiceIndex >= 0 && voiceIdx == prevAug5VoiceIndex && targetResolutionPc >= 0);
                if (shouldEnforceAug5Resolution)
                {
                    // Check if next chord supports targetPC
                    bool nextChordSupportsTarget = chordTonePcs.Contains(targetResolutionPc);
                    
                    if (nextChordSupportsTarget)
                    {
                        // Check if at least one candidate exists with targetPC
                        var targetCandidates = voiceCandidates.Where(c => (c % 12 + 12) % 12 == targetResolutionPc).ToList();
                        
                        // Assert-style log: if condition is met but filter not applied, this should never happen
                        bool conditionMet = (targetCandidates.Count > 0);
                        if (conditionMet)
                        {
                            // Filter will be applied - this is expected
                        }
                        else
                        {
                            // Condition met (aug5 + supports target) but no target candidates - this is the "impossible" case
                        }
                        
                        if (targetCandidates.Count > 0)
                        {
                            // Filter: keep only candidates with targetPC
                            int originalCount = voiceCandidates.Count;
                            voiceCandidates = targetCandidates;
                            
                            // Assert-style log: verify filter was applied
                            if (voiceCandidates.Count != targetCandidates.Count || voiceCandidates.Count == 0)
                            {
                                UnityEngine.Debug.LogError(
                                    $"[AUG5_ENFORCE_ERR] conditionMet=true but filterNotApplied (originalCount={originalCount}, targetCandidates={targetCandidates.Count}, filteredCount={voiceCandidates.Count})");
                            }
                            
                            // Emit INFO diagnostic (NOT gated by debug flag - always visible in diagnostics panel)
                            string[] satbLanes = { "Tenor", "Alto" };
                            string satbLane = (voiceIdx < satbLanes.Length) ? satbLanes[voiceIdx] : $"Voice{voiceIdx}";
                            string prevName = TheoryPitch.GetPitchNameFromMidi(prevAug5Midi, previousEvent.Key);
                            string targetName = TheoryPitch.GetPitchNameFromMidi(targetCandidates[0], current.Key);
                            string nextChordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                            
                            // Add to diagnostics collector (visible in UI panel) - always-on
                            if (diags != null)
                            {
                                diags.Add(stepIndex, DiagSeverity.Info, "Aug5ResolutionEnforced", 
                                    $"lane={satbLane} {prevName} → {targetName} (nextChord={nextChordName})", 
                                    voiceIdx + 1, prevAug5Midi, targetCandidates[0]);
                            }
                            
                            // Also log to console for debugging (gated)
                            if (s_enableAug5Debug)
                            {
                                UnityEngine.Debug.Log(
                                    $"[AUG5] Aug5ResolutionEnforced: lane={satbLane} {prevName} → {targetName} (nextChord={nextChordName})");
                            }
                        }
                        else
                        {
                            // No target candidates exist - emit WARN
                            string[] satbLanes = { "Tenor", "Alto" };
                            string satbLane = (voiceIdx < satbLanes.Length) ? satbLanes[voiceIdx] : $"Voice{voiceIdx}";
                            string prevName = TheoryPitch.GetPitchNameFromMidi(prevAug5Midi, previousEvent.Key);
                            string targetName = TheoryPitch.GetPitchNameFromMidi(targetResolutionPc + 60, current.Key);
                            
                            // Add to diagnostics collector (visible in UI panel) - always-on
                            if (diags != null)
                            {
                                diags.Add(stepIndex, DiagSeverity.Warning, "Aug5ResolutionImpossible", 
                                    $"lane={satbLane} {prevName} target={targetName} (reason=NoTargetCandidate)", 
                                    voiceIdx + 1, prevAug5Midi, -1);
                            }
                            
                            // Also log to console (gated)
                            if (s_enableAug5Debug)
                            {
                                UnityEngine.Debug.LogWarning(
                                    $"[AUG5] Aug5ResolutionImpossible: lane={satbLane} {prevName} target={targetName} (reason=NoTargetCandidate)");
                            }
                        }
                    }
                }
                
                // CRITICAL: Hard no-crossing filter for Alto in SATB+melody path
                // Alto must be >= Tenor (allow unison for inner voices)
                if (isSelectingAlto && upperVoices.Count > 0) // Alto selection, Tenor already chosen
                {
                    int tenorMidi = upperVoices[0]; // Tenor is first in upperVoices
                    var filteredCandidates = new List<int>();
                    
                    if (s_enableSatbNoCrossingDebug)
                    {
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING] ENTRY: Alto selection filter activated at stepIndex={stepIndex}, " +
                            $"isSelectingAlto={isSelectingAlto}, upperVoices.Count={upperVoices.Count}, " +
                            $"Tenor={tenorMidi}, candidates.Count={voiceCandidates.Count}");
                        
                        // Log filter activation
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING] Filtering Alto candidates: stepIndex={stepIndex} Tenor={tenorMidi}, " +
                            $"originalCandidates=[{string.Join(",", voiceCandidates)}]");
                    }
                    
                    foreach (int candidate in voiceCandidates)
                    {
                        if (candidate >= tenorMidi) // Allow equality (unison)
                        {
                            filteredCandidates.Add(candidate);
                        }
                        else
                        {
                            // Log rejected candidate (gated)
                            if (s_enableSatbNoCrossingDebug)
                            {
                                string candidateName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                string tenorName = TheoryPitch.GetPitchNameFromMidi(tenorMidi, current.Key);
                                UnityEngine.Debug.Log(
                                    $"[SATB_NO_CROSSING] Rejected Alto candidate {candidate}({candidateName}) " +
                                    $"(PC={(candidate % 12 + 12) % 12}) because it's < Tenor {tenorMidi}({tenorName}) " +
                                    $"(stepIndex={stepIndex})");
                            }
                        }
                    }
                    
                    // If filtering emptied the list, try fallback: find nearest chord-tone candidate octave-shifted upward
                    if (filteredCandidates.Count == 0)
                    {
                        // Get all chord tone pitch classes
                        var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                        
                        // Try each chord tone PC, octave-shifting upward until >= tenorMidi
                        foreach (int pc in chordTonePcsSet)
                        {
                            int baseOctave = tenorMidi / 12;
                            for (int octaveOffset = 0; octaveOffset <= 2; octaveOffset++) // Try up to 2 octaves above
                            {
                                int candidateMidi = (baseOctave + octaveOffset) * 12 + pc;
                                
                                // Must be >= Tenor (allow unison)
                                if (candidateMidi < tenorMidi)
                                    continue;
                                
                                // Must be within Alto range
                                if (candidateMidi < upperMinMidi || candidateMidi > upperMaxMidi)
                                    continue;
                                
                                // Must be <= Soprano (if melody is present)
                                if (targetSopranoMidi > 0 && candidateMidi > targetSopranoMidi)
                                    continue;
                                
                                // Found a valid fallback candidate
                                if (!filteredCandidates.Contains(candidateMidi))
                                {
                                    filteredCandidates.Add(candidateMidi);
                                }
                            }
                        }
                        
                        // If still empty, log warning and keep best available (shouldn't happen, but safety)
                        if (filteredCandidates.Count == 0)
                        {
                            UnityEngine.Debug.LogWarning(
                                $"[SATB_NO_CROSSING] Cannot find Alto candidate >= Tenor ({tenorMidi}) for chord {TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe)}. " +
                                $"Original candidates: [{string.Join(",", voiceCandidates)}]. " +
                                $"Using best available candidate (may cause crossing).");
                            // Keep original candidates as fallback (will be caught by WouldCauseVoiceCrossing)
                            filteredCandidates = new List<int>(voiceCandidates);
                        }
                        else
                        {
                            // Log fallback strategy used (gated)
                            if (s_enableSatbNoCrossingDebug)
                            {
                                UnityEngine.Debug.Log(
                                    $"[SATB_NO_CROSSING] Alto candidate filtering emptied list at stepIndex={stepIndex}. " +
                                    $"Applied fallback: found {filteredCandidates.Count} candidates >= Tenor ({tenorMidi}). " +
                                    $"Fallback candidates: [{string.Join(",", filteredCandidates)}]");
                            }
                        }
                    }
                    else if (voiceCandidates.Count != filteredCandidates.Count)
                    {
                        // Log filtering summary (gated)
                        if (s_enableSatbNoCrossingDebug)
                        {
                            UnityEngine.Debug.Log(
                                $"[SATB_NO_CROSSING] Filtered Alto candidates: {voiceCandidates.Count} -> {filteredCandidates.Count} " +
                                $"(removed candidates < Tenor {tenorMidi}) at stepIndex={stepIndex}. " +
                                $"Filtered: [{string.Join(",", filteredCandidates)}]");
                        }
                    }
                    
                    voiceCandidates = filteredCandidates;
                }
                
                // AUG5_DBG Log #2: Log candidate pool for the voice that held aug5 in previous chord (before tendency scoring)
                // Map voiceIdx to SATB lane: prevUpper[0]=Tenor(SATB idx 1), prevUpper[1]=Alto(SATB idx 2)
                bool isAug5Voice = (s_enableAug5Debug && prevAug5VoiceIndex >= 0 && voiceIdx == prevAug5VoiceIndex);
                if (isAug5Voice)
                {
                    string prevNoteName = TheoryPitch.GetPitchNameFromMidi(prevAug5Midi, previousEvent.Key);
                    string roman = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                    // Map prevUpper index to SATB lane: [0=Tenor, 1=Alto] -> SATB indices [1, 2]
                    string[] satbLanes = { "Tenor", "Alto" };
                    string satbLane = (voiceIdx < satbLanes.Length) ? satbLanes[voiceIdx] : $"Voice{voiceIdx}";
                    int satbIndex = voiceIdx + 1; // prevUpper[0]=Tenor(SATB 1), prevUpper[1]=Alto(SATB 2)
                    
                    // Check if target A is in candidate list
                    bool containsTargetA = false;
                    var candidateDetails = new List<string>();
                    foreach (int cand in voiceCandidates)
                    {
                        int candPc = (cand % 12 + 12) % 12;
                        string candName = TheoryPitch.GetPitchNameFromMidi(cand, current.Key);
                        candidateDetails.Add($"{cand}({candName})");
                        if (candPc == targetResolutionPc)
                        {
                            containsTargetA = true;
                        }
                    }
                    
                    string candidatesStr = candidateDetails.Count > 0 ? string.Join(",", candidateDetails) : "[]";
                    UnityEngine.Debug.Log(
                        $"[AUG5_DBG] nextChordIndex={stepIndex} roman={roman} V{voiceIdx} lane={satbLane} prevMidi={prevAug5Midi}({prevNoteName}) targetPc={targetResolutionPc}(A) candidates=[{candidatesStr}] containsTargetA={containsTargetA}");
                    
                    // AUG5_DBG Log #3: If A is missing, log why (range check)
                    if (!containsTargetA && targetResolutionPc >= 0)
                    {
                        // Check if A exists in chord tones
                        bool targetAInChordTones = chordTonePcs.Contains(targetResolutionPc);
                        
                        // Check range constraints
                        int targetA_bestMidi = FindNearestPitchClassInRange(targetResolutionPc, prevAug5Midi, tenorMin, Math.Min(upperMaxMidi, targetSopranoMidi - 1));
                        bool targetA_inRange = targetA_bestMidi >= 0;
                        
                        string reason = "";
                        if (!targetAInChordTones)
                        {
                            reason = "NOT_IN_CHORD_TONES";
                        }
                        else if (!targetA_inRange)
                        {
                            reason = $"OUTSIDE_WINDOW (min={tenorMin} max={Math.Min(upperMaxMidi, targetSopranoMidi - 1)} targetA_best={targetA_bestMidi})";
                        }
                        else
                        {
                            reason = "UNKNOWN (check prefilter logs)";
                        }
                        
                        string[] satbLanes2 = { "Tenor", "Alto" };
                        string satbLane2 = (voiceIdx < satbLanes2.Length) ? satbLanes2[voiceIdx] : $"Voice{voiceIdx}";
                        UnityEngine.Debug.Log(
                            $"[AUG5_DBG] candidateWindow V{voiceIdx} lane={satbLane2} min={tenorMin} max={Math.Min(upperMaxMidi, targetSopranoMidi - 1)} | targetA_best={targetA_bestMidi} -> {reason}");
                    }
                }
                
                // For local leading tones, inject a nearby target root candidate (within ±3 semitones)
                if (tendencyInfo.isLocalLeadingTone && tendencyInfo.localTargetRootPc >= 0)
                {
                    int targetRootMidi = FindNearbyTargetRootForLocalLeadingTone(
                        prevVoice,
                        tendencyInfo.localTargetRootPc);
                    
                    // Validate that the target root candidate is a legal chord tone
                    if (targetRootMidi >= 0 && targetRootMidi < melodyMidi)
                    {
                        var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                        string voiceName = (voiceIdx == 0) ? "Tenor" : (voiceIdx == 1) ? "Alto" : $"Voice{voiceIdx}";
                        int validatedMidi = ValidateAndRedirectTendencyCandidate(
                            targetRootMidi,
                            chordTonePcsSet,
                            upperMinMidi,
                            Math.Min(upperMaxMidi, melodyMidi - 1),
                            stepIndex,
                            null, // diags not available in this context
                            voiceName,
                            prevVoice);
                        
                        if (validatedMidi >= 0 && !voiceCandidates.Contains(validatedMidi))
                        {
                            voiceCandidates.Add(validatedMidi);
                        }
                        // Note: diagnostics not available in this function context
                    }
                }
                
                // B9 RESOLUTION TRACE: Identify if this voice holds b9 and trace resolution candidates
                bool shouldTraceB9Resolution = previousEvent.Recipe.RequestedExtensions.TensionFlat9;
                int b9VoiceMidi = -1;
                int b9VoicePc = -1;
                int b9RootPcForTrace = -1;
                int b9TargetResolutionPc = -1;
                bool b9StepDownTargetExists = false;
                
                if (shouldTraceB9Resolution)
                {
                    b9RootPcForTrace = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                    if (b9RootPcForTrace < 0) b9RootPcForTrace = 0;
                    b9RootPcForTrace = (b9RootPcForTrace + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                    if (b9RootPcForTrace < 0) b9RootPcForTrace += 12;
                    int b9Pc = (b9RootPcForTrace + 1) % 12;
                    
                    if (prevPc == b9Pc)
                    {
                        b9VoiceMidi = prevVoice;
                        b9VoicePc = prevPc;
                        b9TargetResolutionPc = (b9Pc + 11) % 12; // -1 semitone from b9
                        b9StepDownTargetExists = chordTonePcs.Contains(b9TargetResolutionPc);
                        
                        string voiceName = isSelectingTenor ? "Tenor" : isSelectingAlto ? "Alto" : $"Voice{voiceIdx}";
                        string prevName = TheoryPitch.GetPitchNameFromMidi(prevVoice, previousEvent.Key);
                        UnityEngine.Debug.Log(
                            $"[B9_RESOLUTION_TRACE] step={stepIndex} voice={voiceName} holds b9:\n" +
                            $"  prevMidi={prevVoice} ({prevName}), prevPc={prevPc} (b9)\n" +
                            $"  targetResolutionPc={b9TargetResolutionPc}, stepDownTargetExists={b9StepDownTargetExists}");
                    }
                }
                
                // For chord 7ths, inject a resolution candidate (step down by 1-2 semitones)
                if (tendencyInfo.isChordSeventh)
                {
                    int seventhPc = (prevVoice % 12 + 12) % 12;
                    var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                    int resolutionMidi = FindSeventhResolutionCandidate(
                        prevVoice,
                        seventhPc,
                        upperMinMidi,
                        Math.Min(upperMaxMidi, melodyMidi - 1),
                        chordTonePcsSet,
                        current.MelodyMidi);
                    
                    // Validate that the resolution candidate is a legal chord tone
                    if (resolutionMidi >= 0 && resolutionMidi < melodyMidi)
                    {
                        string voiceName = (voiceIdx == 0) ? "Tenor" : (voiceIdx == 1) ? "Alto" : $"Voice{voiceIdx}";
                        int validatedMidi = ValidateAndRedirectTendencyCandidate(
                            resolutionMidi,
                            chordTonePcsSet,
                            upperMinMidi,
                            Math.Min(upperMaxMidi, melodyMidi - 1),
                            stepIndex,
                            null, // diags not available in this context
                            voiceName,
                            prevVoice);
                        
                        if (validatedMidi >= 0 && !voiceCandidates.Contains(validatedMidi))
                        {
                            voiceCandidates.Add(validatedMidi);
                        
                        if (enableTendencyDebug)
                        {
                                int resolutionPc = (validatedMidi % 12 + 12) % 12;
                                UnityEngine.Debug.Log($"[Tendency Debug] Injected 7th-resolution candidate: prev={prevVoice} ({seventhPc}), injected={validatedMidi} ({resolutionPc})");
                        }
                        }
                        // Note: diagnostics not available in this function context
                    }
                }
                
                // First, look for common tone (same pitch class) below melody
                foreach (int candidate in voiceCandidates)
                {
                    if (usedCandidates.Contains(candidate) || candidate >= melodyMidi)
                        continue;
                    
                    int candidatePc = (candidate % 12 + 12) % 12;
                    if (candidatePc == prevPc)
                    {
                        // Convert integer distance to float base cost
                        float baseCost = Math.Abs(candidate - prevVoice);
                        
                        // Check for common-tone 3rd→7th bonus: if prev voice is 3rd of current chord
                        // and candidate (same pitch) would be 7th of next chord
                        float commonThirdToSeventhAdjust = 0f;
                        var currentChordTonePcs = GetChordTonePitchClasses(new ChordEvent { Key = current.Key, Recipe = previousEvent.Recipe });
                        if (currentChordTonePcs.Count >= 2)
                        {
                            int currentThirdPc = currentChordTonePcs[1]; // Index 1 is 3rd
                            bool prevIsThirdOfCurrent = (prevPc == currentThirdPc);
                            
                            if (prevIsThirdOfCurrent)
                            {
                                // Check if next chord has a 7th and if this pitch class is that 7th
                                bool nextChordHasSeventh = current.Recipe.Extension == ChordExtension.Seventh &&
                                                          current.Recipe.SeventhQuality != SeventhQuality.None;
                                if (nextChordHasSeventh && chordTonePcs.Count >= 4)
                                {
                                    int nextSeventhPc = chordTonePcs[3]; // Index 3 is 7th
                                    if (candidatePc == nextSeventhPc)
                                    {
                                        commonThirdToSeventhAdjust = CommonThirdToSeventhBonus;
                                        
                                        if (enableTendencyDebug)
                                        {
                                            string prevName = TheoryPitch.GetPitchNameFromMidi(prevVoice, current.Key);
                                            string candName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                            UnityEngine.Debug.Log($"[Tendency Debug] Common 3rd→7th: prev={prevName}(3rd of {previousEvent.Recipe}) held as {candName}(7th of {current.Recipe}), bonus={CommonThirdToSeventhBonus}");
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Check for voice crossing: candidate must be > bass and > all previously selected upper voices
                        if (WouldCauseVoiceCrossing(candidate, bassVoice, upperVoices, out string crossingError))
                        {
                            // AUG5_DBG Log #3: Log rejection reason for aug5 voice
                            if (isAug5Voice)
                            {
                                string candName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                string[] satbLanes = { "Tenor", "Alto" };
                                string satbLane = (voiceIdx < satbLanes.Length) ? satbLanes[voiceIdx] : $"Voice{voiceIdx}";
                                string neighborInfo = $"B={bassVoice}";
                                if (upperVoices.Count > 0) neighborInfo += $" T={upperVoices[0]}";
                                if (upperVoices.Count > 1) neighborInfo += $" A={upperVoices[1]}";
                                UnityEngine.Debug.Log(
                                    $"[AUG5_DBG] prefilterReject V{voiceIdx} lane={satbLane} cand={candidate}({candName}) reason=ORDERING/{crossingError} ({neighborInfo})");
                            }
                            continue; // Skip to next candidate
                        }
                        
                        // Hard structural check: tenor must be above bass
                        if (isSelectingTenor && candidate <= bassVoice)
                        {
                            // AUG5_DBG Log #3: Log rejection reason for aug5 voice
                            if (isAug5Voice)
                            {
                                string candName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                string[] satbLanes4 = { "Tenor", "Alto" };
                                string satbLane4 = (voiceIdx < satbLanes4.Length) ? satbLanes4[voiceIdx] : $"Voice{voiceIdx}";
                                UnityEngine.Debug.Log(
                                    $"[AUG5_DBG] prefilterReject V{voiceIdx} lane={satbLane4} cand={candidate}({candName}) reason=ORDERING violates B={bassVoice} (tenor must be above bass)");
                            }
                            continue; // Skip to next candidate
                        }
                        
                        // STRUCTURAL REJECTION: Natural 9 resolution constraint
                        // If previous chord had natural 9 and next chord has valid stepwise resolution targets,
                        // reject any candidate that doesn't resolve by step (similar to b9 enforcement)
                        var prevReqExt = previousEvent.Recipe.RequestedExtensions;
                        int prevRootPcForNat9 = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                        if (prevRootPcForNat9 < 0) prevRootPcForNat9 = 0;
                        prevRootPcForNat9 = (prevRootPcForNat9 + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                        if (prevRootPcForNat9 < 0) prevRootPcForNat9 += 12;
                        bool prevIsDominant = (previousEvent.Recipe.Extension == ChordExtension.Seventh &&
                                              previousEvent.Recipe.SeventhQuality == SeventhQuality.Dominant7) ||
                                             (previousEvent.Recipe.Quality == ChordQuality.Major && 
                                              previousEvent.Recipe.Extension == ChordExtension.None);
                        bool prevHasNatural9 = (prevReqExt.HasAny && prevReqExt.Tension9 && !prevReqExt.TensionFlat9) ||
                                              (prevIsDominant && prevPc == (prevRootPcForNat9 + 2) % 12);
                        
                        if (prevHasNatural9 && prevPc == (prevRootPcForNat9 + 2) % 12)
                        {
                            // This voice has natural 9, check if candidate resolves by step
                            int ninePc = (prevRootPcForNat9 + 2) % 12;
                            int targetResolutionPcDown = (ninePc + 10) % 12;  // -2 semitones (down whole-step)
                            int targetResolutionPcUp = (ninePc + 2) % 12;     // +2 semitones (up whole-step)
                            
                            // Check if resolution targets exist in next chord
                            bool canResolveDown = chordTonePcs.Contains(targetResolutionPcDown);
                            bool canResolveUp = chordTonePcs.Contains(targetResolutionPcUp);
                            
                            // Also check requested tensions in next chord
                            if (current.Recipe.RequestedExtensions.HasAny)
                            {
                                int nextRootPc = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                                if (nextRootPc < 0) nextRootPc = 0;
                                nextRootPc = (nextRootPc + current.Recipe.RootSemitoneOffset + 12) % 12;
                                if (nextRootPc < 0) nextRootPc += 12;
                                var nextReqExt = current.Recipe.RequestedExtensions;
                                if (nextReqExt.TensionFlat9)
                                    canResolveDown = canResolveDown || (targetResolutionPcDown == (nextRootPc + 1) % 12);
                                else if (nextReqExt.Tension9)
                                    canResolveUp = canResolveUp || (targetResolutionPcUp == (nextRootPc + 2) % 12);
                            }
                            
                            // Check if at least one valid step target exists
                            if (canResolveDown || canResolveUp)
                            {
                                // Check if candidate is a valid stepwise resolution
                                candidatePc = (candidate % 12 + 12) % 12;
                                int semitoneDelta = candidate - prevVoice;
                                bool isDownwardStep = canResolveDown && semitoneDelta == -2 && candidatePc == targetResolutionPcDown;
                                bool isUpwardStep = canResolveUp && semitoneDelta == 2 && candidatePc == targetResolutionPcUp;
                                
                                // Reject candidate if it doesn't resolve by step
                                if (!isDownwardStep && !isUpwardStep)
                                {
                                    // STRUCTURAL REJECTION: Natural 9 must resolve by step when valid targets exist
                                    if (s_debugTensionDetect)
                                    {
                                        string prevName = TheoryPitch.GetPitchNameFromMidi(prevVoice, previousEvent.Key);
                                        string candName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                        string voiceName = isSelectingTenor ? "Tenor" : "Alto";
                                        string targetInfo = "";
                                        if (canResolveDown)
                                        {
                                            int downTarget = prevVoice - 2;
                                            targetInfo += $"down={TheoryPitch.GetPitchNameFromMidi(downTarget, current.Key)}";
                                        }
                                        if (canResolveUp)
                                        {
                                            if (targetInfo.Length > 0) targetInfo += ", ";
                                            int upTarget = prevVoice + 2;
                                            targetInfo += $"up={TheoryPitch.GetPitchNameFromMidi(upTarget, current.Key)}";
                                        }
                                        UnityEngine.Debug.Log(
                                            $"[NAT9_REJECT] step={stepIndex} voice={voiceName}: REJECTED candidate {candName}({candidate}) " +
                                            $"(prev={prevName}({prevVoice}) has natural 9, valid targets exist: {targetInfo}, but candidate doesn't resolve by step)");
                                    }
                                    continue; // Reject this candidate - skip to next
                                }
                            }
                        }
                        
                        // Apply tendency adjustments (inner voices only, not soprano)
                        // Pass voice range for hard 7th resolution constraint
                        float tendAdjust = ComputeTendencyCostAdjustment(
                            tendencyInfo, candidate, current.Key,
                            previousEvent.Recipe, current.Recipe,
                            previousAnalysis, currentAnalysis,
                            isSoprano: false, nextMelodyMidi: current.MelodyMidi,
                            voiceMinMidi: upperMinMidi, voiceMaxMidi: Math.Min(upperMaxMidi, melodyMidi - 1));
                        
                        // Compute cost components matching full search model
                        // 1) Movement cost (weighted if enabled)
                        float moveCost = baseCost;
                        float weightedMoveCost = moveCost;
                        if (s_enableMovementWeighting)
                        {
                            weightedMoveCost *= s_movementWeightInnerVoices;
                        }
                        
                        // 2) Compactness cost (only if we have both voices or can compute gap)
                        float compactnessCost = 0f;
                        if (isSelectingTenor)
                        {
                            int gapTB = candidate - bassVoice;
                            compactnessCost = gapTB * compactnessWeightTenorBass;
                        }
                        else if (isSelectingAlto && knownTenor >= 0)
                        {
                            int gapAT = candidate - knownTenor;
                            compactnessCost = gapAT * compactnessWeightAltoTenor;
                            // Also add gapTB if we can compute it (but we don't have prevTenor here, so skip for now)
                        }
                        
                        // 3) Register gravity penalty
                        float registerPenalty = 0f;
                        if (s_enableRegisterGravity)
                        {
                            if (isSelectingTenor)
                            {
                                float tenorDist = Math.Abs(candidate - s_tenorRegisterCenter);
                                registerPenalty += tenorDist * s_tenorRegisterWeight;
                            }
                            else if (isSelectingAlto)
                            {
                                float altoDist = Math.Abs(candidate - s_altoRegisterCenter);
                                registerPenalty += altoDist * s_altoRegisterWeight;
                            }
                        }
                        
                        // 4) Compression penalty (only when selecting alto, since we need both voices)
                        float compressionPenalty = 0f;
                        if (s_enableCompressionCost && isSelectingAlto && knownTenor >= 0)
                        {
                            int gapAT = candidate - knownTenor;
                            if (gapAT > s_targetAltoTenorGap)
                            {
                                compressionPenalty += (gapAT - s_targetAltoTenorGap) * s_compressionWeightAT;
                            }
                            if (hasSoprano)
                            {
                                int gapSA = knownSoprano - candidate;
                                if (gapSA > s_targetSopAltoGap)
                                {
                                    compressionPenalty += (gapSA - s_targetSopAltoGap) * s_compressionWeightSA;
                                }
                            }
                        }
                        
                        // 5) Extension placement policy (apply at each voice selection stage)
                        float extensionPlacementAdjustment = 0f;
                        if (isSelectingTenor)
                        {
                            // When selecting Tenor: penalize if candidate is a melodic tension
                            extensionPlacementAdjustment = ComputeExtensionPlacementCostAdjustment(
                                current, targetSopranoMidi, null, null, candidate, true, false, false, chordTonePcs);
                        }
                        else if (isSelectingAlto && knownTenor >= 0)
                        {
                            // When selecting Alto: check placement with known tenor and soprano
                            extensionPlacementAdjustment = ComputeExtensionPlacementCostAdjustment(
                                current, targetSopranoMidi, knownTenor, null, candidate, false, true, false, chordTonePcs);
                        }
                        // Note: Soprano selection happens outside this loop (melody is fixed), so we don't handle it here
                        
                        // 6) Add-tone bonus (optional color tones - reward inclusion, no penalty for omission)
                        float addToneBonus = ComputeAddToneBonus(
                            current, targetSopranoMidi, 
                            isSelectingTenor ? candidate : (int?)knownTenor,
                            isSelectingAlto ? candidate : null,
                            candidate,
                            isSelectingTenor, isSelectingAlto, false);
                        
                        // Total cost matching full search model
                        float totalCost = weightedMoveCost + compactnessCost + tendAdjust + registerPenalty + compressionPenalty + commonThirdToSeventhAdjust + extensionPlacementAdjustment + addToneBonus;
                        
                        // DIAGNOSTIC: Log all cost components for step 1 b9 resolution candidates
                        if (stepIndex == 1 && previousEvent.Recipe.RequestedExtensions.TensionFlat9)
                        {
                            int prevRootPc = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                            if (prevRootPc < 0) prevRootPc = 0;
                            prevRootPc = (prevRootPc + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                            if (prevRootPc < 0) prevRootPc += 12;
                            int b9Pc = (prevRootPc + 1) % 12;
                            
                            if (prevPc == b9Pc)
                            {
                                int b9TargetResolutionPcForDiag = (b9Pc + 11) % 12;
                                bool isStrictStep = (candidate - prevVoice == -1);
                                bool matchesTarget = (candidatePc == b9TargetResolutionPcForDiag);
                                string voiceName = isSelectingTenor ? "Tenor" : "Alto";
                                
                                UnityEngine.Debug.Log(
                                    $"[STEP1_COST_DIAG] step=1 {voiceName} candidate={candidate} cost breakdown:\n" +
                                    $"  weightedMoveCost={weightedMoveCost}, compactnessCost={compactnessCost}\n" +
                                    $"  tendAdjust={tendAdjust} (includes b9 resolution bonus/penalty)\n" +
                                    $"  registerPenalty={registerPenalty} (registerCenter={s_tenorRegisterCenter}/{s_altoRegisterCenter})\n" +
                                    $"  compressionPenalty={compressionPenalty}, extensionPlacement={extensionPlacementAdjustment}\n" +
                                    $"  addToneBonus={addToneBonus}, totalCost={totalCost}\n" +
                                    $"  isStrictStep={isStrictStep}, matchesTarget={matchesTarget}");
                            }
                        }
                        
                        // Check spacing constraints based on which voice we're selecting
                        bool spacingOK = true;
                        if (isSelectingTenor)
                        {
                            // Tenor spacing: Tenor - Bass ≤ MaxTenorBassInterval
                            int gapTB = candidate - bassVoice;
                            spacingOK = gapTB <= MaxTenorBassInterval;
                        }
                        else if (isSelectingAlto)
                        {
                            // Alto spacing: Alto - Tenor ≤ MaxAltoTenorInterval
                            int gapAT = candidate - knownTenor;
                            spacingOK = gapAT <= MaxAltoTenorInterval;
                            
                            // Also check Soprano - Alto if soprano is known
                            if (hasSoprano && spacingOK)
                            {
                                int gapSA = knownSoprano - candidate;
                                spacingOK = gapSA <= MaxSopranoAltoInterval;
                            }
                        }
                        
                        // Track best candidate with spacing constraint
                        if (spacingOK)
                        {
                            if (totalCost < bestCostWithSpacing)
                            {
                                bestCostWithSpacing = totalCost;
                                bestMidiWithSpacing = candidate;
                            }
                        }
                        
                        // Always track best overall candidate for fallback
                        if (totalCost < bestCostNoSpacing)
                        {
                            bestCostNoSpacing = totalCost;
                            bestMidiNoSpacing = candidate;
                        }
                        
                        // Keep old logic for backward compatibility during transition
                        if (totalCost < bestCost)
                        {
                            bestNote = candidate;
                            bestCost = totalCost;
                            chosenBaseCost = baseCost;
                            chosenTendAdjust = tendAdjust;
                        }
                        
                        // NAT9 DIAGNOSTIC: Track candidates for logging with full cost breakdown
                        if (isNat9Case)
                        {
                            int candidatePcForNat9 = (candidate % 12 + 12) % 12;
                            bool isDownTarget = (candidate == nat9DownTargetMidi) && (candidatePcForNat9 == nat9DownTargetPc);
                            bool isUpTarget = (candidate == nat9UpTargetMidi) && (candidatePcForNat9 == nat9UpTargetPc);
                            nat9CandidatesToLog.Add((candidate, totalCost, weightedMoveCost, compactnessCost, tendAdjust, registerPenalty, compressionPenalty, commonThirdToSeventhAdjust, extensionPlacementAdjustment, addToneBonus, isDownTarget, isUpTarget, false));
                        }
                    }
                }
                
                // NAT9 DIAGNOSTIC: Mark the chosen candidate and print selected candidates
                if (isNat9Case && nat9CandidatesToLog.Count > 0)
                {
                    // Mark the chosen candidate
                    int chosenMidi = (bestMidiWithSpacing >= 0) ? bestMidiWithSpacing : bestMidiNoSpacing;
                    if (chosenMidi < 0) chosenMidi = bestNote;
                    
                    for (int i = 0; i < nat9CandidatesToLog.Count; i++)
                    {
                        var cand = nat9CandidatesToLog[i];
                        if (cand.midi == chosenMidi)
                        {
                            nat9CandidatesToLog[i] = (cand.midi, cand.cost, cand.weightedMoveCost, cand.compactnessCost, cand.tendAdjust, cand.registerPenalty, cand.compressionPenalty, cand.commonThirdToSeventhAdjust, cand.extensionPlacementAdjustment, cand.addToneBonus, cand.isDownTarget, cand.isUpTarget, true);
                            break;
                        }
                    }
                    
                    // Sort by cost to find top candidates
                    var sortedCandidates = nat9CandidatesToLog.OrderBy(c => c.cost).ToList();
                    
                    // Determine which candidates to log: always log targets and chosen, plus top 3
                    var candidatesToLog = new HashSet<int>();
                    
                    // Always log down and up targets
                    foreach (var cand in nat9CandidatesToLog)
                    {
                        if (cand.isDownTarget || cand.isUpTarget || cand.isChosen)
                            candidatesToLog.Add(cand.midi);
                    }
                    
                    // Add top 3 by cost
                    for (int i = 0; i < Math.Min(3, sortedCandidates.Count); i++)
                    {
                        candidatesToLog.Add(sortedCandidates[i].midi);
                    }
                    
                    // Now log the selected candidates with full cost breakdown
                    string voiceName = isSelectingTenor ? "Tenor" : "Alto";
                    foreach (var cand in nat9CandidatesToLog)
                    {
                        if (!candidatesToLog.Contains(cand.midi))
                            continue;
                        
                        string candName = TheoryPitch.GetPitchNameFromMidi(cand.midi, current.Key);
                        string prevName = TheoryPitch.GetPitchNameFromMidi(prevVoice, previousEvent.Key);
                        string targetType = cand.isDownTarget ? "targetDown" : cand.isUpTarget ? "targetUp" : "neither";
                        string chosenMarker = cand.isChosen ? " <-- CHOSEN" : "";
                        
                        // Re-compute natural 9 specific bonuses/penalties
                        float nat9DownBonus = 0f;
                        float nat9UpBonus = 0f;
                        float nat9StructuralPenalty = 0f;
                        float nat9LeapPenalty = 0f;
                        
                        int candPc = (cand.midi % 12 + 12) % 12;
                        int semitoneDelta = cand.midi - prevVoice;
                        int absDelta = Math.Abs(semitoneDelta);
                        
                        // Check if this is a valid resolution target
                        var nextCandidatePcs = new HashSet<int>(chordTonePcs);
                        if (current.Recipe.RequestedExtensions.HasAny)
                        {
                            int nextRootPc = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                            if (nextRootPc < 0) nextRootPc = 0;
                            nextRootPc = (nextRootPc + current.Recipe.RootSemitoneOffset + 12) % 12;
                            if (nextRootPc < 0) nextRootPc += 12;
                            var nextReqExt = current.Recipe.RequestedExtensions;
                            if (nextReqExt.TensionFlat9)
                                nextCandidatePcs.Add((nextRootPc + 1) % 12);
                            else if (nextReqExt.Tension9)
                                nextCandidatePcs.Add((nextRootPc + 2) % 12);
                            if (nextReqExt.TensionSharp11)
                                nextCandidatePcs.Add((nextRootPc + 6) % 12);
                        }
                        
                        bool canResolveDown = nextCandidatePcs.Contains(nat9DownTargetPc);
                        bool canResolveUp = nextCandidatePcs.Contains(nat9UpTargetPc);
                        bool usesDownwardResolution = canResolveDown && semitoneDelta == -2 && candPc == nat9DownTargetPc;
                        bool usesUpwardResolution = canResolveUp && semitoneDelta == 2 && candPc == nat9UpTargetPc;
                        bool isLeap = absDelta >= 5;
                        
                        if (usesDownwardResolution)
                        {
                            nat9DownBonus = ninthResolutionNatural9DownBonus;
                        }
                        else if (usesUpwardResolution)
                        {
                            nat9UpBonus = ninthResolutionNatural9UpBonus;
                        }
                        else if ((canResolveDown || canResolveUp) && !usesDownwardResolution && !usesUpwardResolution)
                        {
                            // Check if targets are valid (in range - use voice range parameters)
                            bool downwardTargetValid = canResolveDown && nat9DownTargetMidi >= upperMinMidi && nat9DownTargetMidi <= upperMaxMidi;
                            bool upwardTargetValid = canResolveUp && nat9UpTargetMidi >= upperMinMidi && nat9UpTargetMidi <= upperMaxMidi;
                            if (downwardTargetValid || upwardTargetValid)
                            {
                                nat9StructuralPenalty = +35.0f;
                            }
                        }
                        
                        if (isLeap && !usesDownwardResolution && !usesUpwardResolution)
                        {
                            nat9LeapPenalty = ninthResolutionNatural9LeapPenalty;
                        }
                        
                        UnityEngine.Debug.Log(
                            $"[N9_DBG] step={stepIndex} voice={voiceName} prev={prevName}({prevVoice}) cand={candName}({cand.midi}) ({targetType}){chosenMarker}\n" +
                            $"  appliedDownBonus={usesDownwardResolution} ({(usesDownwardResolution ? nat9DownBonus : 0f)}), " +
                            $"appliedUpBonus={usesUpwardResolution} ({(usesUpwardResolution ? nat9UpBonus : 0f)}), " +
                            $"appliedStructuralPenalty={!usesDownwardResolution && !usesUpwardResolution && nat9StructuralPenalty > 0f} ({nat9StructuralPenalty}), " +
                            $"appliedLeapPenalty={isLeap} ({nat9LeapPenalty})\n" +
                            $"  weightedMoveCost={cand.weightedMoveCost}, compactnessCost={cand.compactnessCost}, tendAdjust={cand.tendAdjust}\n" +
                            $"  registerPenalty={cand.registerPenalty}, compressionPenalty={cand.compressionPenalty}, commonThirdToSeventh={cand.commonThirdToSeventhAdjust}\n" +
                            $"  extensionPlacement={cand.extensionPlacementAdjustment}, addToneBonus={cand.addToneBonus}, totalCost={cand.cost}");
                    }
                }
                
                // If no common tone found, find nearest chord tone below melody with tendency adjustments
                if (bestMidiWithSpacing < 0 && bestMidiNoSpacing < 0)
                {
                    foreach (int candidate in voiceCandidates)
                    {
                        if (usedCandidates.Contains(candidate) || candidate >= melodyMidi)
                            continue;
                        
                        // Convert integer distance to float base cost
                        float baseCost = Math.Abs(candidate - prevVoice);
                        
                        // Check for voice crossing: candidate must be > bass and > all previously selected upper voices
                        if (WouldCauseVoiceCrossing(candidate, bassVoice, upperVoices, out string crossingError))
                        {
                            // Veto this candidate with huge penalty
                            // (Debug log removed to reduce spam - voice crossing checks are expected during candidate filtering)
                            // Don't evaluate this candidate further - skip it
                            continue;
                        }
                        
                        // Hard structural check: tenor must be above bass
                        if (isSelectingTenor && candidate <= bassVoice)
                        {
                            continue; // Skip to next candidate
                        }
                        
                        // STRUCTURAL REJECTION: Natural 9 resolution constraint (nearest chord tone path)
                        // Same logic as in common-tone path above
                        var prevReqExt2 = previousEvent.Recipe.RequestedExtensions;
                        int prevRootPcForNat9_2 = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                        if (prevRootPcForNat9_2 < 0) prevRootPcForNat9_2 = 0;
                        prevRootPcForNat9_2 = (prevRootPcForNat9_2 + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                        if (prevRootPcForNat9_2 < 0) prevRootPcForNat9_2 += 12;
                        bool prevIsDominant2 = (previousEvent.Recipe.Extension == ChordExtension.Seventh &&
                                              previousEvent.Recipe.SeventhQuality == SeventhQuality.Dominant7) ||
                                             (previousEvent.Recipe.Quality == ChordQuality.Major && 
                                              previousEvent.Recipe.Extension == ChordExtension.None);
                        bool prevHasNatural9_2 = (prevReqExt2.HasAny && prevReqExt2.Tension9 && !prevReqExt2.TensionFlat9) ||
                                              (prevIsDominant2 && prevPc == (prevRootPcForNat9_2 + 2) % 12);
                        
                        if (prevHasNatural9_2 && prevPc == (prevRootPcForNat9_2 + 2) % 12)
                        {
                            int ninePc2 = (prevRootPcForNat9_2 + 2) % 12;
                            int targetResolutionPcDown2 = (ninePc2 + 10) % 12;
                            int targetResolutionPcUp2 = (ninePc2 + 2) % 12;
                            
                            bool canResolveDown2 = chordTonePcs.Contains(targetResolutionPcDown2);
                            bool canResolveUp2 = chordTonePcs.Contains(targetResolutionPcUp2);
                            
                            if (current.Recipe.RequestedExtensions.HasAny)
                            {
                                int nextRootPc2 = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                                if (nextRootPc2 < 0) nextRootPc2 = 0;
                                nextRootPc2 = (nextRootPc2 + current.Recipe.RootSemitoneOffset + 12) % 12;
                                if (nextRootPc2 < 0) nextRootPc2 += 12;
                                var nextReqExt2 = current.Recipe.RequestedExtensions;
                                if (nextReqExt2.TensionFlat9)
                                    canResolveDown2 = canResolveDown2 || (targetResolutionPcDown2 == (nextRootPc2 + 1) % 12);
                                else if (nextReqExt2.Tension9)
                                    canResolveUp2 = canResolveUp2 || (targetResolutionPcUp2 == (nextRootPc2 + 2) % 12);
                            }
                            
                            if (canResolveDown2 || canResolveUp2)
                            {
                                int candidatePc2 = (candidate % 12 + 12) % 12;
                                int semitoneDelta2 = candidate - prevVoice;
                                bool isDownwardStep2 = canResolveDown2 && semitoneDelta2 == -2 && candidatePc2 == targetResolutionPcDown2;
                                bool isUpwardStep2 = canResolveUp2 && semitoneDelta2 == 2 && candidatePc2 == targetResolutionPcUp2;
                                
                                if (!isDownwardStep2 && !isUpwardStep2)
                                {
                                    if (s_debugTensionDetect)
                                    {
                                        string prevName2 = TheoryPitch.GetPitchNameFromMidi(prevVoice, previousEvent.Key);
                                        string candName2 = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                        string voiceName2 = isSelectingTenor ? "Tenor" : "Alto";
                                        UnityEngine.Debug.Log(
                                            $"[NAT9_REJECT] step={stepIndex} voice={voiceName2} (nearest path): REJECTED candidate {candName2}({candidate}) " +
                                            $"(prev={prevName2}({prevVoice}) has natural 9, but candidate doesn't resolve by step)");
                                    }
                                    continue; // Reject this candidate
                                }
                            }
                        }
                        
                        // Apply tendency adjustments (inner voices only, not soprano)
                        // Pass voice range for hard 7th resolution constraint
                        float tendAdjust = ComputeTendencyCostAdjustment(
                            tendencyInfo, candidate, current.Key,
                            previousEvent.Recipe, current.Recipe,
                            previousAnalysis, currentAnalysis,
                            isSoprano: false, nextMelodyMidi: current.MelodyMidi,
                            voiceMinMidi: upperMinMidi, voiceMaxMidi: Math.Min(upperMaxMidi, melodyMidi - 1));
                        
                        // Compute cost components matching full search model
                        // 1) Movement cost (weighted if enabled)
                        float moveCost = baseCost;
                        float weightedMoveCost = moveCost;
                        if (s_enableMovementWeighting)
                        {
                            weightedMoveCost *= s_movementWeightInnerVoices;
                        }
                        
                        // 2) Compactness cost (only if we have both voices or can compute gap)
                        float compactnessCost = 0f;
                        if (isSelectingTenor)
                        {
                            int gapTB = candidate - bassVoice;
                            compactnessCost = gapTB * compactnessWeightTenorBass;
                        }
                        else if (isSelectingAlto && knownTenor >= 0)
                        {
                            int gapAT = candidate - knownTenor;
                            compactnessCost = gapAT * compactnessWeightAltoTenor;
                        }
                        
                        // 3) Register gravity penalty
                        float registerPenalty = 0f;
                        if (s_enableRegisterGravity)
                        {
                            if (isSelectingTenor)
                            {
                                float tenorDist = Math.Abs(candidate - s_tenorRegisterCenter);
                                registerPenalty += tenorDist * s_tenorRegisterWeight;
                            }
                            else if (isSelectingAlto)
                            {
                                float altoDist = Math.Abs(candidate - s_altoRegisterCenter);
                                registerPenalty += altoDist * s_altoRegisterWeight;
                            }
                        }
                        
                        // 4) Compression penalty (only when selecting alto, since we need both voices)
                        float compressionPenalty = 0f;
                        if (s_enableCompressionCost && isSelectingAlto && knownTenor >= 0)
                        {
                            int gapAT = candidate - knownTenor;
                            if (gapAT > s_targetAltoTenorGap)
                            {
                                compressionPenalty += (gapAT - s_targetAltoTenorGap) * s_compressionWeightAT;
                            }
                            if (hasSoprano)
                            {
                                int gapSA = knownSoprano - candidate;
                                if (gapSA > s_targetSopAltoGap)
                                {
                                    compressionPenalty += (gapSA - s_targetSopAltoGap) * s_compressionWeightSA;
                                }
                            }
                        }
                        
                        // 5) 11th tension heuristics (soprano-only, v1) - only when selecting alto (we have both voices)
                        float eleventhTensionAdjustment = 0f;
                        if (s_enableEleventhHeuristics && isSelectingAlto && hasSoprano)
                        {
                            // Build current SATB array for helper
                            var currentChordTonePcs = GetChordTonePitchClasses(current);
                            eleventhTensionAdjustment = ComputeEleventhTensionCostAdjustment(
                                current, knownSoprano, bassVoice, knownTenor, candidate, currentChordTonePcs);
                        }
                        
                        // Add-tone bonus (optional color tones - reward inclusion, no penalty for omission)
                        float addToneBonus = ComputeAddToneBonus(
                            current, null, 
                            isSelectingTenor ? candidate : (int?)knownTenor,
                            isSelectingAlto ? candidate : null,
                            candidate,
                            isSelectingTenor, isSelectingAlto, false); // Soprano selection happens later in this path
                        
                        // Total cost matching full search model
                        float totalCost = weightedMoveCost + compactnessCost + tendAdjust + registerPenalty + compressionPenalty + eleventhTensionAdjustment + addToneBonus;
                        
                        // Check spacing constraints based on which voice we're selecting
                        bool spacingOK = true;
                        if (isSelectingTenor)
                        {
                            // Tenor spacing: Tenor - Bass ≤ MaxTenorBassInterval
                            int gapTB = candidate - bassVoice;
                            spacingOK = gapTB <= MaxTenorBassInterval;
                        }
                        else if (isSelectingAlto)
                        {
                            // Alto spacing: Alto - Tenor ≤ MaxAltoTenorInterval
                            int gapAT = candidate - knownTenor;
                            spacingOK = gapAT <= MaxAltoTenorInterval;
                            
                            // Also check Soprano - Alto if soprano is known
                            if (hasSoprano && spacingOK)
                            {
                                int gapSA = knownSoprano - candidate;
                                spacingOK = gapSA <= MaxSopranoAltoInterval;
                            }
                        }
                        
                        // Track best candidate with spacing constraint
                        if (spacingOK)
                        {
                            if (totalCost < bestCostWithSpacing)
                            {
                                bestCostWithSpacing = totalCost;
                                bestMidiWithSpacing = candidate;
                                
                                // DIAGNOSTIC: Log when bestMidiWithSpacing is set for Alto
                                if (isSelectingAlto && stepIndex == 2)
                                {
                                    int tenorMidi = upperVoices.Count > 0 ? upperVoices[0] : -1;
                                    string candName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                    string tenorName = tenorMidi >= 0 ? TheoryPitch.GetPitchNameFromMidi(tenorMidi, current.Key) : "N/A";
                                    UnityEngine.Debug.Log(
                                        $"[SATB_NO_CROSSING_DIAG] Alto bestMidiWithSpacing SET: " +
                                        $"candidate={candidate}({candName}) cost={totalCost:F2} " +
                                        $"Tenor={tenorMidi}({tenorName})");
                                }
                            }
                        }
                        
                        // Always track best overall candidate for fallback
                        if (totalCost < bestCostNoSpacing)
                        {
                            bestCostNoSpacing = totalCost;
                            bestMidiNoSpacing = candidate;
                            
                            // DIAGNOSTIC: Log when bestMidiNoSpacing is set for Alto (gated)
                            if (s_enableSatbNoCrossingDebug && isSelectingAlto && stepIndex == 2)
                            {
                                int tenorMidi = upperVoices.Count > 0 ? upperVoices[0] : -1;
                                string candName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                string tenorName = tenorMidi >= 0 ? TheoryPitch.GetPitchNameFromMidi(tenorMidi, current.Key) : "N/A";
                                UnityEngine.Debug.Log(
                                    $"[SATB_NO_CROSSING_DIAG] Alto bestMidiNoSpacing SET: " +
                                    $"candidate={candidate}({candName}) cost={totalCost:F2} " +
                                    $"Tenor={tenorMidi}({tenorName})");
                            }
                        }
                        
                        // Keep old logic for backward compatibility during transition
                        if (totalCost < bestCost)
                        {
                            bestNote = candidate;
                            bestCost = totalCost;
                            chosenBaseCost = baseCost;
                            chosenTendAdjust = tendAdjust;
                        }
                    }
                }
                
                // Choose best candidate: prefer spacing-constrained if available, otherwise fallback
                int chosenNote = -1;
                float finalCost = float.MaxValue;
                float finalBaseCost = 0f;
                float finalTendAdjust = 0f;
                
                if (bestMidiWithSpacing >= 0)
                {
                    // At least one candidate satisfied spacing – use it
                    chosenNote = bestMidiWithSpacing;
                    finalCost = bestCostWithSpacing;
                    // Recompute base cost and tendency adjust for chosen note (for logging)
                    finalBaseCost = Math.Abs(chosenNote - prevVoice);
                    finalTendAdjust = ComputeTendencyCostAdjustment(
                        tendencyInfo, chosenNote, current.Key,
                        previousEvent.Recipe, current.Recipe,
                        previousAnalysis, currentAnalysis,
                        isSoprano: false, nextMelodyMidi: current.MelodyMidi,
                        voiceMinMidi: upperMinMidi, voiceMaxMidi: Math.Min(upperMaxMidi, melodyMidi - 1));
                }
                else if (bestMidiNoSpacing >= 0)
                {
                    // Fallback: no candidate fit spacing, use best overall and log
                    chosenNote = bestMidiNoSpacing;
                    finalCost = bestCostNoSpacing;
                    // Recompute base cost and tendency adjust for chosen note (for logging)
                    finalBaseCost = Math.Abs(chosenNote - prevVoice);
                    finalTendAdjust = ComputeTendencyCostAdjustment(
                        tendencyInfo, chosenNote, current.Key,
                        previousEvent.Recipe, current.Recipe,
                        previousAnalysis, currentAnalysis,
                        isSoprano: false, nextMelodyMidi: current.MelodyMidi,
                        voiceMinMidi: upperMinMidi, voiceMaxMidi: Math.Min(upperMaxMidi, melodyMidi - 1));
                    
                    if (GetTendencyDebug())
                    {
                        if (isSelectingTenor)
                        {
                            UnityEngine.Debug.LogWarning(
                                $"[Spacing Relax Tenor] No tenor candidate satisfied spacing; using best overall: " +
                                $"Bass={bassVoice}, Tenor={chosenNote}");
                        }
                        else if (isSelectingAlto)
                        {
                            UnityEngine.Debug.LogWarning(
                                $"[Spacing Relax Alto] No alto candidate satisfied spacing; using best overall: " +
                                $"B={bassVoice}, T={knownTenor}, A={chosenNote}, S={(hasSoprano ? knownSoprano : -1)}");
                        }
                    }
                }
                else if (bestNote >= 0)
                {
                    // Fallback to old logic if spacing tracking didn't find anything
                    chosenNote = bestNote;
                    finalCost = bestCost;
                    finalBaseCost = chosenBaseCost;
                    finalTendAdjust = chosenTendAdjust;
                }
                
                if (chosenNote >= 0)
                {
                    // DIAGNOSTIC: Log chosenNote value and source for Alto selection (gated)
                    if (s_enableSatbNoCrossingDebug && isSelectingAlto && stepIndex == 2)
                    {
                        string source = "UNKNOWN";
                        if (bestMidiWithSpacing >= 0 && chosenNote == bestMidiWithSpacing)
                            source = "bestMidiWithSpacing";
                        else if (bestMidiNoSpacing >= 0 && chosenNote == bestMidiNoSpacing)
                            source = "bestMidiNoSpacing";
                        else if (bestNote >= 0 && chosenNote == bestNote)
                            source = "bestNote";
                        
                        int tenorMidi = upperVoices.Count > 0 ? upperVoices[0] : -1;
                        string chosenName = TheoryPitch.GetPitchNameFromMidi(chosenNote, current.Key);
                        string tenorName = tenorMidi >= 0 ? TheoryPitch.GetPitchNameFromMidi(tenorMidi, current.Key) : "N/A";
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] Alto chosenNote BEFORE safeguard: " +
                            $"chosenNote={chosenNote}({chosenName}) source={source} " +
                            $"Tenor={tenorMidi}({tenorName}) " +
                            $"bestMidiWithSpacing={bestMidiWithSpacing} bestMidiNoSpacing={bestMidiNoSpacing} bestNote={bestNote}");
                    }
                    
                    // CRITICAL: Verify Alto >= Tenor after selection (hard no-crossing check)
                    // This is a final safeguard in case something overrode the filter
                    if (isSelectingAlto && upperVoices.Count > 0)
                    {
                        int tenorMidi = upperVoices[0];
                        if (chosenNote < tenorMidi)
                        {
                            // This should never happen if the filter worked correctly
                            UnityEngine.Debug.LogError(
                                $"[SATB_NO_CROSSING_ERROR] CRITICAL: Alto candidate {chosenNote} was chosen but is < Tenor {tenorMidi}! " +
                                $"This indicates the hard filter failed or was bypassed. " +
                                $"Chord: {TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe)} at stepIndex={stepIndex}");
                            
                            // Force fallback: find nearest chord tone >= Tenor
                            var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                            int fallbackAlto = -1;
                            int fallbackDistance = int.MaxValue;
                            
                            foreach (int pc in chordTonePcsSet)
                            {
                                int baseOctave = tenorMidi / 12;
                                for (int octaveOffset = 0; octaveOffset <= 2; octaveOffset++)
                                {
                                    int candidateMidi = (baseOctave + octaveOffset) * 12 + pc;
                                    if (candidateMidi >= tenorMidi && 
                                        candidateMidi >= upperMinMidi && candidateMidi <= upperMaxMidi &&
                                        (targetSopranoMidi <= 0 || candidateMidi <= targetSopranoMidi))
                                    {
                                        int distance = Math.Abs(candidateMidi - chosenNote);
                                        if (distance < fallbackDistance)
                                        {
                                            fallbackAlto = candidateMidi;
                                            fallbackDistance = distance;
                                        }
                                    }
                                }
                            }
                            
                            if (fallbackAlto >= 0)
                            {
                                UnityEngine.Debug.LogWarning(
                                    $"[SATB_NO_CROSSING] Forced fallback: Alto {chosenNote} -> {fallbackAlto} to satisfy Alto >= Tenor constraint");
                                chosenNote = fallbackAlto;
                            }
                            else
                            {
                                UnityEngine.Debug.LogError(
                                    $"[SATB_NO_CROSSING] CRITICAL: Cannot find fallback Alto >= Tenor {tenorMidi}. " +
                                    $"This will cause voice crossing!");
                            }
                        }
                    }
                    
                    // AUG5_DBG Log: chosen vs preferred for aug5 resolution
                    if (s_enableAug5Debug && isAug5Voice && targetResolutionPc >= 0)
                    {
                        int chosenPcForAug5 = (chosenNote % 12 + 12) % 12;
                        string[] satbLanes = { "Tenor", "Alto" };
                        string satbLane = (voiceIdx < satbLanes.Length) ? satbLanes[voiceIdx] : $"Voice{voiceIdx}";
                        string prevName = TheoryPitch.GetPitchNameFromMidi(prevAug5Midi, previousEvent.Key);
                        string chosenName = TheoryPitch.GetPitchNameFromMidi(chosenNote, current.Key);
                        string roman = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        
                        // Find preferred candidate (target resolution)
                        int preferredMidi = -1;
                        foreach (int cand in voiceCandidates)
                        {
                            int candPc = (cand % 12 + 12) % 12;
                            if (candPc == targetResolutionPc)
                            {
                                preferredMidi = cand;
                                break;
                            }
                        }
                        
                        string preferredInfo = preferredMidi >= 0 ? $"{preferredMidi}({TheoryPitch.GetPitchNameFromMidi(preferredMidi, current.Key)})" : "NONE";
                        string chosenReason = (chosenPcForAug5 == targetResolutionPc) ? "correctResolution" : $"totalCostLower (cost={finalCost:F2})";
                        
                        UnityEngine.Debug.Log(
                            $"[AUG5_DBG] resolveStep nextChordIndex={stepIndex} roman={roman} lane={satbLane} prev={prevAug5Midi}({prevName}) targetPc={targetResolutionPc}(A) preferredMidi={preferredInfo} chosenMidi={chosenNote}({chosenName}) chosenReason={chosenReason}");
                    }
                    
                    // Debug logging for tendency cases
                    LogTendencyDebugInfo(
                        stepIndex: stepIndex,
                        voiceIndex: voiceIdx + 1,
                        tendencyInfo,
                        prevVoice,
                        chosenNote,
                        current.Key,
                        current.Recipe,
                        currentAnalysis,
                        finalBaseCost,
                        finalTendAdjust,
                        finalCost);
                    
                    // Store mapping: previous voice index -> selected MIDI (for 7th resolution enforcement)
                    if (!voiceSelectionMap.ContainsKey(voiceIdx))
                    {
                        voiceSelectionMap[voiceIdx] = chosenNote;
                    }
                    
                    // DIAGNOSTIC: Log chosenNote value immediately before adding to upperVoices (gated)
                    if (s_enableSatbNoCrossingDebug && isSelectingAlto && stepIndex == 2)
                    {
                        int tenorMidi = upperVoices.Count > 0 ? upperVoices[0] : -1;
                        string chosenName = TheoryPitch.GetPitchNameFromMidi(chosenNote, current.Key);
                        string tenorName = tenorMidi >= 0 ? TheoryPitch.GetPitchNameFromMidi(tenorMidi, current.Key) : "N/A";
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] Alto chosenNote BEFORE upperVoices.Add(): " +
                            $"chosenNote={chosenNote}({chosenName}) " +
                            $"Tenor={tenorMidi}({tenorName}) " +
                            $"upperVoices.Count={upperVoices.Count}");
                    }
                    
                    upperVoices.Add(chosenNote);
                    // CRITICAL FIX: Allow unison doubling for inner voices
                    // If Alto is selecting the same note as Tenor (unison), don't add to usedCandidates
                    // This allows both Tenor and Alto to have the same MIDI note
                    bool isAltoUnison = (isSelectingAlto && upperVoices.Count == 2 && upperVoices[0] == chosenNote);
                    if (!isAltoUnison)
                    {
                        usedCandidates.Add(chosenNote);
                    }
                    else if (s_enableSatbNoCrossingDebug && stepIndex == 2)
                    {
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] Allowing unison doubling: Alto={chosenNote} same as Tenor={upperVoices[0]}");
                    }
                    
                    // CRITICAL DIAGNOSTIC: Log what was actually added to upperVoices for Alto (gated)
                    if (s_enableSatbNoCrossingDebug && isSelectingAlto && stepIndex == 2)
                    {
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] AFTER upperVoices.Add() for Alto: " +
                            $"chosenNote={chosenNote} upperVoices.Count={upperVoices.Count} " +
                            $"upperVoices=[{string.Join(",", upperVoices.Select(m => $"{m}({TheoryPitch.GetPitchNameFromMidi(m, current.Key)})"))}]");
                    }
                    
                    // LANE_MAP_DBG: Log lane assignment (gated)
                    if (s_enableAug5Debug)
                    {
                        string chosenNameForLane = TheoryPitch.GetPitchNameFromMidi(chosenNote, current.Key);
                        UnityEngine.Debug.Log(
                            $"[LANE_MAP_DBG] fillingLane={fillingLane} upperVoicesAddIndex={upperVoicesAddIndex} chosen={chosenNote}({chosenNameForLane})");
                    }
                    
                    // AUG5_SNAP: Log state immediately after voice selection (gated)
                    if (s_enableAug5Debug && stepIndex == 2) // chord IV in repro (C=0, Caug=1, F=2)
                    {
                        string roman = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        if (roman == "F" || roman == "IV")
                        {
                            // Build temporary SATB array to log
                            var tempAllVoices = new List<int> { bassVoice };
                            tempAllVoices.AddRange(upperVoices);
                            if (tempAllVoices.Count >= 4)
                            {
                                string bassName = TheoryPitch.GetPitchNameFromMidi(tempAllVoices[0], current.Key);
                                string tenorName = TheoryPitch.GetPitchNameFromMidi(tempAllVoices[1], current.Key);
                                string altoName = tempAllVoices.Count > 2 ? TheoryPitch.GetPitchNameFromMidi(tempAllVoices[2], current.Key) : "N/A";
                                string sopranoName = tempAllVoices.Count > 3 ? TheoryPitch.GetPitchNameFromMidi(tempAllVoices[3], current.Key) : "N/A";
                                UnityEngine.Debug.Log(
                                    $"[AUG5_SNAP] stage=AfterVoiceSelection chordIndex={stepIndex} roman={roman} SATB=[Bass={tempAllVoices[0]}({bassName}), Tenor={tempAllVoices[1]}({tenorName}), Alto={tempAllVoices[2]}({altoName}), Soprano={tempAllVoices[3]}({sopranoName})]");
                            }
                        }
                    }
                    
                    // Update tension tracking: if chosen note is a tension, mark it as chosen
                    int chosenPc = (chosenNote % 12 + 12) % 12;
                    if (tensionPcSetForIncremental.Contains(chosenPc))
                    {
                        tensionPcsAlreadyChosen.Add(chosenPc);
                    }
                    
                    remainingVoices--;
                }
            }
            
            // Fill any remaining slots with available chord tones below melody
            // CRITICAL: This fallback must respect the no-crossing constraint for Alto
            while (remainingVoices > 0 && candidates.Count > 0)
            {
                // DIAGNOSTIC: Log fallback loop entry (gated)
                if (s_enableSatbNoCrossingDebug && stepIndex == 2)
                {
                    UnityEngine.Debug.Log(
                        $"[SATB_NO_CROSSING_DIAG] Fallback loop ENTRY: " +
                        $"remainingVoices={remainingVoices} upperVoices.Count={upperVoices.Count} " +
                        $"upperVoices=[{string.Join(",", upperVoices.Select(m => $"{m}({TheoryPitch.GetPitchNameFromMidi(m, current.Key)})"))}] " +
                        $"candidates.Count={candidates.Count}");
                }
                
                int bestCandidate = -1;
                
                // For Alto selection, filter candidates to respect no-crossing (Alto >= Tenor)
                List<int> candidatesToCheck = candidates;
                if (upperVoices.Count == 1) // Alto is being selected (Tenor already chosen)
                {
                    int tenorMidi = upperVoices[0];
                    var filteredCandidates = new List<int>();
                    foreach (int candidate in candidates)
                    {
                        if (candidate >= tenorMidi) // Allow unison
                        {
                            filteredCandidates.Add(candidate);
                        }
                    }
                    
                    if (filteredCandidates.Count > 0)
                    {
                        candidatesToCheck = filteredCandidates;
                        if (s_enableSatbNoCrossingDebug && stepIndex == 2)
                        {
                            UnityEngine.Debug.Log(
                                $"[SATB_NO_CROSSING] Fallback loop: Filtered candidates for Alto " +
                                $"(Tenor={tenorMidi}): [{string.Join(",", filteredCandidates)}]");
                        }
                    }
                    else
                    {
                        // No valid candidates after filtering - try octave-shifted chord tones
                        var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                        foreach (int pc in chordTonePcsSet)
                        {
                            int baseOctave = tenorMidi / 12;
                            for (int octaveOffset = 0; octaveOffset <= 2; octaveOffset++)
                            {
                                int candidateMidi = (baseOctave + octaveOffset) * 12 + pc;
                                if (candidateMidi >= tenorMidi && 
                                    candidateMidi >= upperMinMidi && candidateMidi <= upperMaxMidi &&
                                    candidateMidi < melodyMidi &&
                                    !usedCandidates.Contains(candidateMidi))
                                {
                                    filteredCandidates.Add(candidateMidi);
                                }
                            }
                        }
                        if (filteredCandidates.Count > 0)
                        {
                            candidatesToCheck = filteredCandidates;
                        }
                    }
                }
                
                foreach (int candidate in candidatesToCheck)
                {
                    // DIAGNOSTIC: Log each candidate being checked (gated)
                    if (s_enableSatbNoCrossingDebug && stepIndex == 2 && upperVoices.Count == 1)
                    {
                        bool inUsed = usedCandidates.Contains(candidate);
                        bool belowMelody = candidate < melodyMidi;
                        string candName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] Fallback loop checking candidate: " +
                            $"candidate={candidate}({candName}) belowMelody={belowMelody} " +
                            $"inUsedCandidates={inUsed} melodyMidi={melodyMidi}");
                    }
                    
                    // CRITICAL FIX: Allow unison doubling for inner voices (Tenor/Alto)
                    // If this is Alto selection (upperVoices.Count == 1) and candidate is already used by Tenor,
                    // allow it for unison doubling (inner voices can double the same note)
                    bool isAltoSelection = (upperVoices.Count == 1);
                    bool isUnisonWithTenor = isAltoSelection && usedCandidates.Contains(candidate) && upperVoices.Count > 0 && upperVoices[0] == candidate;
                    bool canUseCandidate = candidate < melodyMidi && (!usedCandidates.Contains(candidate) || isUnisonWithTenor);
                    
                    if (canUseCandidate)
                    {
                        bestCandidate = candidate;
                        if (s_enableSatbNoCrossingDebug && isUnisonWithTenor && stepIndex == 2)
                        {
                            UnityEngine.Debug.Log(
                                $"[SATB_NO_CROSSING_DIAG] Fallback loop: Allowing unison doubling for Alto: " +
                                $"candidate={candidate} (same as Tenor)");
                        }
                        break;
                    }
                }
                
                // DIAGNOSTIC: Log if no candidate was found (gated)
                if (s_enableSatbNoCrossingDebug && bestCandidate < 0 && stepIndex == 2 && upperVoices.Count == 1)
                {
                    UnityEngine.Debug.LogWarning(
                        $"[SATB_NO_CROSSING_DIAG] Fallback loop: No valid candidate found! " +
                        $"candidatesToCheck.Count={candidatesToCheck.Count} " +
                        $"candidatesToCheck=[{string.Join(",", candidatesToCheck.Select(c => $"{c}({TheoryPitch.GetPitchNameFromMidi(c, current.Key)})"))}] " +
                        $"melodyMidi={melodyMidi} " +
                        $"usedCandidates=[{string.Join(",", usedCandidates)}]");
                }
                
                if (bestCandidate >= 0)
                {
                    // DIAGNOSTIC: Log what's being added in fallback loop (gated)
                    if (s_enableSatbNoCrossingDebug && stepIndex == 2)
                    {
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] Fallback loop BEFORE Add: " +
                            $"bestCandidate={bestCandidate} upperVoices.Count={upperVoices.Count} " +
                            $"remainingVoices={remainingVoices}");
                    }
                    
                    upperVoices.Add(bestCandidate);
                    // CRITICAL FIX: Allow unison doubling for inner voices in fallback loop
                    // If Alto is selecting the same note as Tenor (unison), don't add to usedCandidates
                    bool isAltoUnisonFallback = (upperVoices.Count == 2 && upperVoices[0] == bestCandidate);
                    if (!isAltoUnisonFallback)
                    {
                        usedCandidates.Add(bestCandidate);
                    }
                    else if (s_enableSatbNoCrossingDebug && stepIndex == 2)
                    {
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] Fallback loop: Allowing unison doubling: Alto={bestCandidate} same as Tenor={upperVoices[0]}");
                    }
                    candidates.Remove(bestCandidate);
                    remainingVoices--;
                    
                    // DIAGNOSTIC: Log what was actually added (gated)
                    if (s_enableSatbNoCrossingDebug && stepIndex == 2)
                    {
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] Fallback loop AFTER Add: " +
                            $"bestCandidate={bestCandidate} upperVoices.Count={upperVoices.Count} " +
                            $"upperVoices=[{string.Join(",", upperVoices.Select(m => $"{m}({TheoryPitch.GetPitchNameFromMidi(m, current.Key)})"))}] " +
                            $"remainingVoices={remainingVoices}");
                    }
                    
                    // Log for Alto selection (gated)
                    if (s_enableSatbNoCrossingDebug && upperVoices.Count == 2 && stepIndex == 2)
                    {
                        int tenorMidi = upperVoices[0];
                        string bestName = TheoryPitch.GetPitchNameFromMidi(bestCandidate, current.Key);
                        string tenorName = TheoryPitch.GetPitchNameFromMidi(tenorMidi, current.Key);
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING_DIAG] Fallback loop added Alto: " +
                            $"bestCandidate={bestCandidate}({bestName}) Tenor={tenorMidi}({tenorName})");
                    }
                }
                else
                {
                    // Fallback: use PlaceInMidRegister for remaining pitch classes
                    if (availablePcs.Count > 0)
                    {
                        int fallbackPc = availablePcs[0];
                        availablePcs.RemoveAt(0);
                        int fallbackMidi = PlaceInMidRegister(fallbackPc, upperMinMidi, Math.Min(upperMaxMidi, melodyMidi - 1));
                        
                        // CRITICAL: For Alto, ensure fallback respects no-crossing constraint
                        if (upperVoices.Count == 1 && fallbackMidi < upperVoices[0])
                        {
                            // Try octave-shifting upward
                            int tenorMidi = upperVoices[0];
                            int baseOctave = (tenorMidi / 12) + 1;
                            int adjustedMidi = baseOctave * 12 + fallbackPc;
                            
                            if (adjustedMidi >= tenorMidi && 
                                adjustedMidi >= upperMinMidi && adjustedMidi <= upperMaxMidi &&
                                adjustedMidi < melodyMidi)
                            {
                                fallbackMidi = adjustedMidi;
                                if (stepIndex == 2)
                                {
                                    UnityEngine.Debug.Log(
                                        $"[SATB_NO_CROSSING] Fallback PlaceInMidRegister adjusted for Alto: " +
                                        $"{PlaceInMidRegister(fallbackPc, upperMinMidi, Math.Min(upperMaxMidi, melodyMidi - 1))} -> {fallbackMidi} " +
                                        $"(Tenor={tenorMidi})");
                                }
                            }
                            else
                            {
                                // Adjustment failed - try other pitch classes or octaves
                                var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                                int bestFallbackMidi = -1;
                                
                                foreach (int pc in chordTonePcsSet)
                                {
                                    int testOctave = (tenorMidi / 12);
                                    for (int octaveOffset = 0; octaveOffset <= 2; octaveOffset++)
                                    {
                                        int testMidi = (testOctave + octaveOffset) * 12 + pc;
                                        if (testMidi >= tenorMidi && 
                                            testMidi >= upperMinMidi && testMidi <= upperMaxMidi &&
                                            testMidi < melodyMidi &&
                                            !usedCandidates.Contains(testMidi))
                                        {
                                            bestFallbackMidi = testMidi;
                                            break;
                                        }
                                    }
                                    if (bestFallbackMidi >= 0) break;
                                }
                                
                                if (bestFallbackMidi >= 0)
                                {
                                    fallbackMidi = bestFallbackMidi;
                                    if (stepIndex == 2)
                                    {
                                        UnityEngine.Debug.Log(
                                            $"[SATB_NO_CROSSING] Fallback PlaceInMidRegister found alternative: " +
                                            $"{PlaceInMidRegister(fallbackPc, upperMinMidi, Math.Min(upperMaxMidi, melodyMidi - 1))} -> {fallbackMidi} " +
                                            $"(Tenor={tenorMidi})");
                                    }
                                }
                                else
                                {
                                    // Cannot find valid fallback - reject this one
                                    if (stepIndex == 2)
                                    {
                                        UnityEngine.Debug.LogError(
                                            $"[SATB_NO_CROSSING] CRITICAL: PlaceInMidRegister fallback would place Alto={fallbackMidi} < Tenor={tenorMidi} " +
                                            $"and cannot be adjusted. Skipping this fallback.");
                                    }
                                    continue; // Skip to next iteration (will try next availablePc)
                                }
                            }
                        }
                        
                        // Final check: don't add if it still violates no-crossing
                        if (upperVoices.Count == 1 && fallbackMidi < upperVoices[0])
                        {
                            if (stepIndex == 2)
                            {
                                UnityEngine.Debug.LogError(
                                    $"[SATB_NO_CROSSING] CRITICAL: PlaceInMidRegister fallback Alto={fallbackMidi} < Tenor={upperVoices[0]}. " +
                                    $"Rejecting this fallback.");
                            }
                            continue; // Skip this fallback, try next availablePc
                        }
                        
                        if (fallbackMidi < melodyMidi && !usedCandidates.Contains(fallbackMidi))
                        {
                            // DIAGNOSTIC: Log PlaceInMidRegister fallback
                            if (stepIndex == 2 && upperVoices.Count == 1)
                            {
                                UnityEngine.Debug.Log(
                                    $"[SATB_NO_CROSSING_DIAG] PlaceInMidRegister fallback adding: " +
                                    $"fallbackMidi={fallbackMidi} upperVoices.Count={upperVoices.Count}");
                            }
                            
                            upperVoices.Add(fallbackMidi);
                            usedCandidates.Add(fallbackMidi);
                            remainingVoices--;
                        }
                    }
                    else
                    {
                        break; // No more options
                    }
                }
            }
        }

        /// <summary>
        /// Voices the next chord in a progression with voice-leading from the previous chord.
        /// Tier 1 heuristic: keeps common tones in same voices when possible,
        /// otherwise moves each voice to the nearest chord tone.
        /// Applies soft tonal tendency rules for more classical voice-leading.
        /// </summary>
        /// <param name="previous">The previously voiced chord</param>
        /// <param name="previousEvent">The previous chord event (for tendency analysis)</param>
        /// <param name="current">The current chord event to voice</param>
        /// <param name="numVoices">Number of voices (3 or 4)</param>
        /// <param name="bassOctave">Octave for bass voice fallback</param>
        /// <param name="upperMinMidi">Minimum MIDI for upper voices</param>
        /// <param name="upperMaxMidi">Maximum MIDI for upper voices</param>
        /// <returns>VoicedChord for the current event with voice-leading</returns>
        private static VoicedChord VoiceNextChord(
            VoicedChord previous,
            ChordEvent previousEvent,
            ChordEvent current,
            int numVoices,
            int bassOctave,
            int upperMinMidi,
            int upperMaxMidi,
            int stepIndex = -1,
            DiagnosticsCollector diags = null,
            string regionDebugLabel = null)
        {
            // Trace: Log parsed extensions (point 1) - only for Play path (no melody)
            if (s_debugTensionDetect && stepIndex >= 0 && !current.MelodyMidi.HasValue)
            {
                var req = current.Recipe.RequestedExtensions;
                if (req.HasAny)
                {
                    int rootPc = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                    if (rootPc < 0) rootPc = 0;
                    rootPc = (rootPc + current.Recipe.RootSemitoneOffset + 12) % 12;
                    if (rootPc < 0) rootPc += 12;
                    
                    var requestedList = new List<string>();
                    var computedPcs = new Dictionary<string, int>();
                    if (req.Tension9) { requestedList.Add("9"); computedPcs["9"] = (rootPc + 2) % 12; }
                    if (req.TensionFlat9) { requestedList.Add("b9"); computedPcs["b9"] = (rootPc + 1) % 12; }
                    if (req.TensionSharp11) { requestedList.Add("#11"); computedPcs["#11"] = (rootPc + 6) % 12; }
                    if (req.Add9) { requestedList.Add("add9"); computedPcs["add9"] = (rootPc + 2) % 12; }
                    if (req.Add11) { requestedList.Add("add11"); computedPcs["add11"] = (rootPc + 5) % 12; }
                    if (req.Sus4) { requestedList.Add("sus4"); }
                    
                    string token = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                    string quality = current.Recipe.Quality.ToString();
                    string requestedStr = requestedList.Count > 0 ? string.Join(",", requestedList) : "none";
                    string computedStr = string.Join(" ", computedPcs.Select(kvp => $"{kvp.Key}:{kvp.Value}"));
                    
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_TRACE][PARSE] step={stepIndex} token={token} rootPc={rootPc} quality={quality}\n" +
                        $"  requested=[{requestedStr}]\n" +
                        $"  computedPcs={{ {computedStr} }}");
                }
            }
            
            // Debug: Log voicing path and effective weights (chord-only path)
            if (enableVoicingPathDebug && stepIndex >= 0)
            {
                UnityEngine.Debug.Log(
                    $"[VOICING PATH] VOICE_NEXT_CHORD (incremental) [stepIndex={stepIndex}]\n" +
                    $"  7th Resolution: bonus={seventhResolutionDownStepBonusNormal:F3}, avoidPenalty={seventhResolutionAvoidPenaltyNormal:F3}"
                );
            }
            
            // Debug: Log playback mode and soprano selection status
            bool hasMelody = current.MelodyMidi.HasValue;
            string playbackMode = hasMelody ? "SATB/NH" : "Play";
            string sopranoStatus = hasMelody ? "fixed" : "selected";
            string sopranoSelector = hasMelody ? "melody-constrained" : "no-melody path";
            
            if (s_debugTensionDetect && stepIndex >= 0)
            {
                if (s_debugTensionVerbose)
                {
                    string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_DEBUG] step={stepIndex} mode={playbackMode} soprano={sopranoStatus} " +
                        $"selector={sopranoSelector} placementPolicy={s_extensionPlacementMode} " +
                        $"label={label}");
                }
            }
            
            // Clamp numVoices to valid range [3, 4]
            if (numVoices < 3) numVoices = 3;
            if (numVoices > 4) numVoices = 4;

            // Get chord analyses for tendency rules (gracefully degrade if unavailable)
            ChordFunctionProfile previousAnalysis;
            ChordFunctionProfile currentAnalysis;
            try
            {
                previousAnalysis = TheoryChord.AnalyzeChordProfile(previousEvent.Key, previousEvent.Recipe);
                currentAnalysis = TheoryChord.AnalyzeChordProfile(current.Key, current.Recipe);
            }
            catch
            {
                // Fallback: create empty profiles if analysis fails
                previousAnalysis = new ChordFunctionProfile();
                currentAnalysis = new ChordFunctionProfile();
            }

            // Get target chord tone pitch classes for the current chord
            var chordTonePcs = GetChordTonePitchClasses(current);
            if (chordTonePcs.Count == 0)
            {
                // Fallback: use VoiceFirstChord if we can't get chord tones
                return VoiceFirstChord(current, numVoices, bassOctave, upperMinMidi, upperMaxMidi);
            }

            // Voice bass (index 0): use cost-based selection with root position preference
            int prevBass = previous.VoicesMidi[0];
            
            // Debug logging for recipe inversion
            if (enableTendencyDebug)
            {
                UnityEngine.Debug.Log($"[Voicing Debug] Step {stepIndex}: recipe inversion = {current.Recipe.Inversion}");
            }
            
            // Voice upper voices (indices 1..N-1)
            var prevUpper = new List<int>();
            for (int i = 1; i < previous.VoicesMidi.Length; i++)
            {
                prevUpper.Add(previous.VoicesMidi[i]);
            }
            
            // DIAGNOSTIC: Log previous voicing used for step 1 (when resolving from step 0)
            if (stepIndex == 1 && previousEvent.Recipe.RequestedExtensions.HasAny)
            {
                var req = previousEvent.Recipe.RequestedExtensions;
                int prevRootPc = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                if (prevRootPc < 0) prevRootPc = 0;
                prevRootPc = (prevRootPc + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                if (prevRootPc < 0) prevRootPc += 12;
                int requiredB9Pc = req.TensionFlat9 ? (prevRootPc + 1) % 12 : -1;
                
                var prevPcs = new List<int>();
                for (int i = 0; i < previous.VoicesMidi.Length; i++)
                {
                    prevPcs.Add((previous.VoicesMidi[i] % 12 + 12) % 12);
                }
                bool b9Present = requiredB9Pc >= 0 && prevPcs.Contains(requiredB9Pc);
                
                UnityEngine.Debug.Log(
                    $"[STEP1_DIAG] === VoiceNextChord step=1: Previous voicing from step 0 ===\n" +
                    $"  previous.VoicesMidi (BTAS): [{string.Join(", ", previous.VoicesMidi)}]\n" +
                    $"  prevUpper (T,A,S): [{string.Join(", ", prevUpper)}]\n" +
                    $"  pitch classes: [{string.Join(", ", prevPcs)}]\n" +
                    $"  requiredB9Pc={requiredB9Pc}, b9Present={b9Present}\n" +
                    $"  previousEvent: {TheoryChord.RecipeToRomanNumeral(previousEvent.Key, previousEvent.Recipe)}\n" +
                    $"  currentEvent: {TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe)}");
            }

            // Analyze tendencies for each previous voice (for soft voice-leading rules)
            var tendencyInfos = new VoiceTendencyInfo[prevUpper.Count];
            for (int v = 0; v < prevUpper.Count; v++)
            {
                tendencyInfos[v] = AnalyzeVoiceTendencies(
                    prevUpper[v],
                    previousEvent.Key,
                    previousEvent.Recipe,
                    previousAnalysis);
                
                // DIAGNOSTIC: Log tendency info for step 1 (when resolving b9 from step 0)
                if (stepIndex == 1 && previousEvent.Recipe.RequestedExtensions.TensionFlat9)
                {
                    int prevPc = (prevUpper[v] % 12 + 12) % 12;
                    int prevRootPc = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                    if (prevRootPc < 0) prevRootPc = 0;
                    prevRootPc = (prevRootPc + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                    if (prevRootPc < 0) prevRootPc += 12;
                    int b9Pc = (prevRootPc + 1) % 12;
                    
                    if (prevPc == b9Pc)
                    {
                        string voiceName = v == 0 ? "Tenor" : v == 1 ? "Alto" : "Soprano";
                        UnityEngine.Debug.Log(
                            $"[STEP1_DIAG] Voice {v} ({voiceName}) has b9: prevUpper[{v}]={prevUpper[v]}, prevPc={prevPc}, b9Pc={b9Pc}\n" +
                            $"  tendencyInfo.midiNote={tendencyInfos[v].midiNote}, isChordSeventh={tendencyInfos[v].isChordSeventh}");
                    }
                }
            }
            
            // Track which selected MIDI corresponds to which previous voice index (for 7th resolution enforcement)
            // Maps: previous voice index -> selected MIDI (before sorting)
            var voiceSelectionMap = new Dictionary<int, int>();

            int bassVoice = FindBestBassNoteWithInversionPreference(
                prevBass, current.Key, current.Recipe, bassOctave, upperMinMidi, stepIndex);

            // Handle melody constraint if present
            var upperVoices = new List<int>();
            int? targetSopranoMidi = null; // Target soprano MIDI (computed early, locked at end)
            int? melodyPcForLock = null; // Melody pitch class for final verification
            
                if (current.MelodyMidi.HasValue)
                {
                    // CRITICAL: Compute target soprano MIDI early, preserving melody pitch class
                    // The melodyMidi already has any octave offset applied by ChordLabController
                    int melodyMidi = current.MelodyMidi.Value;
                    int melodyPc = (melodyMidi % 12 + 12) % 12;
                    melodyPcForLock = melodyPc;
                    
                    // Get previous soprano (highest voice) to check for common tones
                    int prevSoprano = prevUpper.Count > 0 ? prevUpper[prevUpper.Count - 1] : -1;
                    int prevSopranoPc = prevSoprano >= 0 ? (prevSoprano % 12 + 12) % 12 : -1;
                    
                    // Check if melody pitch class is a common tone with previous soprano
                    bool isCommonTone = (prevSopranoPc >= 0 && melodyPc == prevSopranoPc);
                    
                    // Calculate target soprano MIDI: start with melody MIDI, adjust octave to stay in range
                    int targetSoprano = melodyMidi;
                    
                    // If this is a common tone, prefer the same octave as previous soprano (if in range)
                    if (isCommonTone && prevSoprano >= upperMinMidi && prevSoprano <= upperMaxMidi)
                    {
                        // Use the same octave as previous soprano (preserve common tone)
                        targetSoprano = prevSoprano;
                        
                        if (enableTendencyDebug)
                        {
                            UnityEngine.Debug.Log(
                                $"[Common Tone Debug] Step {stepIndex}: Melody PC {melodyPc} matches previous soprano PC {prevSopranoPc}. " +
                                $"Preserving octave: {targetSoprano} (prev soprano was {prevSoprano})");
                        }
                    }
                    else
                    {
                        // Adjust by octaves so it sits in [upperMinMidi, upperMaxMidi]
                        while (targetSoprano < upperMinMidi) targetSoprano += 12;
                        while (targetSoprano > upperMaxMidi) targetSoprano -= 12;
                        
                        // If it's a common tone but previous octave was out of range, try to get as close as possible
                        if (isCommonTone && prevSoprano >= 0)
                        {
                            // Find the octave of targetSoprano that's closest to prevSoprano
                            int targetOctave = targetSoprano / 12;
                            int prevOctave = prevSoprano / 12;
                            
                            // Try the octave closest to previous soprano (if in range)
                            int candidateOctave = prevOctave;
                            int candidateMidi = candidateOctave * 12 + melodyPc;
                            
                            if (candidateMidi >= upperMinMidi && candidateMidi <= upperMaxMidi)
                            {
                                targetSoprano = candidateMidi;
                                
                                if (enableTendencyDebug)
                                {
                                    UnityEngine.Debug.Log(
                                        $"[Common Tone Debug] Step {stepIndex}: Melody PC {melodyPc} matches previous soprano PC {prevSopranoPc}. " +
                                        $"Using closest octave to previous: {targetSoprano} (prev soprano was {prevSoprano})");
                                }
                            }
                        }
                    }
                    
                    // Verify pitch class is preserved (should always be true, but check anyway)
                    int targetPc = (targetSoprano % 12 + 12) % 12;
                    if (targetPc != melodyPc)
                    {
                        // Force pitch class match by recalculating from melody pitch class
                        int targetOctave = targetSoprano / 12;
                        targetSoprano = targetOctave * 12 + melodyPc;
                        
                        // Re-adjust octave if needed
                        while (targetSoprano < upperMinMidi) targetSoprano += 12;
                        while (targetSoprano > upperMaxMidi) targetSoprano -= 12;
                    }
                    
                    targetSopranoMidi = targetSoprano;
                    
                    // Debug: Log when melody is present but ForceSoprano should still apply constraints
                    if (s_debugTensionDetect && s_extensionPlacementMode == RequestedExtensionPlacementMode.ForceSoprano)
                    {
                        var forcedPcs = GetSopranoCandidatePcsForForceMode(current);
                        if (forcedPcs != null && forcedPcs.Count > 0)
                        {
                            int targetSopranoPc = (targetSoprano % 12 + 12) % 12;
                            bool melodyMatchesForced = forcedPcs.Contains(targetSopranoPc);
                            string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                            string forcedPcsStr = string.Join(",", forcedPcs);
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_PLACE] step={stepIndex} mode=ForceSoprano {label} " +
                                $"melodyPresent=true melodyPC={targetSopranoPc} forcedPCs=[{forcedPcsStr}] " +
                                $"melodyMatchesForced={melodyMatchesForced} " +
                                $"placementPolicyApplied=true (melody-constrained path)");
                        }
                    }
                
                // NEW: full SATB search for Tenor/Alto
                // Use full search if: (1) enabled via dev toggle, or (2) stepIndex == 1 (first chord after initial)
                bool shouldUseFullSearch = s_useFullSearchEveryChord || (stepIndex == 1);
                
                int[] prevUpperArray = prevUpper.ToArray();
                List<int> fullSearchUpper = null;
                Dictionary<int, int> fullSearchSelectionMap = null;
                bool fullSearchOk = false;
                
                if (shouldUseFullSearch)
                {
                    fullSearchOk = TryBuildUpperVoicesWithMelodyFullSearch(
                    previousEvent,
                    current,
                    numVoices,
                    bassVoice,
                    upperMinMidi,
                    upperMaxMidi,
                    prevUpperArray,
                    tendencyInfos,
                    previousAnalysis,
                    currentAnalysis,
                    targetSopranoMidi.Value,
                    chordTonePcs,
                    out fullSearchUpper,
                    out fullSearchSelectionMap,
                        stepIndex,
                        diags);
                }
                
                if (fullSearchOk)
                {
                    // CRITICAL: Apply no-crossing constraint to full search results for SATB+melody mode
                    // The full search doesn't enforce Alto >= Tenor, so we need to fix it here
                    if (fullSearchUpper != null && fullSearchUpper.Count >= 2 && current.MelodyMidi.HasValue)
                    {
                        int tenorMidi = fullSearchUpper[0];
                        int altoMidi = fullSearchUpper[1];
                        
                        // Check if Alto < Tenor (voice crossing)
                        if (altoMidi < tenorMidi)
                        {
                            UnityEngine.Debug.LogWarning(
                                $"[SATB_NO_CROSSING] Full search result violates no-crossing: Alto={altoMidi} < Tenor={tenorMidi} " +
                                $"at stepIndex={stepIndex}. Adjusting Alto to >= Tenor.");
                            
                            // Find nearest chord tone candidate for Alto that is >= Tenor
                            var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                            int adjustedAlto = -1;
                            int minDistance = int.MaxValue;
                            
                            foreach (int pc in chordTonePcsSet)
                            {
                                int baseOctave = tenorMidi / 12;
                                for (int octaveOffset = 0; octaveOffset <= 2; octaveOffset++)
                                {
                                    int candidateMidi = (baseOctave + octaveOffset) * 12 + pc;
                                    
                                    // Must be >= Tenor (allow unison)
                                    if (candidateMidi < tenorMidi)
                                        continue;
                                    
                                    // Must be within Alto range
                                    if (candidateMidi < upperMinMidi || candidateMidi > upperMaxMidi)
                                        continue;
                                    
                                    // Must be <= Soprano
                                    if (targetSopranoMidi.HasValue && candidateMidi > targetSopranoMidi.Value)
                                        continue;
                                    
                                    // Find nearest to original altoMidi
                                    int distance = Math.Abs(candidateMidi - altoMidi);
                                    if (distance < minDistance)
                                    {
                                        adjustedAlto = candidateMidi;
                                        minDistance = distance;
                                    }
                                }
                            }
                            
                            if (adjustedAlto >= 0)
                            {
                                fullSearchUpper[1] = adjustedAlto;
                                UnityEngine.Debug.Log(
                                    $"[SATB_NO_CROSSING] Full search Alto adjusted: {altoMidi} -> {adjustedAlto} to satisfy Alto >= Tenor {tenorMidi}");
                            }
                            else
                            {
                                UnityEngine.Debug.LogError(
                                    $"[SATB_NO_CROSSING] CRITICAL: Cannot adjust full search Alto {altoMidi} >= Tenor {tenorMidi}. " +
                                    $"Keeping original (will cause crossing).");
                            }
                        }
                    }
                    
                    upperVoices = fullSearchUpper;
                    foreach (var kvp in fullSearchSelectionMap)
                    {
                        if (!voiceSelectionMap.ContainsKey(kvp.Key))
                            voiceSelectionMap[kvp.Key] = kvp.Value;
                    }
                }
                else
                {
                    // Fallback: use incremental logic
                    BuildUpperVoicesIncrementalWithMelody(
                        previousEvent,
                        current,
                        numVoices,
                        bassVoice,
                        upperMinMidi,
                        upperMaxMidi,
                        prevUpper,
                        tendencyInfos,
                        previousAnalysis,
                        currentAnalysis,
                        targetSopranoMidi.Value,
                        chordTonePcs,
                        upperVoices,
                        voiceSelectionMap,
                        stepIndex,
                        diags);
                }
            }
            else
            {
                // Original logic when no melody constraint (Play path)
                // Debug logging: Show chord tone PCs before adding tensions
                var req = current.Recipe.RequestedExtensions;
                if (s_debugTensionDetect && stepIndex >= 0)
                {
                    string chordTonesStr = string.Join(",", chordTonePcs.OrderBy(x => x));
                    // High-level summary (always on)
                    if (req.HasAny)
                    {
                        var reqList = new List<string>();
                        if (req.TensionFlat9) reqList.Add("b9");
                        if (req.Tension9) reqList.Add("9");
                        if (req.TensionSharp11) reqList.Add("#11");
                        string reqStr = string.Join(",", reqList);
                        string token = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        UnityEngine.Debug.Log($"Chord {stepIndex} ({token}): requested tensions = [{reqStr}]");
                    }
                    
                    // Verbose details (gated)
                    if (s_debugTensionVerbose && s_debugTensionDetect)
                    {
                        string token = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        UnityEngine.Debug.Log(
                            $"[PLAY_DEBUG] === CHORD {stepIndex} (VoiceNextChord - NO melody) ===\n" +
                            $"  originalToken='{token}'\n" +
                            $"  ChordRecipe.RequestedExtensions=[b9={req.TensionFlat9}, 9={req.Tension9}, #11={req.TensionSharp11}]\n" +
                            $"  chordTonePcs (from GetChordTonePitchClasses)=[{chordTonesStr}]");
                    }
                }
                
                // CRITICAL: Include requested tension PCs in candidate pool
                var candidatePcs = new HashSet<int>(chordTonePcs);
                if (req.HasAny)
                {
                    int rootPc = chordTonePcs[0];
                    // Add requested tension PCs (mutually exclusive: b9 excludes 9)
                    if (req.TensionFlat9)
                    {
                        candidatePcs.Add((rootPc + 1) % 12); // b9
                        // Explicitly do NOT add natural 9
                    }
                    else if (req.Tension9)
                    {
                        candidatePcs.Add((rootPc + 2) % 12); // 9
                    }
                    if (req.TensionSharp11)
                    {
                        candidatePcs.Add((rootPc + 6) % 12); // #11
                    }
                    
                    // Debug logging: Show candidatePCs immediately after construction
                    if (s_debugTensionDetect && stepIndex >= 0)
                    {
                        string candidatePcsStr = string.Join(",", candidatePcs.OrderBy(x => x));
                        UnityEngine.Debug.Log(
                            $"[PLAY_DEBUG] Chord {stepIndex} candidatePCs=[{candidatePcsStr}] " +
                            $"(chordTones + requested tensions)");
                    }
                }
                
                // Generate candidate MIDI notes for upper voices
                var candidates = GenerateCandidatesInRange(new List<int>(candidatePcs), upperMinMidi, upperMaxMidi);
                
                // Debug logging: Per-voice candidate availability in VoiceNextChord
                if (s_debugTensionDetect && stepIndex >= 0 && req.TensionFlat9)
                {
                    int b9Pc = (chordTonePcs[0] + 1) % 12;
                    var b9Candidates = candidates.Where(m => (m % 12 + 12) % 12 == b9Pc).ToList();
                    int rootPc = chordTonePcs[0];
                    
                    if (s_debugTensionVerbose)
                    {
                        UnityEngine.Debug.Log(
                            $"[PLAY_DEBUG] Chord {stepIndex} (VoiceNextChord) candidate enumeration:\n" +
                            $"  Register limits: upperMinMidi={upperMinMidi}, upperMaxMidi={upperMaxMidi}, bassOctave={bassOctave}\n" +
                            $"  Total candidates from candidatePCs: {candidates.Count}\n" +
                            $"  Candidates with pc={b9Pc} (b9): {b9Candidates.Count}\n" +
                            $"  b9 candidate MIDI examples: {(b9Candidates.Count > 0 ? string.Join(",", b9Candidates.Take(5)) : "NONE")}\n" +
                            $"  All candidate MIDI range: {(candidates.Count > 0 ? $"{candidates.Min()}-{candidates.Max()}" : "NONE")}");
                    }
                }
                
                // TRACE 2: Candidate generation phase (after candidates generated, before scoring)
                if (enableTraceLogs && diags != null && diags.EnableTrace)
                {
                    string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                    if (ShouldTrace(label))
                    {
                        TraceLog($"[TRACE] R{stepIndex} {label}: Entered candidate selection", diags);
                        string candidateList = string.Join(",", candidates);
                        TraceLog($"[TRACE] R{stepIndex} {label}: Generated {candidates.Count} base candidates: [{candidateList}]", diags);
                    }
                }

                // Assign upper voices: try common tones first, then nearest chord tone
                // Use float costs with tendency adjustments for voice-leading
                var usedCandidates = new HashSet<int>();

                // NO DOUBLED TENSIONS: Build tension set and tracking for this chord step
                var tensionPcSetForIncremental = new HashSet<int>();
                var tensionPcsAlreadyChosen = new HashSet<int>();
                var reqForIncremental = current.Recipe.RequestedExtensions;
                int rootPcForIncremental = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                if (rootPcForIncremental < 0) rootPcForIncremental = 0;
                rootPcForIncremental = (rootPcForIncremental + current.Recipe.RootSemitoneOffset + 12) % 12;
                if (rootPcForIncremental < 0) rootPcForIncremental += 12;
                
                if (reqForIncremental.TensionFlat9) tensionPcSetForIncremental.Add((rootPcForIncremental + 1) % 12);
                if (reqForIncremental.Tension9) tensionPcSetForIncremental.Add((rootPcForIncremental + 2) % 12);
                if (reqForIncremental.TensionSharp9) tensionPcSetForIncremental.Add((rootPcForIncremental + 3) % 12);
                if (reqForIncremental.TensionSharp11) tensionPcSetForIncremental.Add((rootPcForIncremental + 6) % 12);
                if (reqForIncremental.Add9) tensionPcSetForIncremental.Add((rootPcForIncremental + 2) % 12);
                if (reqForIncremental.Add11) tensionPcSetForIncremental.Add((rootPcForIncremental + 5) % 12);
                
                // Include natural 9 from dominant 7th extensions (e.g., V9)
                bool chordHasSeventhForIncremental = current.Recipe.Extension == ChordExtension.Seventh &&
                                                   current.Recipe.SeventhQuality != SeventhQuality.None;
                if (chordHasSeventhForIncremental && current.Recipe.SeventhQuality == SeventhQuality.Dominant7 && 
                    !reqForIncremental.TensionFlat9 && !reqForIncremental.TensionSharp9)
                {
                    tensionPcSetForIncremental.Add((rootPcForIncremental + 2) % 12);
                }

                // Select inner voices (tenor/alto) first, then explicitly select soprano
                for (int voiceIdx = 0; voiceIdx < prevUpper.Count - 1; voiceIdx++) // Exclude soprano from loop
                {
                    int prevVoice = prevUpper[voiceIdx];
                    int prevPc = (prevVoice % 12 + 12) % 12;
                    int bestNote = -1;
                    float bestCost = float.MaxValue;
                    float chosenBaseCost = 0f;
                    float chosenTendAdjust = 0f;

                    // Get tendency info for this voice (gracefully handle if index out of range)
                    var tendencyInfo = voiceIdx < tendencyInfos.Length ? tendencyInfos[voiceIdx] : new VoiceTendencyInfo { midiNote = prevVoice };

                    // This is an inner voice (not soprano)
                    bool willBeSoprano = false;
                    
                    // Build voice-specific candidate list, starting with normal candidates
                    var voiceCandidates = new List<int>(candidates);
                    
                    // Trace: Log voice selection for inner voices (Tenor/Alto)
                    if (s_debugTensionDetect && stepIndex >= 0 && !current.MelodyMidi.HasValue)
                    {
                        string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                        var candidatePcsSet = new HashSet<int>();
                        foreach (int c in voiceCandidates)
                        {
                            candidatePcsSet.Add((c % 12 + 12) % 12);
                        }
                        string candidatePcsStr = string.Join(",", candidatePcsSet.OrderBy(x => x));
                        if (s_debugTensionVerbose)
                        {
                            UnityEngine.Debug.Log(
                                $"[PLAY_TRACE] step={stepIndex} selecting {voiceName}: " +
                                $"candidatePCs=[{candidatePcsStr}] ({voiceCandidates.Count} MIDI candidates)");
                        }
                    }
                    
                    // ForceSoprano mode: filter soprano candidates to only melodic tension pitch classes
                    if (willBeSoprano && s_extensionPlacementMode == RequestedExtensionPlacementMode.ForceSoprano)
                    {
                        var forcedPcs = GetSopranoCandidatePcsForForceMode(current);
                        if (forcedPcs != null && forcedPcs.Count > 0)
                        {
                            int originalCount = voiceCandidates.Count;
                            // Filter candidates to only those with pitch classes in forcedPcs
                            var filteredCandidates = new List<int>();
                            foreach (int candidate in voiceCandidates)
                            {
                                int candidatePc = (candidate % 12 + 12) % 12;
                                if (forcedPcs.Contains(candidatePc))
                                {
                                    filteredCandidates.Add(candidate);
                                }
                            }
                            if (filteredCandidates.Count > 0)
                            {
                                voiceCandidates = filteredCandidates;
                                
                                // Debug logging
                                if (s_debugTensionDetect)
                                {
                                    string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                    string forcedPcsStr = string.Join(",", forcedPcs);
                                    UnityEngine.Debug.Log(
                                        $"[REQ_EXT_PLACE] step={stepIndex} mode=ForceSoprano {label} " +
                                        $"filtered soprano candidates: {originalCount}->{filteredCandidates.Count} " +
                                        $"forcedPCs=[{forcedPcsStr}]");
                                }
                            }
                            // If no candidates match, keep original list (will fall back to best available)
                        }
                    }
                    
                    // For local leading tones, inject a nearby target root candidate (within ±3 semitones)
                    if (tendencyInfo.isLocalLeadingTone && tendencyInfo.localTargetRootPc >= 0)
                    {
                        int targetRootMidi = FindNearbyTargetRootForLocalLeadingTone(
                            prevVoice,
                            tendencyInfo.localTargetRootPc);
                        
                        // Validate that the target root candidate is a legal chord tone
                        if (targetRootMidi >= 0)
                        {
                            var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                            string voiceName = (voiceIdx == 0) ? "Tenor" : (voiceIdx == 1) ? "Alto" : (willBeSoprano ? "Soprano" : $"Voice{voiceIdx}");
                            int validatedMidi = ValidateAndRedirectTendencyCandidate(
                                targetRootMidi,
                                chordTonePcsSet,
                                upperMinMidi,
                                upperMaxMidi,
                                stepIndex,
                                diags,
                                voiceName,
                                prevVoice);
                            
                            if (validatedMidi >= 0 && !voiceCandidates.Contains(validatedMidi))
                            {
                                voiceCandidates.Add(validatedMidi);
                            }
                            else if (validatedMidi < 0 && diags != null)
                            {
                                // Reject illegal candidate - log diagnostic (capped to 1 per region)
                                int targetPc = (targetRootMidi % 12 + 12) % 12;
                                string allowedPCsStr = string.Join(",", chordTonePcs.OrderBy(x => x));
                                diags.Add(stepIndex, DiagSeverity.Warning, DiagCode.REJECTED_ILLEGAL_TENDENCY_CANDIDATE,
                                    $"Rejected illegal local-leading-tone candidate: {voiceName} fromMidi={prevVoice} attemptedMidi={targetRootMidi} pc={targetPc} allowedPCs=[{allowedPCsStr}]",
                                    voiceIndex: voiceIdx, beforeMidi: prevVoice, afterMidi: targetRootMidi);
                            }
                        }
                    }
                    
                    // For chord 7ths, inject a resolution candidate (step down by 1-2 semitones)
                    if (tendencyInfo.isChordSeventh)
                    {
                        int seventhPc2 = (prevVoice % 12 + 12) % 12;
                        var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                        int resolutionMidi = FindSeventhResolutionCandidate(
                            prevVoice,
                            seventhPc2,
                            upperMinMidi,
                            upperMaxMidi,
                            chordTonePcsSet,
                            current.MelodyMidi);
                        
                        // Validate that the resolution candidate is a legal chord tone
                        if (resolutionMidi >= 0)
                        {
                            string voiceName = (voiceIdx == 0) ? "Tenor" : (voiceIdx == 1) ? "Alto" : (willBeSoprano ? "Soprano" : $"Voice{voiceIdx}");
                            int validatedMidi = ValidateAndRedirectTendencyCandidate(
                                resolutionMidi,
                                chordTonePcsSet,
                                upperMinMidi,
                                upperMaxMidi,
                                stepIndex,
                                diags,
                                voiceName,
                                prevVoice);
                            
                            if (validatedMidi >= 0 && !voiceCandidates.Contains(validatedMidi))
                            {
                                voiceCandidates.Add(validatedMidi);
                                
                                // TRACE 2b: Log injected resolution candidate
                                if (enableTraceLogs)
                                {
                                    string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                    if (ShouldTrace(label))
                                    {
                                        int resolutionPc = (validatedMidi % 12 + 12) % 12;
                                        string resolutionName = TheoryPitch.GetPitchNameFromMidi(validatedMidi, current.Key);
                                        string allowedPCs = string.Join(",", chordTonePcs);
                                        TraceLog($"[TRACE Injected] R{stepIndex} {label} V{voiceIdx} Injected 7th-resolution candidate: {validatedMidi}→{resolutionName} (PC={resolutionPc}), allowedPCs=[{allowedPCs}]", diags);
                                    }
                                }
                            
                            if (enableTendencyDebug)
                            {
                                    int resolutionPc = (validatedMidi % 12 + 12) % 12;
                                    UnityEngine.Debug.Log($"[Tendency Debug] Injected 7th-resolution candidate: prev={prevVoice} ({seventhPc2}), injected={validatedMidi} ({resolutionPc})");
                                }
                            }
                            else if (validatedMidi < 0 && diags != null)
                            {
                                // Reject illegal candidate - log diagnostic (capped to 1 per region)
                                int resolutionPc = (resolutionMidi % 12 + 12) % 12;
                                string allowedPCsStr = string.Join(",", chordTonePcs.OrderBy(x => x));
                                diags.Add(stepIndex, DiagSeverity.Warning, DiagCode.REJECTED_ILLEGAL_TENDENCY_CANDIDATE,
                                    $"Rejected illegal 7th-resolution candidate: {voiceName} fromMidi={prevVoice} attemptedMidi={resolutionMidi} pc={resolutionPc} allowedPCs=[{allowedPCsStr}]",
                                    voiceIndex: voiceIdx, beforeMidi: prevVoice, afterMidi: resolutionMidi);
                            }
                        }
                    }
                    
                    // TRACE 2c: Log voice-specific candidates after injection
                    if (enableTraceLogs)
                    {
                        string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        if (ShouldTrace(label))
                        {
                            string voiceName = (voiceIdx == 0) ? "Tenor" : (voiceIdx == 1) ? "Alto" : (willBeSoprano ? "Soprano" : $"Voice{voiceIdx}");
                            string candidateList = string.Join(",", voiceCandidates);
                            TraceLog($"[TRACE] R{stepIndex} {label}: Generated candidates per voice - {voiceName}: [{candidateList}]", diags);
                        }
                    }

                    // CRITICAL: Hard no-crossing filter for Alto in SATB+melody path
                    // Alto must be >= Tenor (allow unison for inner voices)
                    if (voiceIdx == 1 && upperVoices.Count > 0) // Alto selection, Tenor already chosen
                    {
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING] ENTRY: Alto selection filter activated at stepIndex={stepIndex}, " +
                            $"voiceIdx={voiceIdx}, upperVoices.Count={upperVoices.Count}, " +
                            $"Tenor={upperVoices[0]}, candidates.Count={voiceCandidates.Count}");
                        
                        int tenorMidi = upperVoices[0]; // Tenor is first in upperVoices
                        var filteredCandidates = new List<int>();
                        
                        // Log filter activation (always log, not just for chord IV)
                        UnityEngine.Debug.Log(
                            $"[SATB_NO_CROSSING] Filtering Alto candidates: stepIndex={stepIndex} Tenor={tenorMidi}, " +
                            $"originalCandidates=[{string.Join(",", voiceCandidates)}]");
                        
                        foreach (int candidate in voiceCandidates)
                        {
                            if (candidate >= tenorMidi) // Allow equality (unison)
                            {
                                filteredCandidates.Add(candidate);
                            }
                            else
                            {
                                // Log rejected candidate (always log)
                                string candidateName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                string tenorName = TheoryPitch.GetPitchNameFromMidi(tenorMidi, current.Key);
                                UnityEngine.Debug.Log(
                                    $"[SATB_NO_CROSSING] Rejected Alto candidate {candidate}({candidateName}) " +
                                    $"(PC={(candidate % 12 + 12) % 12}) because it's < Tenor {tenorMidi}({tenorName}) " +
                                    $"(stepIndex={stepIndex})");
                            }
                        }
                        
                        // If filtering emptied the list, try fallback: find nearest chord-tone candidate octave-shifted upward
                        if (filteredCandidates.Count == 0)
                        {
                            // Get all chord tone pitch classes
                            var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                            
                            // Try each chord tone PC, octave-shifting upward until >= tenorMidi
                            foreach (int pc in chordTonePcsSet)
                            {
                                int baseOctave = tenorMidi / 12;
                                for (int octaveOffset = 0; octaveOffset <= 2; octaveOffset++) // Try up to 2 octaves above
                                {
                                    int candidateMidi = (baseOctave + octaveOffset) * 12 + pc;
                                    
                                    // Must be >= Tenor (allow unison)
                                    if (candidateMidi < tenorMidi)
                                        continue;
                                    
                                    // Must be within Alto range
                                    if (candidateMidi < upperMinMidi || candidateMidi > upperMaxMidi)
                                        continue;
                                    
                                    // Must be <= Soprano (if melody is present)
                                    if (targetSopranoMidi.HasValue && candidateMidi > targetSopranoMidi.Value)
                                        continue;
                                    
                                    // Found a valid fallback candidate
                                    if (!filteredCandidates.Contains(candidateMidi))
                                    {
                                        filteredCandidates.Add(candidateMidi);
                                    }
                                }
                            }
                            
                            // If still empty, log warning and keep best available (shouldn't happen, but safety)
                            if (filteredCandidates.Count == 0)
                            {
                                UnityEngine.Debug.LogWarning(
                                    $"[SATB_NO_CROSSING] Cannot find Alto candidate >= Tenor ({tenorMidi}) for chord {TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe)}. " +
                                    $"Original candidates: [{string.Join(",", voiceCandidates)}]. " +
                                    $"Using best available candidate (may cause crossing).");
                                // Keep original candidates as fallback (will be caught by WouldCauseVoiceCrossing)
                                filteredCandidates = new List<int>(voiceCandidates);
                            }
                            else
                            {
                                // Log fallback strategy used (always log)
                                UnityEngine.Debug.Log(
                                    $"[SATB_NO_CROSSING] Alto candidate filtering emptied list at stepIndex={stepIndex}. " +
                                    $"Applied fallback: found {filteredCandidates.Count} candidates >= Tenor ({tenorMidi}). " +
                                    $"Fallback candidates: [{string.Join(",", filteredCandidates)}]");
                            }
                        }
                        else if (voiceCandidates.Count != filteredCandidates.Count)
                        {
                            // Log filtering summary (always log when filtering occurs)
                            UnityEngine.Debug.Log(
                                $"[SATB_NO_CROSSING] Filtered Alto candidates: {voiceCandidates.Count} -> {filteredCandidates.Count} " +
                                $"(removed candidates < Tenor {tenorMidi}) at stepIndex={stepIndex}. " +
                                $"Filtered: [{string.Join(",", filteredCandidates)}]");
                        }
                        
                        voiceCandidates = filteredCandidates;
                    }

                    // First, look for common tone (same pitch class)
                    foreach (int candidate in voiceCandidates)
                    {
                        if (usedCandidates.Contains(candidate))
                            continue;

                        int candidatePc = (candidate % 12 + 12) % 12;
                        
                        // NO DOUBLED TENSIONS VETO: Reject candidate if it's a tension already chosen
                        if (tensionPcSetForIncremental.Contains(candidatePc) && tensionPcsAlreadyChosen.Contains(candidatePc))
                        {
                            string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                            string tensionName = "";
                            if (candidatePc == (rootPcForIncremental + 1) % 12) tensionName = "b9";
                            else if (candidatePc == (rootPcForIncremental + 2) % 12) tensionName = "9";
                            else if (candidatePc == (rootPcForIncremental + 3) % 12) tensionName = "#9";
                            else if (candidatePc == (rootPcForIncremental + 6) % 12) tensionName = "#11";
                            else tensionName = $"pc={candidatePc}";
                            
                            if (GetTendencyDebug())
                            {
                                string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                UnityEngine.Debug.Log(
                                    $"[NO_DOUBLE_TENSION] Reject {voiceName} candidate {candidate} (pc={candidatePc}, {tensionName}): " +
                                    $"tension already chosen in another voice for chord {chordName}");
                            }
                            continue; // Skip this candidate
                        }
                        
                        if (candidatePc == prevPc)
                        {
                            // Convert integer distance to float base cost
                            float baseCost = Math.Abs(candidate - prevVoice);
                            
                            // Check for common-tone 3rd→7th bonus: if prev voice is 3rd of current chord
                            // and candidate (same pitch) would be 7th of next chord
                            float commonThirdToSeventhAdjust = 0f;
                            var currentChordTonePcs = GetChordTonePitchClasses(new ChordEvent { Key = current.Key, Recipe = previousEvent.Recipe });
                            if (currentChordTonePcs.Count >= 2)
                            {
                                int currentThirdPc = currentChordTonePcs[1]; // Index 1 is 3rd
                                bool prevIsThirdOfCurrent = (prevPc == currentThirdPc);
                                
                                if (prevIsThirdOfCurrent)
                                {
                                    // Check if next chord has a 7th and if this pitch class is that 7th
                                    bool nextChordHasSeventh = current.Recipe.Extension == ChordExtension.Seventh &&
                                                              current.Recipe.SeventhQuality != SeventhQuality.None;
                                    if (nextChordHasSeventh && chordTonePcs.Count >= 4)
                                    {
                                        int nextSeventhPc = chordTonePcs[3]; // Index 3 is 7th
                                        if (candidatePc == nextSeventhPc)
                                        {
                                            commonThirdToSeventhAdjust = CommonThirdToSeventhBonus;
                                            
                                            if (enableTendencyDebug)
                                            {
                                                string prevName = TheoryPitch.GetPitchNameFromMidi(prevVoice, current.Key);
                                                string candName = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                                UnityEngine.Debug.Log($"[Tendency Debug] Common 3rd→7th: prev={prevName}(3rd of {previousEvent.Recipe}) held as {candName}(7th of {current.Recipe}), bonus={CommonThirdToSeventhBonus}");
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Check for voice crossing: candidate must be > bass and > all previously selected upper voices
                            if (WouldCauseVoiceCrossing(candidate, bassVoice, upperVoices, out string crossingError2))
                            {
                                // Veto this candidate - skip it entirely
                                // (Debug log removed to reduce spam - voice crossing checks are expected during candidate filtering)
                                continue; // Skip to next candidate
                            }
                            
                            // STRUCTURAL REJECTION: Natural 9 resolution constraint (common-tone alternative path)
                            // Same logic as in other paths
                            var prevReqExt4 = previousEvent.Recipe.RequestedExtensions;
                            int prevRootPcForNat9_4 = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                            if (prevRootPcForNat9_4 < 0) prevRootPcForNat9_4 = 0;
                            prevRootPcForNat9_4 = (prevRootPcForNat9_4 + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                            if (prevRootPcForNat9_4 < 0) prevRootPcForNat9_4 += 12;
                            bool prevIsDominant4 = (previousEvent.Recipe.Extension == ChordExtension.Seventh &&
                                                  previousEvent.Recipe.SeventhQuality == SeventhQuality.Dominant7) ||
                                                 (previousEvent.Recipe.Quality == ChordQuality.Major && 
                                                  previousEvent.Recipe.Extension == ChordExtension.None);
                            bool prevHasNatural9_4 = (prevReqExt4.HasAny && prevReqExt4.Tension9 && !prevReqExt4.TensionFlat9) ||
                                                  (prevIsDominant4 && prevPc == (prevRootPcForNat9_4 + 2) % 12);
                            
                            if (prevHasNatural9_4 && prevPc == (prevRootPcForNat9_4 + 2) % 12)
                            {
                                int ninePc4 = (prevRootPcForNat9_4 + 2) % 12;
                                int targetResolutionPcDown4 = (ninePc4 + 10) % 12;
                                int targetResolutionPcUp4 = (ninePc4 + 2) % 12;
                                
                                bool canResolveDown4 = chordTonePcs.Contains(targetResolutionPcDown4);
                                bool canResolveUp4 = chordTonePcs.Contains(targetResolutionPcUp4);
                                
                                if (current.Recipe.RequestedExtensions.HasAny)
                                {
                                    int nextRootPc4 = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                                    if (nextRootPc4 < 0) nextRootPc4 = 0;
                                    nextRootPc4 = (nextRootPc4 + current.Recipe.RootSemitoneOffset + 12) % 12;
                                    if (nextRootPc4 < 0) nextRootPc4 += 12;
                                    var nextReqExt4 = current.Recipe.RequestedExtensions;
                                    if (nextReqExt4.TensionFlat9)
                                        canResolveDown4 = canResolveDown4 || (targetResolutionPcDown4 == (nextRootPc4 + 1) % 12);
                                    else if (nextReqExt4.Tension9)
                                        canResolveUp4 = canResolveUp4 || (targetResolutionPcUp4 == (nextRootPc4 + 2) % 12);
                                }
                                
                                if (canResolveDown4 || canResolveUp4)
                                {
                                    int candidatePc4 = (candidate % 12 + 12) % 12;
                                    int semitoneDelta4 = candidate - prevVoice;
                                    bool isDownwardStep4 = canResolveDown4 && semitoneDelta4 == -2 && candidatePc4 == targetResolutionPcDown4;
                                    bool isUpwardStep4 = canResolveUp4 && semitoneDelta4 == 2 && candidatePc4 == targetResolutionPcUp4;
                                    
                                    if (!isDownwardStep4 && !isUpwardStep4)
                                    {
                                        if (s_debugTensionDetect)
                                        {
                                            string prevName4 = TheoryPitch.GetPitchNameFromMidi(prevVoice, previousEvent.Key);
                                            string candName4 = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                            string voiceName4 = voiceIdx == 0 ? "Tenor" : "Alto";
                                            UnityEngine.Debug.Log(
                                                $"[NAT9_REJECT] step={stepIndex} voice={voiceName4} (common-tone alt path): REJECTED candidate {candName4}({candidate}) " +
                                                $"(prev={prevName4}({prevVoice}) has natural 9, but candidate doesn't resolve by step)");
                                        }
                                        continue; // Reject this candidate
                                    }
                                }
                            }
                            
                            // Apply tendency adjustments
                            // Pass voice range for hard 7th resolution constraint
                            // When there's no melody, soprano also needs voice range for hard 7th rule
                            bool noMelodyForSoprano2 = !current.MelodyMidi.HasValue;
                            float tendAdjust = ComputeTendencyCostAdjustment(
                                tendencyInfo, candidate, current.Key,
                                previousEvent.Recipe, current.Recipe,
                                previousAnalysis, currentAnalysis,
                                isSoprano: willBeSoprano, nextMelodyMidi: current.MelodyMidi,
                                voiceMinMidi: (willBeSoprano && !noMelodyForSoprano2) ? -1 : upperMinMidi, 
                                voiceMaxMidi: (willBeSoprano && !noMelodyForSoprano2) ? -1 : upperMaxMidi);
                            
                            // Add leading-tone resolution penalty (dominant-to-tonic motion)
                            float leadingTonePenalty = ComputeLeadingToneResolutionPenalty(
                                prevVoice, candidate, previousEvent, current, stepIndex);
                            
                            // SAFETY RAIL: Infinite penalty for doubled tensions (even if veto check missed it)
                            float doubledTensionPenalty = 0f;
                            if (tensionPcSetForIncremental.Contains(candidatePc) && tensionPcsAlreadyChosen.Contains(candidatePc))
                            {
                                doubledTensionPenalty = 1e9f; // Infinite penalty
                                if (GetTendencyDebug())
                                {
                                    string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                                    string tensionName = "";
                                    if (candidatePc == (rootPcForIncremental + 1) % 12) tensionName = "b9";
                                    else if (candidatePc == (rootPcForIncremental + 2) % 12) tensionName = "9";
                                    else if (candidatePc == (rootPcForIncremental + 3) % 12) tensionName = "#9";
                                    else if (candidatePc == (rootPcForIncremental + 6) % 12) tensionName = "#11";
                                    else tensionName = $"pc={candidatePc}";
                                    string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                    UnityEngine.Debug.Log(
                                        $"[NO_DOUBLE_TENSION] INF PENALTY applied to {voiceName} candidate {candidate} (pc={candidatePc}, {tensionName}): " +
                                        $"tension already chosen in another voice for chord {chordName}");
                                }
                            }
                            
                            float totalCost = baseCost + tendAdjust + commonThirdToSeventhAdjust + leadingTonePenalty + doubledTensionPenalty;
                            
                            if (totalCost < bestCost)
                            {
                                bestNote = candidate;
                                bestCost = totalCost;
                                chosenBaseCost = baseCost;
                                chosenTendAdjust = tendAdjust + commonThirdToSeventhAdjust;
                            }
                        }
                    }

                    // If no common tone found, find nearest chord tone with tendency adjustments
                    if (bestNote < 0)
                    {
                        foreach (int candidate in voiceCandidates)
                        {
                            if (usedCandidates.Contains(candidate))
                                continue;

                            int candidatePc = (candidate % 12 + 12) % 12;
                            
                            // NO DOUBLED TENSIONS VETO: Reject candidate if it's a tension already chosen
                            if (tensionPcSetForIncremental.Contains(candidatePc) && tensionPcsAlreadyChosen.Contains(candidatePc))
                            {
                                string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                                string tensionName = "";
                                if (candidatePc == (rootPcForIncremental + 1) % 12) tensionName = "b9";
                                else if (candidatePc == (rootPcForIncremental + 2) % 12) tensionName = "9";
                                else if (candidatePc == (rootPcForIncremental + 3) % 12) tensionName = "#9";
                                else if (candidatePc == (rootPcForIncremental + 6) % 12) tensionName = "#11";
                                else tensionName = $"pc={candidatePc}";
                                
                                if (GetTendencyDebug())
                                {
                                    string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                    UnityEngine.Debug.Log(
                                        $"[NO_DOUBLE_TENSION] Reject {voiceName} candidate {candidate} (pc={candidatePc}, {tensionName}): " +
                                        $"tension already chosen in another voice for chord {chordName}");
                                }
                                continue; // Skip this candidate
                            }

                            // Convert integer distance to float base cost
                            float baseCost = Math.Abs(candidate - prevVoice);
                            
                            // Check for voice crossing: candidate must be > bass and > all previously selected upper voices
                            if (WouldCauseVoiceCrossing(candidate, bassVoice, upperVoices, out string crossingError3))
                            {
                                // Veto this candidate - skip it entirely
                                // (Debug log removed to reduce spam - voice crossing checks are expected during candidate filtering)
                                continue; // Skip to next candidate
                            }
                            
                            // STRUCTURAL REJECTION: Natural 9 resolution constraint (no melody path)
                            // Same logic as in other paths
                            var prevReqExt3 = previousEvent.Recipe.RequestedExtensions;
                            int prevRootPcForNat9_3 = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                            if (prevRootPcForNat9_3 < 0) prevRootPcForNat9_3 = 0;
                            prevRootPcForNat9_3 = (prevRootPcForNat9_3 + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                            if (prevRootPcForNat9_3 < 0) prevRootPcForNat9_3 += 12;
                            bool prevIsDominant3 = (previousEvent.Recipe.Extension == ChordExtension.Seventh &&
                                                  previousEvent.Recipe.SeventhQuality == SeventhQuality.Dominant7) ||
                                                 (previousEvent.Recipe.Quality == ChordQuality.Major && 
                                                  previousEvent.Recipe.Extension == ChordExtension.None);
                            bool prevHasNatural9_3 = (prevReqExt3.HasAny && prevReqExt3.Tension9 && !prevReqExt3.TensionFlat9) ||
                                                  (prevIsDominant3 && prevPc == (prevRootPcForNat9_3 + 2) % 12);
                            
                            if (prevHasNatural9_3 && prevPc == (prevRootPcForNat9_3 + 2) % 12)
                            {
                                int ninePc3 = (prevRootPcForNat9_3 + 2) % 12;
                                int targetResolutionPcDown3 = (ninePc3 + 10) % 12;
                                int targetResolutionPcUp3 = (ninePc3 + 2) % 12;
                                
                                bool canResolveDown3 = chordTonePcs.Contains(targetResolutionPcDown3);
                                bool canResolveUp3 = chordTonePcs.Contains(targetResolutionPcUp3);
                                
                                if (current.Recipe.RequestedExtensions.HasAny)
                                {
                                    int nextRootPc3 = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                                    if (nextRootPc3 < 0) nextRootPc3 = 0;
                                    nextRootPc3 = (nextRootPc3 + current.Recipe.RootSemitoneOffset + 12) % 12;
                                    if (nextRootPc3 < 0) nextRootPc3 += 12;
                                    var nextReqExt3 = current.Recipe.RequestedExtensions;
                                    if (nextReqExt3.TensionFlat9)
                                        canResolveDown3 = canResolveDown3 || (targetResolutionPcDown3 == (nextRootPc3 + 1) % 12);
                                    else if (nextReqExt3.Tension9)
                                        canResolveUp3 = canResolveUp3 || (targetResolutionPcUp3 == (nextRootPc3 + 2) % 12);
                                }
                                
                                if (canResolveDown3 || canResolveUp3)
                                {
                                    int candidatePc3 = (candidate % 12 + 12) % 12;
                                    int semitoneDelta3 = candidate - prevVoice;
                                    bool isDownwardStep3 = canResolveDown3 && semitoneDelta3 == -2 && candidatePc3 == targetResolutionPcDown3;
                                    bool isUpwardStep3 = canResolveUp3 && semitoneDelta3 == 2 && candidatePc3 == targetResolutionPcUp3;
                                    
                                    if (!isDownwardStep3 && !isUpwardStep3)
                                    {
                                        if (s_debugTensionDetect)
                                        {
                                            string prevName3 = TheoryPitch.GetPitchNameFromMidi(prevVoice, previousEvent.Key);
                                            string candName3 = TheoryPitch.GetPitchNameFromMidi(candidate, current.Key);
                                            string voiceName3 = voiceIdx == 0 ? "Tenor" : "Alto";
                                            UnityEngine.Debug.Log(
                                                $"[NAT9_REJECT] step={stepIndex} voice={voiceName3} (no-melody path): REJECTED candidate {candName3}({candidate}) " +
                                                $"(prev={prevName3}({prevVoice}) has natural 9, but candidate doesn't resolve by step)");
                                        }
                                        continue; // Reject this candidate
                                    }
                                }
                            }
                            
                            // Apply tendency adjustments
                            // Pass voice range for hard 7th resolution constraint
                            // When there's no melody, soprano also needs voice range for hard 7th rule
                            bool noMelodyForNearest = !current.MelodyMidi.HasValue;
                            float tendAdjust = ComputeTendencyCostAdjustment(
                                tendencyInfo, candidate, current.Key,
                                previousEvent.Recipe, current.Recipe,
                                previousAnalysis, currentAnalysis,
                                isSoprano: willBeSoprano, nextMelodyMidi: current.MelodyMidi,
                                voiceMinMidi: (willBeSoprano && !noMelodyForNearest) ? -1 : upperMinMidi, 
                                voiceMaxMidi: (willBeSoprano && !noMelodyForNearest) ? -1 : upperMaxMidi);
                            
                            // Add leading-tone resolution penalty (dominant-to-tonic motion)
                            float leadingTonePenalty = ComputeLeadingToneResolutionPenalty(
                                prevVoice, candidate, previousEvent, current, stepIndex);
                            
                            // SAFETY RAIL: Infinite penalty for doubled tensions (even if veto check missed it)
                            float doubledTensionPenalty = 0f;
                            if (tensionPcSetForIncremental.Contains(candidatePc) && tensionPcsAlreadyChosen.Contains(candidatePc))
                            {
                                doubledTensionPenalty = 1e9f; // Infinite penalty
                                if (GetTendencyDebug())
                                {
                                    string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                                    string tensionName = "";
                                    if (candidatePc == (rootPcForIncremental + 1) % 12) tensionName = "b9";
                                    else if (candidatePc == (rootPcForIncremental + 2) % 12) tensionName = "9";
                                    else if (candidatePc == (rootPcForIncremental + 3) % 12) tensionName = "#9";
                                    else if (candidatePc == (rootPcForIncremental + 6) % 12) tensionName = "#11";
                                    else tensionName = $"pc={candidatePc}";
                                    string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                    UnityEngine.Debug.Log(
                                        $"[NO_DOUBLE_TENSION] INF PENALTY applied to {voiceName} candidate {candidate} (pc={candidatePc}, {tensionName}): " +
                                        $"tension already chosen in another voice for chord {chordName}");
                                }
                            }
                            
                            float totalCost = baseCost + tendAdjust + leadingTonePenalty + doubledTensionPenalty;
                            
                            // DIAGNOSTIC: Log candidate evaluation for step 1 when resolving b9 from step 0
                            if (stepIndex == 1 && previousEvent.Recipe.RequestedExtensions.TensionFlat9 && prevPc == ((TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree) + previousEvent.Recipe.RootSemitoneOffset + 1) % 12))
                            {
                                int diagCandidatePc = (candidate % 12 + 12) % 12;
                                int targetResolutionPc = (prevPc + 11) % 12; // -1 semitone from b9
                                bool isStrictStep = (candidate - prevVoice == -1);
                                bool matchesTarget = (diagCandidatePc == targetResolutionPc);
                                string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                                
                                UnityEngine.Debug.Log(
                                    $"[STEP1_CANDIDATE_DIAG] step=1 {voiceName} (voiceIdx={voiceIdx}) candidate evaluation:\n" +
                                    $"  candidate={candidate} ({TheoryPitch.GetPitchNameFromMidi(candidate, current.Key)}), candidatePc={diagCandidatePc}\n" +
                                    $"  prevVoice={prevVoice} ({TheoryPitch.GetPitchNameFromMidi(prevVoice, previousEvent.Key)}), prevPc={prevPc}\n" +
                                    $"  midiDelta={candidate - prevVoice}, isStrictStep={isStrictStep} (expected: -1)\n" +
                                    $"  targetResolutionPc={targetResolutionPc}, matchesTarget={matchesTarget}\n" +
                                    $"  baseCost={baseCost}, tendAdjust={tendAdjust}, totalCost={totalCost}\n" +
                                    $"  bestCost={bestCost}, isBest={totalCost < bestCost}");
                            }
                            
                            if (totalCost < bestCost)
                            {
                                bestNote = candidate;
                                bestCost = totalCost;
                                chosenBaseCost = baseCost;
                                chosenTendAdjust = tendAdjust;
                            }
                        }
                    }

                    // If still no candidate found, fallback to mid register placement
                    if (bestNote < 0)
                    {
                        // Use first available chord tone pitch class that is NOT a doubled tension
                        int fallbackPc = -1;
                        for (int i = 0; i < chordTonePcs.Count; i++)
                        {
                            int pc = chordTonePcs[i];
                            // Skip if this PC is a tension that's already chosen
                            if (tensionPcSetForIncremental.Contains(pc) && tensionPcsAlreadyChosen.Contains(pc))
                            {
                                if (GetTendencyDebug())
                                {
                                    string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                                    string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                    UnityEngine.Debug.Log(
                                        $"[NO_DOUBLE_TENSION] Emergency fallback skipping pc={pc} (doubled tension) for {voiceName} in {chordName}");
                                }
                                continue; // Skip this PC, try next
                            }
                            fallbackPc = pc;
                            break; // Found a valid PC
                        }
                        
                        // If all chord tones are doubled tensions, use the first one anyway (shouldn't happen, but safety)
                        if (fallbackPc < 0)
                        {
                            fallbackPc = chordTonePcs.Count > 1 ? chordTonePcs[1] : chordTonePcs[0];
                            if (GetTendencyDebug())
                            {
                                string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                                string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                UnityEngine.Debug.LogWarning(
                                    $"[NO_DOUBLE_TENSION] Emergency fallback forced to use pc={fallbackPc} (all chord tones are doubled tensions) for {voiceName} in {chordName}");
                            }
                        }
                        
                        // CRITICAL: For Alto, ensure fallback respects no-crossing constraint (Alto >= Tenor)
                        // voiceIdx == 1 means Alto (voiceIdx == 0 is Tenor)
                        if (voiceIdx == 1 && upperVoices.Count > 0)
                        {
                            int tenorMidi = upperVoices[0];
                            int fallbackMidi = PlaceInMidRegister(fallbackPc, upperMinMidi, upperMaxMidi);
                            
                            // If fallback would cause crossing, try octave-shifting upward
                            if (fallbackMidi < tenorMidi)
                            {
                                // Try placing in next octave
                                int baseOctave = (tenorMidi / 12) + 1;
                                int candidateMidi = baseOctave * 12 + fallbackPc;
                                
                                // Must be within Alto range and <= Soprano
                                if (candidateMidi >= tenorMidi && 
                                    candidateMidi >= upperMinMidi && candidateMidi <= upperMaxMidi &&
                                    (targetSopranoMidi <= 0 || candidateMidi <= targetSopranoMidi))
                                {
                                    bestNote = candidateMidi;
                                    UnityEngine.Debug.LogWarning(
                                        $"[SATB_NO_CROSSING] Fallback adjusted: Alto fallback {fallbackMidi} -> {candidateMidi} to satisfy Alto >= Tenor {tenorMidi}");
                                }
                                else
                                {
                                    // Still can't satisfy constraint - use original but log error
                                    bestNote = fallbackMidi;
                                    UnityEngine.Debug.LogError(
                                        $"[SATB_NO_CROSSING] CRITICAL: Fallback Alto {fallbackMidi} < Tenor {tenorMidi} and cannot be adjusted. " +
                                        $"This will cause voice crossing!");
                                }
                            }
                            else
                            {
                                bestNote = fallbackMidi;
                            }
                        }
                        else
                        {
                            bestNote = PlaceInMidRegister(fallbackPc, upperMinMidi, upperMaxMidi);
                        }
                        
                        chosenBaseCost = Math.Abs(bestNote - prevVoice);
                        chosenTendAdjust = 0f;
                    }

                    // Debug logging for tendency cases
                    if (bestNote >= 0)
                    {
                        LogTendencyDebugInfo(
                            stepIndex: stepIndex,
                            voiceIndex: voiceIdx + 1,
                            tendencyInfo,
                            prevVoice,
                            bestNote,
                            current.Key,
                            current.Recipe,
                            currentAnalysis,
                            chosenBaseCost,
                            chosenTendAdjust,
                            bestCost);
                        
                        // Trace: Log selected note for inner voice
                        if (s_debugTensionDetect && stepIndex >= 0 && !current.MelodyMidi.HasValue)
                        {
                            string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                            int traceChosenPc = (bestNote % 12 + 12) % 12;
                            string chosenName = TheoryPitch.GetPitchNameFromMidi(bestNote, current.Key);
                            UnityEngine.Debug.Log(
                                $"[PLAY_TRACE] step={stepIndex} {voiceName} chosen: " +
                                $"{bestNote}({chosenName},pc={traceChosenPc})");
                        }
                    }

                    // CRITICAL: Verify Alto >= Tenor after selection (hard no-crossing check)
                    // This is a final safeguard in case something overrode the filter
                    if (voiceIdx == 1 && upperVoices.Count > 0 && bestNote >= 0) // Alto selection
                    {
                        int tenorMidi = upperVoices[0];
                        if (bestNote < tenorMidi)
                        {
                            // This should never happen if the filter worked correctly
                            UnityEngine.Debug.LogError(
                                $"[SATB_NO_CROSSING_ERROR] CRITICAL: Alto candidate {bestNote} was chosen but is < Tenor {tenorMidi}! " +
                                $"This indicates the hard filter failed or was bypassed. " +
                                $"Chord: {TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe)} at stepIndex={stepIndex}");
                            
                            // Force fallback: find nearest chord tone >= Tenor
                            var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                            int fallbackAlto = -1;
                            int fallbackDistance = int.MaxValue;
                            
                            foreach (int pc in chordTonePcsSet)
                            {
                                int baseOctave = tenorMidi / 12;
                                for (int octaveOffset = 0; octaveOffset <= 2; octaveOffset++)
                                {
                                    int candidateMidi = (baseOctave + octaveOffset) * 12 + pc;
                                    if (candidateMidi >= tenorMidi && 
                                        candidateMidi >= upperMinMidi && candidateMidi <= upperMaxMidi &&
                                        (!targetSopranoMidi.HasValue || candidateMidi <= targetSopranoMidi.Value))
                                    {
                                        int distance = Math.Abs(candidateMidi - bestNote);
                                        if (distance < fallbackDistance)
                                        {
                                            fallbackAlto = candidateMidi;
                                            fallbackDistance = distance;
                                        }
                                    }
                                }
                            }
                            
                            if (fallbackAlto >= 0)
                            {
                                UnityEngine.Debug.LogWarning(
                                    $"[SATB_NO_CROSSING] Forced fallback: Alto {bestNote} -> {fallbackAlto} to satisfy Alto >= Tenor constraint");
                                bestNote = fallbackAlto;
                            }
                            else
                            {
                                UnityEngine.Debug.LogError(
                                    $"[SATB_NO_CROSSING] CRITICAL: Cannot find fallback Alto >= Tenor {tenorMidi}. " +
                                    $"This will cause voice crossing!");
                            }
                        }
                    }

                    // Store mapping: previous voice index -> selected MIDI (for 7th resolution enforcement)
                    if (!voiceSelectionMap.ContainsKey(voiceIdx))
                    {
                        voiceSelectionMap[voiceIdx] = bestNote;
                    }

                    // TRACE: Log selected note for this voice
                    if (enableTraceLogs)
                    {
                        string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        if (ShouldTrace(label))
                        {
                            string voiceName = (voiceIdx == 0) ? "Tenor" : (voiceIdx == 1) ? "Alto" : (willBeSoprano ? "Soprano" : $"Voice{voiceIdx}");
                            string pitchName = TheoryPitch.GetPitchNameFromMidi(bestNote, current.Key);
                            int pc = (bestNote % 12 + 12) % 12;
                            TraceLog($"[TRACE] R{stepIndex} {label}: Selected {voiceName} = {bestNote}→{pitchName} (PC={pc})", diags);
                        }
                    }

                    // DIAGNOSTIC: Log chosen voice for step 1 when resolving b9 from step 0 (after selection)
                    if (stepIndex == 1 && previousEvent.Recipe.RequestedExtensions.TensionFlat9 && bestNote >= 0)
                    {
                        int prevRootPc = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                        if (prevRootPc < 0) prevRootPc = 0;
                        prevRootPc = (prevRootPc + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                        if (prevRootPc < 0) prevRootPc += 12;
                        int b9Pc = (prevRootPc + 1) % 12;
                        
                        if (prevPc == b9Pc)
                        {
                            string voiceName = voiceIdx == 0 ? "Tenor" : "Alto";
                            int diagChosenPc = (bestNote % 12 + 12) % 12;
                            string chosenName = TheoryPitch.GetPitchNameFromMidi(bestNote, current.Key);
                            int targetResolutionPc = (b9Pc + 11) % 12;
                            int resolutionDelta = bestNote - prevVoice;
                            bool isStrictStep = (resolutionDelta == -1);
                            bool matchesTarget = (diagChosenPc == targetResolutionPc);
                            
                            UnityEngine.Debug.Log(
                                $"[STEP1_CHOSEN_DIAG] step=1 {voiceName} (voiceIdx={voiceIdx}) CHOSEN (non-common-tone path):\n" +
                                $"  prevVoice={prevVoice} ({TheoryPitch.GetPitchNameFromMidi(prevVoice, previousEvent.Key)}), prevPc={prevPc} (b9)\n" +
                                $"  chosen={bestNote} ({chosenName}), chosenPc={diagChosenPc}\n" +
                                $"  resolutionDelta={resolutionDelta}, isStrictStep={isStrictStep} (expected: -1)\n" +
                                $"  targetResolutionPc={targetResolutionPc}, matchesTarget={matchesTarget}\n" +
                                $"  baseCost={chosenBaseCost}, tendAdjust={chosenTendAdjust}, totalCost={bestCost}");
                        }
                    }
                    
                    // ASSERTION: Verify that chosen note is not a doubled tension (debug builds only)
                    #if UNITY_EDITOR || DEVELOPMENT_BUILD
                    if (bestNote >= 0)
                    {
                        int chosenPcForAssert = (bestNote % 12 + 12) % 12;
                        if (tensionPcSetForIncremental.Contains(chosenPcForAssert) && tensionPcsAlreadyChosen.Contains(chosenPcForAssert))
                        {
                            string voiceNameForAssert = voiceIdx == 0 ? "Tenor" : "Alto";
                            string tensionNameForAssert = "";
                            if (chosenPcForAssert == (rootPcForIncremental + 1) % 12) tensionNameForAssert = "b9";
                            else if (chosenPcForAssert == (rootPcForIncremental + 2) % 12) tensionNameForAssert = "9";
                            else if (chosenPcForAssert == (rootPcForIncremental + 3) % 12) tensionNameForAssert = "#9";
                            else if (chosenPcForAssert == (rootPcForIncremental + 6) % 12) tensionNameForAssert = "#11";
                            else tensionNameForAssert = $"pc={chosenPcForAssert}";
                            string chordNameForAssert = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                            string errorMsg = 
                                $"[NO_DOUBLE_TENSION ASSERTION FAILED] step={stepIndex} voice={voiceNameForAssert} " +
                                $"chosen={bestNote} (pc={chosenPcForAssert}, {tensionNameForAssert}) is a doubled tension " +
                                $"for chord {chordNameForAssert}. This should have been vetoed!";
                            UnityEngine.Debug.LogError(errorMsg);
                            UnityEngine.Debug.Assert(false, errorMsg);
                        }
                    }
                    #endif
                    
                    upperVoices.Add(bestNote);
                    usedCandidates.Add(bestNote);
                    
                    // Update tension tracking: if chosen note is a tension, mark it as chosen
                    int chosenPc = (bestNote % 12 + 12) % 12;
                    if (tensionPcSetForIncremental.Contains(chosenPc))
                    {
                        tensionPcsAlreadyChosen.Add(chosenPc);
                    }
                }
                
                // Explicit soprano selection for no-melody path
                // After selecting all inner voices (tenor/alto), explicitly choose soprano with Force/Prefer policies
                // The loop above selects prevUpper.Count - 1 inner voices, so now we select soprano
                if (upperVoices.Count == prevUpper.Count - 1) // We've selected all inner voices, now select soprano
                {
                    // Get previous soprano for tendency cost adjustment
                    int previousSoprano = prevUpper.Count > 0 ? prevUpper[prevUpper.Count - 1] : -1;
                    int sopranoMidi = SelectSopranoExplicitly(
                        current,
                        upperVoices,
                        bassVoice,
                        chordTonePcs,
                        upperMinMidi,
                        upperMaxMidi,
                        stepIndex,
                        diags,
                        previousEvent: previousEvent,
                        previousSopranoMidi: previousSoprano,
                        previousAnalysis: previousAnalysis,
                        currentAnalysis: currentAnalysis);
                    
                    if (sopranoMidi >= 0)
                    {
                        // ASSERTION: Verify that soprano is not a doubled tension (debug builds only)
                        #if UNITY_EDITOR || DEVELOPMENT_BUILD
                        int sopranoPcForAssert = (sopranoMidi % 12 + 12) % 12;
                        if (tensionPcSetForIncremental.Contains(sopranoPcForAssert) && tensionPcsAlreadyChosen.Contains(sopranoPcForAssert))
                        {
                            string tensionNameForAssert = "";
                            if (sopranoPcForAssert == (rootPcForIncremental + 1) % 12) tensionNameForAssert = "b9";
                            else if (sopranoPcForAssert == (rootPcForIncremental + 2) % 12) tensionNameForAssert = "9";
                            else if (sopranoPcForAssert == (rootPcForIncremental + 3) % 12) tensionNameForAssert = "#9";
                            else if (sopranoPcForAssert == (rootPcForIncremental + 6) % 12) tensionNameForAssert = "#11";
                            else tensionNameForAssert = $"pc={sopranoPcForAssert}";
                            string chordNameForAssert = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                            string errorMsg = 
                                $"[NO_DOUBLE_TENSION ASSERTION FAILED] step={stepIndex} voice=Soprano " +
                                $"chosen={sopranoMidi} (pc={sopranoPcForAssert}, {tensionNameForAssert}) is a doubled tension " +
                                $"for chord {chordNameForAssert}. This should have been vetoed!";
                            UnityEngine.Debug.LogError(errorMsg);
                            UnityEngine.Debug.Assert(false, errorMsg);
                        }
                        #endif
                        
                        upperVoices.Add(sopranoMidi);
                        usedCandidates.Add(sopranoMidi);
                        
                        // Update tension tracking: if soprano is a tension, mark it as chosen
                        int sopranoPc = (sopranoMidi % 12 + 12) % 12;
                        if (tensionPcSetForIncremental.Contains(sopranoPc))
                        {
                            tensionPcsAlreadyChosen.Add(sopranoPc);
                        }
                        
                        // Minimal debug logging for V9/tension chords (gated, temporary)
                        string labelForDebug = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        string tokenForDebug = regionDebugLabel ?? labelForDebug;
                        bool hasTension9 = reqForIncremental.TensionFlat9 || reqForIncremental.Tension9 || reqForIncremental.TensionSharp9;
                        bool shouldLogMinimal = (tokenForDebug.Contains("V9") || hasTension9) && stepIndex >= 0 && !current.MelodyMidi.HasValue;
                        if (shouldLogMinimal)
                        {
                            var allVoicesForMinimal = new List<int> { bassVoice };
                            allVoicesForMinimal.AddRange(upperVoices);
                            var voicePcs = new List<int>();
                            for (int i = 0; i < allVoicesForMinimal.Count && i < 4; i++)
                            {
                                int midi = allVoicesForMinimal[i];
                                int pc = (midi % 12 + 12) % 12;
                                voicePcs.Add(pc);
                            }
                            string voicePcsStr = string.Join(",", voicePcs);
                            string tensionPcsStr = string.Join(",", tensionPcSetForIncremental.OrderBy(x => x));
                            UnityEngine.Debug.Log(
                                $"[NO_DOUBLE_TENSION_DEBUG] step={stepIndex} token='{tokenForDebug}' rootPc={rootPcForIncremental} " +
                                $"tensionPcSet=[{tensionPcsStr}] finalVoices(BTAS)=[{voicePcsStr}]");
                        }
                        
                        // Trace A: Immediately after initial voicing selection (after soprano chosen)
                        if (s_debugTensionDetect && stepIndex >= 0 && !current.MelodyMidi.HasValue)
                        {
                            var allVoicesForTrace = new List<int> { bassVoice };
                            allVoicesForTrace.AddRange(upperVoices);
                            var reqTrace = current.Recipe.RequestedExtensions;
                            var reqList = new List<string>();
                            if (reqTrace.TensionFlat9) reqList.Add("b9");
                            if (reqTrace.Tension9) reqList.Add("9");
                            if (reqTrace.TensionSharp11) reqList.Add("#11");
                            string reqStr = reqList.Count > 0 ? string.Join(",", reqList) : "none";
                            int rootPcTrace = chordTonePcs[0];
                            string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                            string token = regionDebugLabel ?? label;
                            
                            // Compute b9 PC if requested
                            int b9PcTrace = -1;
                            if (reqTrace.TensionFlat9)
                            {
                                b9PcTrace = (rootPcTrace + 1) % 12;
                            }
                            
                            var voiceInfo = new List<string>();
                            var pcs = new List<int>();
                            for (int i = 0; i < allVoicesForTrace.Count && i < 4; i++)
                            {
                                int midi = allVoicesForTrace[i];
                                int pc = (midi % 12 + 12) % 12;
                                string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                                string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, current.Key);
                                voiceInfo.Add($"{voiceName}={midi}({pitchName},pc={pc})");
                                pcs.Add(pc);
                            }
                            
                            // Compact summary log
                            string preVoices = string.Join(" ", voiceInfo);
                            string prePcs = string.Join(",", pcs.OrderBy(x => x));
                            string b9PcStr = b9PcTrace >= 0 ? b9PcTrace.ToString() : "N/A";
                            bool b9Present = b9PcTrace >= 0 && pcs.Contains(b9PcTrace);
                            if (s_debugTensionVerbose && s_debugTensionDetect)
                            {
                                UnityEngine.Debug.Log(
                                    $"[B9_FLOW] step={stepIndex} token={token} rootPc={rootPcTrace} req=[{reqStr}] b9Pc={b9PcStr} " +
                                    $"preVoices=[{preVoices}] prePcs=[{prePcs}] b9Present={b9Present}");
                                
                                UnityEngine.Debug.Log(
                                    $"[PLAY_VOICES_TRACE] A) After initial voicing selection:\n" +
                                    $"  step={stepIndex} token='{token}' label='{label}' rootPc={rootPcTrace} requested=[{reqStr}]\n" +
                                    $"  voices: {string.Join(" ", voiceInfo)}\n" +
                                    $"  pcs=[{string.Join(",", pcs.OrderBy(x => x))}]");
                            }
                        }
                    }
                }
                
                // CRITICAL: In explicit lane assignment mode (melody/SATB path), do NOT sort upperVoices
                // Sorting would break lane identity (Tenor/Alto swap bug)
                // Only sort for non-melody paths where we rely on implicit ordering
                bool shouldSkipSort = hasMelody; // Melody path uses explicit lane assignment, skip sort
                
                if (!shouldSkipSort)
                {
                    // Ensure upper voices are strictly ascending (low→high)
                    // Sort inner voices (soprano will be added separately if melody is present)
                    upperVoices.Sort();
                    
                    // ORDERING_DEBUG: Log sort operation for non-melody path (gated)
                    if (s_enableAug5Debug && stepIndex == 2 && s_debugTensionDetect)
                    {
                        UnityEngine.Debug.Log(
                            $"[ORDERING_DEBUG] Non-melody path: sorted upperVoices for stepIndex={stepIndex}");
                    }
                }
                else
                {
                    // ORDERING_DEBUG: Log that sort is skipped for melody path
                    if (stepIndex == 2 && s_debugTensionDetect)
                    {
                        if (s_enableAug5Debug)
                        {
                            UnityEngine.Debug.Log(
                                $"[ORDERING_DEBUG] Melody path (shouldSkipSort=true): skipping sort for stepIndex={stepIndex} " +
                                $"upperVoices=[{string.Join(",", upperVoices)}]");
                        }
                    }
                }
                
                // Add soprano at highest position (if melody was present)
                if (GetTendencyDebug())
                {
                    UnityEngine.Debug.Log($"[Soprano Debug] Step {stepIndex}: current.MelodyMidi.HasValue={current.MelodyMidi.HasValue}, targetSopranoMidi.HasValue={targetSopranoMidi.HasValue}, upperVoices.Count={upperVoices.Count}");
                }
                
                if (targetSopranoMidi.HasValue)
                {
                    // Check that soprano doesn't cause crossing
                    if (upperVoices.Count > 0 && targetSopranoMidi.Value <= upperVoices[upperVoices.Count - 1])
                    {
                        if (enableTendencyDebug)
                        {
                            UnityEngine.Debug.Log($"[Voice Crossing] Soprano ({targetSopranoMidi.Value}) <= highest upper voice ({upperVoices[upperVoices.Count - 1]})");
                        }
                        // This should not happen if melody constraint is set correctly, but log if it does
                    }
                    upperVoices.Add(targetSopranoMidi.Value);
                    
                    if (GetTendencyDebug())
                    {
                        UnityEngine.Debug.Log($"[Soprano Debug] Added soprano {targetSopranoMidi.Value} to upperVoices, new count={upperVoices.Count}");
                    }
                }
                else if (GetTendencyDebug())
                {
                    UnityEngine.Debug.LogWarning($"[Soprano Debug] Step {stepIndex}: targetSopranoMidi is null, soprano will not be added!");
                }

                // Assemble final voicing
                // For non-melody path: use sorted upperVoices (implicit ordering)
                // For melody path: explicit lane assignment is handled separately above
                var finalVoices = new List<int> { bassVoice };
                finalVoices.AddRange(upperVoices);
                var finalVoicesArray = finalVoices.ToArray();
                
                // NO DOUBLED TENSIONS CHECK (non-melody path): Veto voicing if tensions are doubled
                // This is a hard veto - if doubled tensions are found, we need to reject and try a different approach
                if (finalVoicesArray.Length >= 4)
                {
                    // Build tension pitch class set
                    var tensionPcSetNonMelody = new HashSet<int>();
                    var reqNonMelody = current.Recipe.RequestedExtensions;
                    int rootPcNonMelody = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                    if (rootPcNonMelody < 0) rootPcNonMelody = 0;
                    rootPcNonMelody = (rootPcNonMelody + current.Recipe.RootSemitoneOffset + 12) % 12;
                    if (rootPcNonMelody < 0) rootPcNonMelody += 12;
                    
                    if (reqNonMelody.TensionFlat9) tensionPcSetNonMelody.Add((rootPcNonMelody + 1) % 12);
                    if (reqNonMelody.Tension9) tensionPcSetNonMelody.Add((rootPcNonMelody + 2) % 12);
                    if (reqNonMelody.TensionSharp9) tensionPcSetNonMelody.Add((rootPcNonMelody + 3) % 12);
                    if (reqNonMelody.TensionSharp11) tensionPcSetNonMelody.Add((rootPcNonMelody + 6) % 12);
                    if (reqNonMelody.Add9) tensionPcSetNonMelody.Add((rootPcNonMelody + 2) % 12);
                    if (reqNonMelody.Add11) tensionPcSetNonMelody.Add((rootPcNonMelody + 5) % 12);
                    
                    // Include natural 9 from dominant 7th extensions
                    bool chordHasSeventhNonMelody = current.Recipe.Extension == ChordExtension.Seventh &&
                                                   current.Recipe.SeventhQuality != SeventhQuality.None;
                    if (chordHasSeventhNonMelody && current.Recipe.SeventhQuality == SeventhQuality.Dominant7 && 
                        !reqNonMelody.TensionFlat9 && !reqNonMelody.TensionSharp9)
                    {
                        tensionPcSetNonMelody.Add((rootPcNonMelody + 2) % 12);
                    }
                    
                    // Check for doubled tensions
                    bool hasDoubledTensionNonMelody = false;
                    int doubledTensionPcNonMelody = -1;
                    var tensionOccurrencesNonMelody = new Dictionary<int, List<string>>();
                    
                    foreach (int tensionPc in tensionPcSetNonMelody)
                    {
                        int count = 0;
                        var voicesWithTension = new List<string>();
                        
                        for (int v = 0; v < finalVoicesArray.Length; v++)
                        {
                            int voicePc = (finalVoicesArray[v] % 12 + 12) % 12;
                            if (voicePc == tensionPc)
                            {
                                count++;
                                string voiceName = v == 0 ? "Bass" : v == 1 ? "Tenor" : v == 2 ? "Alto" : "Soprano";
                                voicesWithTension.Add(voiceName);
                            }
                        }
                        
                        if (count > 1)
                        {
                            hasDoubledTensionNonMelody = true;
                            doubledTensionPcNonMelody = tensionPc;
                            tensionOccurrencesNonMelody[tensionPc] = voicesWithTension;
                            break;
                        }
                    }
                    
                    if (hasDoubledTensionNonMelody)
                    {
                        // This is a hard veto - we should not accept this voicing
                        // However, in the incremental path, we've already selected voices, so we log a warning
                        // In practice, this should be rare if the melody-path veto is working correctly
                        string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        string voicesStr = string.Join(",", tensionOccurrencesNonMelody[doubledTensionPcNonMelody]);
                        string tensionName = "";
                        if (doubledTensionPcNonMelody == (rootPcNonMelody + 1) % 12) tensionName = "b9";
                        else if (doubledTensionPcNonMelody == (rootPcNonMelody + 2) % 12) tensionName = "9";
                        else if (doubledTensionPcNonMelody == (rootPcNonMelody + 3) % 12) tensionName = "#9";
                        else if (doubledTensionPcNonMelody == (rootPcNonMelody + 6) % 12) tensionName = "#11";
                        else tensionName = $"pc={doubledTensionPcNonMelody}";
                        
                        UnityEngine.Debug.LogWarning(
                            $"[NO_DOUBLE_TENSION] Reject: tension {tensionName} (pc={doubledTensionPcNonMelody}) occurs {tensionOccurrencesNonMelody[doubledTensionPcNonMelody].Count}x " +
                            $"(voices: {voicesStr}) in chord {chordName} at step {stepIndex} (non-melody path). " +
                            $"Voicing: B={finalVoicesArray[0]}, T={finalVoicesArray[1]}, A={finalVoicesArray[2]}, S={finalVoicesArray[3]}");
                        
                        // Note: In incremental path, we can't easily reject at this point without major refactoring
                        // This warning serves as a diagnostic. The melody-path veto should prevent this in most cases.
                    }
                }
                
                // CHECKPOINT 2: Log voicing array after assembly (non-melody path, before VoicedChord creation)
                var reqForCheckpoint2 = current.Recipe.RequestedExtensions;
                bool hasB9ForCheckpoint2 = reqForCheckpoint2.TensionFlat9;
                bool shouldLogCheckpoint2 = hasB9ForCheckpoint2 || 
                                          (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano && reqForCheckpoint2.TensionFlat9);
                
                if (shouldLogCheckpoint2 && !current.MelodyMidi.HasValue)
                {
                    string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                    UnityEngine.Debug.Log(
                        $"[CHECKPOINT_AFTER_ASSEMBLY] step={stepIndex} chord={chordLabel} (non-melody path, before VoicedChord)\n" +
                        $"  SATB MIDI array: [{string.Join(", ", finalVoicesArray)}]");
                }
                
                // Trace: Log final voicing result (point 4)
                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                {
                    if (req.HasAny)
                    {
                        int rootPc = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                        if (rootPc < 0) rootPc = 0;
                        rootPc = (rootPc + current.Recipe.RootSemitoneOffset + 12) % 12;
                        if (rootPc < 0) rootPc += 12;
                        
                        // Get final voice PCs
                        var voicePcs = new List<int>();
                        var voiceNames = new List<string> { "B", "T", "A", "S" };
                        for (int i = 0; i < finalVoicesArray.Length && i < 4; i++)
                        {
                            voicePcs.Add((finalVoicesArray[i] % 12 + 12) % 12);
                        }
                        
                        // Check which voice contains each requested extension
                        var extensionAssignments = new List<string>();
                        var missingExtensions = new List<string>();
                        var wrongSubstitutions = new List<string>();
                        
                        if (req.TensionFlat9)
                        {
                            int b9Pc = (rootPc + 1) % 12;
                            int ninePc = (rootPc + 2) % 12;
                            bool found = false;
                            for (int i = 0; i < voicePcs.Count; i++)
                            {
                                if (voicePcs[i] == b9Pc)
                                {
                                    extensionAssignments.Add($"b9={b9Pc}→{voiceNames[i]}");
                                    found = true;
                                    break;
                                }
                            }
                            if (!found)
                            {
                                // Check if natural 9 is present instead
                                bool hasNatural9 = voicePcs.Contains(ninePc);
                                if (hasNatural9)
                                {
                                    wrongSubstitutions.Add($"b9={b9Pc} but natural9={ninePc} found");
                                }
                                else
                                {
                                    missingExtensions.Add($"b9={b9Pc}");
                                }
                            }
                        }
                        if (req.Tension9)
                        {
                            int ninePc = (rootPc + 2) % 12;
                            bool found = false;
                            for (int i = 0; i < voicePcs.Count; i++)
                            {
                                if (voicePcs[i] == ninePc)
                                {
                                    extensionAssignments.Add($"9={ninePc}→{voiceNames[i]}");
                                    found = true;
                                    break;
                                }
                            }
                            if (!found)
                            {
                                missingExtensions.Add($"9={ninePc}");
                            }
                        }
                        if (req.TensionSharp11)
                        {
                            int sharp11Pc = (rootPc + 6) % 12;
                            bool found = false;
                            for (int i = 0; i < voicePcs.Count; i++)
                            {
                                if (voicePcs[i] == sharp11Pc)
                                {
                                    extensionAssignments.Add($"#11={sharp11Pc}→{voiceNames[i]}");
                                    found = true;
                                    break;
                                }
                            }
                            if (!found)
                            {
                                missingExtensions.Add($"#11={sharp11Pc}");
                            }
                        }
                        
                        string voicesStr = finalVoicesArray.Length >= 4 
                            ? $"B={finalVoicesArray[0]} T={finalVoicesArray[1]} A={finalVoicesArray[2]} S={finalVoicesArray[3]}"
                            : string.Join(" ", finalVoicesArray.Select((v, i) => $"{voiceNames[i]}={v}"));
                        string pcsStr = string.Join(",", voicePcs);
                        string assignmentsStr = extensionAssignments.Count > 0 ? string.Join(" ", extensionAssignments) : "none";
                        string missingStr = missingExtensions.Count > 0 ? string.Join(" ", missingExtensions) + " ❌" : "none";
                        string wrongStr = wrongSubstitutions.Count > 0 ? string.Join(" ", wrongSubstitutions) + " ❌" : "";
                        
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_TRACE][FINAL] step={stepIndex}\n" +
                            $"  voices: {voicesStr}\n" +
                            $"  pcs: [{pcsStr}]\n" +
                            $"  requested: {assignmentsStr}\n" +
                            $"  missing: {missingStr}" +
                            (wrongStr.Length > 0 ? $"\n  {wrongStr}" : ""));
                    }
                }
            }
            
            // CRITICAL FIX: Use explicit lane assignment for melody path (prevents Tenor/Alto swap)
            // In explicit lane assignment mode, we NEVER sort upperVoices - we extract lanes directly
            // SATB order: [0=Bass, 1=Tenor, 2=Alto, 3=Soprano]
            bool useExplicitLaneAssignment = hasMelody; // Melody path uses explicit lane assignment
            var voicesArray = new int[numVoices];
            int tenorMidiExplicit = -1;
            int altoMidiExplicit = -1;
            int sopranoMidiExplicit = targetSopranoMidi.HasValue ? targetSopranoMidi.Value : -1;
            
            if (useExplicitLaneAssignment)
            {
                // DIAGNOSTIC: Log upperVoices state before extracting lanes
                if (stepIndex == 2)
                {
                    UnityEngine.Debug.Log(
                        $"[SATB_NO_CROSSING_DIAG] BEFORE explicit lane extraction: " +
                        $"upperVoices.Count={upperVoices.Count} " +
                        $"upperVoices=[{string.Join(",", upperVoices.Select(m => $"{m}({TheoryPitch.GetPitchNameFromMidi(m, current.Key)})"))}]");
                }
                
                // Extract Tenor and Alto from upperVoices in the order they were added (NOT sorted)
                // upperVoices should contain [Tenor, Alto] in that order (from BuildUpperVoicesIncrementalWithMelody)
                // CRITICAL: Do NOT rely on sorted order - extract by insertion order
                if (upperVoices.Count >= 2)
                {
                    tenorMidiExplicit = upperVoices[0]; // First added = Tenor
                    altoMidiExplicit = upperVoices[1];  // Second added = Alto
                }
                else if (upperVoices.Count == 1)
                {
                    // Only one voice selected - assume it's Tenor
                    tenorMidiExplicit = upperVoices[0];
                    // Alto will need to be filled or is missing
                }
                
                // Assemble final voicing using explicit lane assignment (prevents lane/index mismatch bugs)
                voicesArray[0] = bassVoice;   // Bass
                voicesArray[1] = tenorMidiExplicit >= 0 ? tenorMidiExplicit : upperMinMidi;  // Tenor
                voicesArray[2] = altoMidiExplicit >= 0 ? altoMidiExplicit : upperMinMidi + 3; // Alto
                voicesArray[3] = sopranoMidiExplicit >= 0 ? sopranoMidiExplicit : upperMinMidi + 12; // Soprano
            }
            else
            {
                // Non-melody path: use sorted upperVoices (implicit ordering)
                // Assemble final voicing from sorted list
                voicesArray[0] = bassVoice;   // Bass
                for (int i = 0; i < upperVoices.Count && i + 1 < numVoices; i++)
                {
                    voicesArray[i + 1] = upperVoices[i]; // Tenor, Alto, Soprano in sorted order
                }
                // Fill remaining voices if needed
                for (int i = upperVoices.Count + 1; i < numVoices; i++)
                {
                    voicesArray[i] = upperMinMidi + (i - 1) * 3;
                }
            }
            
            // LANE_MAP_DBG: Log final SATB assembly for chord IV
            if (stepIndex == 2)
            {
                string roman = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                if (roman == "F" || roman == "IV")
                {
                    string bassName = TheoryPitch.GetPitchNameFromMidi(voicesArray[0], current.Key);
                    string tenorName = TheoryPitch.GetPitchNameFromMidi(voicesArray[1], current.Key);
                    string altoName = TheoryPitch.GetPitchNameFromMidi(voicesArray[2], current.Key);
                    string sopranoName = TheoryPitch.GetPitchNameFromMidi(voicesArray[3], current.Key);
                    string explicitLanesStr = useExplicitLaneAssignment 
                        ? $"explicitLanes=[Tenor={tenorMidiExplicit}, Alto={altoMidiExplicit}, Soprano={sopranoMidiExplicit}]"
                        : "implicitOrdering";
                    UnityEngine.Debug.Log(
                        $"[LANE_MAP_DBG] FinalSATBAssembly chordIndex={stepIndex} roman={roman} " +
                        $"upperVoices=[{string.Join(",", upperVoices.Select(m => $"{m}({TheoryPitch.GetPitchNameFromMidi(m, current.Key)})"))}] " +
                        $"{explicitLanesStr} " +
                        $"SATB=[Bass={voicesArray[0]}({bassName}), Tenor={voicesArray[1]}({tenorName}), Alto={voicesArray[2]}({altoName}), Soprano={voicesArray[3]}({sopranoName})]");
                }
            }
            
            // AUG5_SNAP: Log state after initial voicing assembly (PostInitialSelection) (gated)
            if (s_enableAug5Debug && stepIndex == 2 && voicesArray != null && voicesArray.Length >= 4) // chord IV in repro
            {
                string roman = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                if (roman == "F" || roman == "IV")
                {
                    string bassName = TheoryPitch.GetPitchNameFromMidi(voicesArray[0], current.Key);
                    string tenorName = TheoryPitch.GetPitchNameFromMidi(voicesArray[1], current.Key);
                    string altoName = TheoryPitch.GetPitchNameFromMidi(voicesArray[2], current.Key);
                    string sopranoName = TheoryPitch.GetPitchNameFromMidi(voicesArray[3], current.Key);
                    UnityEngine.Debug.Log(
                        $"[AUG5_SNAP] stage=PostInitialSelection chordIndex={stepIndex} roman={roman} SATB=[Bass={voicesArray[0]}({bassName}), Tenor={voicesArray[1]}({tenorName}), Alto={voicesArray[2]}({altoName}), Soprano={voicesArray[3]}({sopranoName})]");
                }
            }
            
            // CHECKPOINT 1: After initial voicing creation (VoiceNextChord)
            bool? seventhWasPresentNext = null;
            LogSeventhCheckpoint("AfterInitialVoicing", stepIndex, current, voicesArray, false, ref seventhWasPresentNext);
            
            // REGRESSION DIAGNOSTIC: Stage 1 - Post-initial voicing selection (before FixChordToneCoverage)
            string diagnosticToken = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
            LogRequiredChordTonesDiagnostic("PostInitialSelection", stepIndex, current, voicesArray, diagnosticToken);
            
            // STAGE SNAPSHOT: PostInitialSelection for diminished triads
            if (current.Recipe.Quality == ChordQuality.Diminished)
            {
                bool dimTriadHasSeventh = current.Recipe.Extension == ChordExtension.Seventh &&
                                          current.Recipe.SeventhQuality != SeventhQuality.None;
                if (!dimTriadHasSeventh) // Only triads, not dim7
                {
                    var dimTriadChordTonePcs = GetChordTonePitchClasses(current);
                    if (dimTriadChordTonePcs != null && dimTriadChordTonePcs.Count >= 3)
                    {
                        int dimTriadRootPc = dimTriadChordTonePcs[0];
                        int dimTriadThirdPc = dimTriadChordTonePcs[1];
                        int dimTriadFifthPc = dimTriadChordTonePcs[2];
                        int dimTriadThirdInterval = (dimTriadThirdPc - dimTriadRootPc + 12) % 12;
                        int dimTriadFifthInterval = (dimTriadFifthPc - dimTriadRootPc + 12) % 12;
                        if (dimTriadThirdInterval == 3 && dimTriadFifthInterval == 6) // Valid dim triad
                        {
                            var requiredIdentityPcs = new HashSet<int> { dimTriadRootPc, dimTriadThirdPc, dimTriadFifthPc };
                            string label = regionDebugLabel ?? diagnosticToken;
                            LogStageSnapshot_DimTriad(
                                "PostInitialSelection",
                                stepIndex,
                                diagnosticToken,
                                label,
                                voicesArray,
                                requiredIdentityPcs,
                                current.Key);
                        }
                    }
                }
            }
            
            // TRACE: After candidate selection, before PostSelectionEnforcement
            {
                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                string debugLabel = regionDebugLabel ?? label;
                TraceDumpSATB("Selected (pre-enforcement)", stepIndex, label, debugLabel, voicesArray, chordTonePcsSet, current.Key, diags);
            }
            
            // Compute spacing penalty for complete SATB voicing (for diagnostics)
            // Note: This is computed after selection, so it doesn't influence selection in the current incremental architecture
            if (voicesArray.Length >= 4)
            {
                int candidateBass = voicesArray[0];
                int candidateTenor = voicesArray[1];
                int candidateAlto = voicesArray[2];
                int candidateSoprano = voicesArray[3];
                
                float spacingPenalty = GetSpacingPenalty(candidateBass, candidateTenor, candidateAlto, candidateSoprano);
                if (spacingPenalty != 0f && GetTendencyDebug())
                {
                    UnityEngine.Debug.Log(
                        $"[Spacing Soft] B={candidateBass}, T={candidateTenor}, A={candidateAlto}, S={candidateSoprano}, penalty={spacingPenalty}");
                }
            }
            
            // Fix chord tone coverage: ensure required tones are present
            // NOTE: This only modifies upper voices (indices 1..N-1); bass (index 0) remains unchanged.
            // When melody is present, soprano (highest voice) is also protected and not modified.
            bool melodyLocked = current.MelodyMidi.HasValue;
            bool noMelody = !current.MelodyMidi.HasValue;
            
            // Track which voices have hard-locked 7th resolutions (to protect them from fix-up logic)
            // lockedResolutionVoices[i] = true means voicesArray[i] should not be modified by FixChordToneCoverage
            bool[] lockedResolutionVoices = new bool[voicesArray.Length];
            
            // Post-selection enforcement: Force 7th resolution (inner voices always, soprano when no melody)
            // This overrides the cost-based selection to ensure correct 7th resolution even when
            // other candidates would have won based on cost alone.
            // We use voiceSelectionMap to track which selected MIDI corresponds to which previous voice index.
            if (voicesArray.Length >= 4 && voiceSelectionMap.Count > 0)
            {
                // Get chord tone pitch classes for resolution checking
                var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                
                // Determine max voice index to check: include soprano when there's no melody
                int maxVoiceIndexToCheck = voicesArray.Length - 1; // Include soprano by default
                if (melodyLocked && !noMelody)
                {
                    maxVoiceIndexToCheck = voicesArray.Length - 2; // Exclude soprano when melody is locked
                }
                
                // After sorting, match voices to their previous voice indices
                // by finding which selected MIDI in voicesArray matches which entry in voiceSelectionMap
                for (int voiceArrayIndex = 1; voiceArrayIndex <= maxVoiceIndexToCheck; voiceArrayIndex++)
                {
                    int selectedMidi = voicesArray[voiceArrayIndex];
                    
                    // Find which previous voice index this selected MIDI corresponds to
                    int matchingPrevVoiceIndex = -1;
                    foreach (var kvp in voiceSelectionMap)
                    {
                        if (kvp.Value == selectedMidi)
                        {
                            matchingPrevVoiceIndex = kvp.Key;
                            break;
                        }
                    }
                    
                    // If we found a match and that previous voice was a 7th, enforce resolution
                    if (matchingPrevVoiceIndex >= 0 && 
                        matchingPrevVoiceIndex < tendencyInfos.Length && 
                        matchingPrevVoiceIndex < prevUpper.Count)
                    {
                        var tendencyInfo = tendencyInfos[matchingPrevVoiceIndex];
                        
                        if (tendencyInfo.isChordSeventh)
                        {
                            int prevMidi = prevUpper[matchingPrevVoiceIndex];
                            int prevPc = (prevMidi % 12 + 12) % 12;
                            
                            // Determine valid resolution pitch classes (1-2 semitones down)
                            int resolutionPc1 = (prevPc + 11) % 12;   // -1 semitone
                            int resolutionPc2 = (prevPc + 10) % 12;   // -2 semitones
                            
                            // Check if the next chord contains either resolution pitch class
                            bool hasResolutionTone = chordTonePcsSet.Contains(resolutionPc1) || chordTonePcsSet.Contains(resolutionPc2);
                            
                            if (hasResolutionTone)
                            {
                                // Determine voice range for this voice
                                int voiceMinMidi = upperMinMidi;
                                int voiceMaxMidi = upperMaxMidi;
                                
                                // Check if this is the soprano voice (last voice index)
                                bool isSopranoVoice = (voiceArrayIndex == voicesArray.Length - 1);
                                
                                // For inner voices (Tenor/Alto), allow them to dip below upperMinMidi for 7th resolution
                                // This is similar to how TryBuildUpperVoicesWithMelodyFullSearch allows tenor to go an octave below
                                if (!isSopranoVoice)
                                {
                                    // Allow inner voices to go an octave below upperMinMidi for 7th resolution
                                    // Use the minimum of (bass+1) and (upperMinMidi-12) to allow going below bass if needed
                                    // This ensures we can resolve 7ths even when bass is high
                                    int minFromBass = voicesArray[0] + 1;
                                    int minFromUpper = upperMinMidi - 12;
                                    voiceMinMidi = Math.Min(minFromBass, minFromUpper);
                                    // But ensure it's at least above a reasonable absolute minimum (e.g., C3 = 48)
                                    voiceMinMidi = Math.Max(voiceMinMidi, 48);
                                }
                                
                                // If melody is present, inner voices must stay below it; soprano uses full range
                                if (targetSopranoMidi.HasValue && !isSopranoVoice)
                                {
                                    voiceMaxMidi = Math.Min(voiceMaxMidi, targetSopranoMidi.Value - 1);
                                }
                                
                                // Try to find a downward resolution (prioritize resolutionPc1, then resolutionPc2)
                                int resolutionMidi = -1;
                                
                                // Try resolutionPc1 first (more common -1 semitone resolution)
                                if (chordTonePcsSet.Contains(resolutionPc1))
                                {
                                    resolutionMidi = FindDownwardSeventhResolution(prevMidi, resolutionPc1, voiceMinMidi, voiceMaxMidi);
                                }
                                
                                // Try resolutionPc2 if resolutionPc1 didn't yield a result
                                if (resolutionMidi < 0 && chordTonePcsSet.Contains(resolutionPc2))
                                {
                                    resolutionMidi = FindDownwardSeventhResolution(prevMidi, resolutionPc2, voiceMinMidi, voiceMaxMidi);
                                }
                                
                                // Verify that the resolution MIDI's pitch class is actually in the destination chord
                                if (resolutionMidi >= 0)
                                {
                                    int resolutionPc = (resolutionMidi % 12 + 12) % 12;
                                    bool isAllowed = chordTonePcsSet.Contains(resolutionPc);
                                    string voiceLabel = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : $"Voice{voiceArrayIndex}");
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(prevMidi, current.Key);
                                    string proposedName = TheoryPitch.GetPitchNameFromMidi(resolutionMidi, current.Key);
                                    string proposedPcName = TheoryPitch.GetPitchNameFromMidi(resolutionPc + 60, current.Key);
                                    string allowedSet = GetAllowedDestinationPCsString(chordTonePcs, current.Key);
                                    string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                    
                                    // Build diagnostic message
                                    var diagMsg = new System.Text.StringBuilder();
                                    diagMsg.Append($"R{stepIndex} {chordLabel} V={voiceLabel}: {prevName}({prevMidi})->{proposedName}({resolutionMidi}) ");
                                    diagMsg.Append($"proposedPC={proposedPcName} allowed={allowedSet} isAllowed={isAllowed}");
                                    
                                    if (!isAllowed)
                                    {
                                        // Illegal resolution - try to redirect or block
                                        int redirectedMidi = TryRedirectResolution(prevMidi, resolutionPc, chordTonePcsSet, voiceMinMidi, voiceMaxMidi);
                                        
                                        if (redirectedMidi >= 0)
                                        {
                                            int redirectDelta = redirectedMidi - prevMidi;
                                            string redirectedName = TheoryPitch.GetPitchNameFromMidi(redirectedMidi, current.Key);
                                            diagMsg.Append($" redirect=delta:{redirectDelta:+0;-0}->{redirectedName}({redirectedMidi})");
                                        }
                                        else
                                        {
                                            diagMsg.Append(" blocked=true");
                                        }
                                        
                                        // Emit diagnostic before processing
                                        if (diags != null)
                                        {
                                            diags.Add(stepIndex, DiagSeverity.Warning, DiagCode.RESOLUTION_CHECK,
                                                diagMsg.ToString(),
                                                voiceIndex: voiceArrayIndex, beforeMidi: prevMidi, afterMidi: resolutionMidi);
                                        }
                                        
                                        if (redirectedMidi >= 0)
                                        {
                                            // TRACE: Log redirect
                                            if (ShouldTraceRegion(stepIndex, diags))
                                            {
                                                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                                string voiceName = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : $"Voice{voiceArrayIndex}");
                                                int redirectDelta = redirectedMidi - prevMidi;
                                                int redirectedPc = ((redirectedMidi % 12) + 12) % 12;
                                                bool redirectedOk = chordTonePcsSet.Contains(redirectedPc);
                                                UnityEngine.Debug.Log(
                                                    $"[TRACE] R{stepIndex} {label} :: Enforcement REDIRECTED v={voiceArrayIndex} " +
                                                    $"from={prevMidi}({TheoryPitch.GetPitchNameFromMidi(prevMidi, current.Key)}) " +
                                                    $"to={redirectedMidi}({TheoryPitch.GetPitchNameFromMidi(redirectedMidi, current.Key)}) pc={redirectedPc} " +
                                                    (redirectedOk ? "" : "[ILLEGAL]")
                                                );
                                            }
                                            resolutionMidi = redirectedMidi;
                                        }
                                        else
                                        {
                                            // TRACE: Log block
                                            if (ShouldTraceRegion(stepIndex, diags))
                                            {
                                                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                                string debugLabel = regionDebugLabel ?? label;
                                                string voiceName = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : $"Voice{voiceArrayIndex}");
                                                UnityEngine.Debug.Log(
                                                    $"[TRACE] R{stepIndex} label='{debugLabel}' chord={label} :: Enforcement BLOCKED v={voiceArrayIndex} " +
                                                    $"kept={prevMidi}({TheoryPitch.GetPitchNameFromMidi(prevMidi, current.Key)})"
                                                );
                                            }
                                            resolutionMidi = -1; // Block the resolution
                                        }
                                    }
                                    else
                                    {
                                        // Legal resolution - emit diagnostic
                                        if (diags != null)
                                        {
                                            diags.Add(stepIndex, DiagSeverity.Warning, DiagCode.RESOLUTION_CHECK,
                                                diagMsg.ToString(),
                                                voiceIndex: voiceArrayIndex, beforeMidi: prevMidi, afterMidi: resolutionMidi);
                                        }
                                        
                                        // Optionally log as applied legal resolution (when debug enabled)
                                        if (diags != null && enableTendencyDebug)
                                        {
                                            diags.Add(stepIndex, DiagSeverity.Info, DiagCode.APPLIED_LEGAL_RESOLUTION,
                                                $"Applied legal resolution {prevName}→{proposedName} ({voiceLabel})",
                                                voiceIndex: voiceArrayIndex, beforeMidi: prevMidi, afterMidi: resolutionMidi);
                                        }
                                    }
                                }
                                
                                // If we found a valid resolution MIDI and the current choice is different, override it
                                // But only if it doesn't break spacing or create tripled notes
                                if (resolutionMidi < 0)
                                {
                                    // TRACE: Log skip (no resolution found)
                                    if (ShouldTraceRegion(stepIndex, diags))
                                    {
                                        string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                        string debugLabel = regionDebugLabel ?? label;
                                        string voiceName = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : $"Voice{voiceArrayIndex}");
                                        UnityEngine.Debug.Log(
                                            $"[TRACE] R{stepIndex} label='{debugLabel}' chord={label} :: Enforcement SKIPPED v={voiceArrayIndex} " +
                                            $"(no resolution found), kept={selectedMidi}({TheoryPitch.GetPitchNameFromMidi(selectedMidi, current.Key)})"
                                        );
                                    }
                                }
                                else if (resolutionMidi >= 0 && selectedMidi != resolutionMidi)
                                {
                                    // TRACE: Instrument the actual mutation site
                                    if (ShouldTraceRegion(stepIndex, diags))
                                    {
                                        string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                        int before = voicesArray[voiceArrayIndex];
                                        int beforePc = ((before % 12) + 12) % 12;
                                        int afterPc = ((resolutionMidi % 12) + 12) % 12;
                                        bool afterOk = chordTonePcsSet.Contains(afterPc);
                                        
                                        UnityEngine.Debug.Log(
                                            $"[TRACE] R{stepIndex} {label} :: Enforcement mutate v={voiceArrayIndex} " +
                                            $"before={before}({TheoryPitch.GetPitchNameFromMidi(before, current.Key)}) pc={beforePc} -> " +
                                            $"after={resolutionMidi}({TheoryPitch.GetPitchNameFromMidi(resolutionMidi, current.Key)}) pc={afterPc} " +
                                            (afterOk ? "" : "[ILLEGAL]")
                                        );
                                    }
                                    
                                    int oldMidi = voicesArray[voiceArrayIndex];
                                    voicesArray[voiceArrayIndex] = resolutionMidi;
                                    
                                    // Check if this breaks spacing
                                    bool breaksSpacing = voicesArray.Length >= 4 &&
                                                         ViolatesHardSpacing(voicesArray[0], voicesArray[1], voicesArray[2], voicesArray[3]);
                                    
                                    // Check if this creates tripled notes (for triads, maxCount must be <= 2)
                                    bool createsTripledNotes = false;
                                    bool chordHasSeventhForResolution = current.Recipe.Extension == ChordExtension.Seventh &&
                                                                        current.Recipe.SeventhQuality != SeventhQuality.None;
                                    if (!chordHasSeventhForResolution) // Only check for triads
                                    {
                                        var tempPcCounts = new Dictionary<int, int>();
                                        foreach (int m in voicesArray)
                                        {
                                            int pc = (m % 12 + 12) % 12;
                                            if (!tempPcCounts.TryGetValue(pc, out int cnt)) cnt = 0;
                                            tempPcCounts[pc] = cnt + 1;
                                        }
                                        
                                        int maxCount = 0;
                                        foreach (var kvp in tempPcCounts)
                                        {
                                            maxCount = Math.Max(maxCount, kvp.Value);
                                        }
                                        
                                        // For triads, reject if any pitch class appears 3+ times
                                        createsTripledNotes = maxCount > 2;
                                    }
                                    
                                    if (breaksSpacing || createsTripledNotes)
                                    {
                                        // Revert if it breaks spacing or creates tripled notes
                                        voicesArray[voiceArrayIndex] = oldMidi;
                                        
                                        // TRACE: Log rejection
                                        if (ShouldTraceRegion(stepIndex, diags))
                                        {
                                            string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                            string debugLabel = regionDebugLabel ?? label;
                                            string voiceName = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : $"Voice{voiceArrayIndex}");
                                            string reason = breaksSpacing ? "spacing" : "tripled notes";
                                            TraceLog($"[TRACE] R{stepIndex} label='{debugLabel}' chord={label} :: Enforcement BLOCKED v={voiceArrayIndex} (breaks {reason}), kept {oldMidi}", diags);
                                        }
                                        
                                        if (enableTendencyDebug)
                                        {
                                            string voiceLabel = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : "Voice" + voiceArrayIndex);
                                            string reason = breaksSpacing ? "spacing" : "tripled notes";
                                            UnityEngine.Debug.LogWarning(
                                                $"[7th Resolution] Rejected forced resolution {resolutionMidi} " +
                                                $"in voice {voiceArrayIndex} ({voiceLabel}) because it breaks {reason}.");
                                        }
                                    }
                                    else
                                    {
                                        // TRACE: Log successful application
                                        if (enableTraceLogs)
                                        {
                                            string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                                            if (ShouldTrace(label))
                                            {
                                                string voiceName = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : $"Voice{voiceArrayIndex}");
                                                // Log SATB after this change
                                                var sbAfter = new System.Text.StringBuilder();
                                                sbAfter.AppendLine($"[TRACE]   SATB after this change:");
                                                for (int v = 0; v < voicesArray.Length; v++)
                                                {
                                                    int m = voicesArray[v];
                                                    string n = TheoryPitch.GetPitchNameFromMidi(m, current.Key);
                                                    string vl = (v == 0) ? "Bass" : (v == 1) ? "Tenor" : (v == 2) ? "Alto" : "Soprano";
                                                    sbAfter.Append($"    {vl}: {m}→{n} ");
                                                }
                                                UnityEngine.Debug.Log(sbAfter.ToString());
                                            }
                                        }
                                        
                                        // Keep it, and log as before
                                        if (enableTendencyDebug)
                                        {
                                            string voiceLabel = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : "Voice" + voiceArrayIndex);
                                            string prevName = TheoryPitch.GetPitchNameFromMidi(prevMidi, current.Key);
                                            string resolutionName = TheoryPitch.GetPitchNameFromMidi(resolutionMidi, current.Key);
                                            string beforeName = TheoryPitch.GetPitchNameFromMidi(selectedMidi, current.Key);
                                            UnityEngine.Debug.Log($"[Tendency Debug] Forcing 7th resolution: voice={voiceLabel}, prev={prevName}({prevMidi}) -> forced={resolutionName}({resolutionMidi}) (was {beforeName}({selectedMidi}))");
                                        }
                                        
                                        // Add diagnostic event for forced 7th resolution
                                        // Note: stepIndex is available in the outer scope
                                        if (diags != null)
                                        {
                                            string voiceLabel = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : $"Voice{voiceArrayIndex}");
                                            string resolutionName = TheoryPitch.GetPitchNameFromMidi(resolutionMidi, current.Key);
                                            diags.Add(stepIndex, DiagSeverity.Forced, DiagCode.FORCED_7TH_RESOLUTION, 
                                                $"Resolved 7th down by step ({voiceLabel}: {resolutionName})", 
                                                voiceIndex: voiceArrayIndex, beforeMidi: selectedMidi, afterMidi: resolutionMidi);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // TRACE: After PostSelectionEnforcement (complete pass)
            {
                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                string debugLabel = regionDebugLabel ?? label;
                TraceDumpSATB("After PostSelectionEnforcement", stepIndex, label, debugLabel, voicesArray, chordTonePcsSet, current.Key, diags);
            }
            
            // Detect and lock voices with hard 7th resolutions (to protect them from fix-up logic)
            // Check each voice (inner voices, and soprano if no melody) to see if it represents a hard-locked 7th resolution
            // We check all previous voices to see if any of them was a 7th that resolves to this voice's current MIDI
            // Note: noMelody is already defined above
            var chordTonePcsSetForLock = new HashSet<int>(chordTonePcs);
            // Include soprano in locking logic when there's no melody (so it can be locked like inner voices)
            int maxVoiceIndexForLocking = voicesArray.Length - 1; // Include all voices (soprano is last)
            if (melodyLocked && !noMelody)
            {
                maxVoiceIndexForLocking = voicesArray.Length - 2; // Exclude soprano when melody is locked
            }
            for (int voiceArrayIndex = 1; voiceArrayIndex <= maxVoiceIndexForLocking; voiceArrayIndex++)
            {
                int selectedMidi = voicesArray[voiceArrayIndex];
                int selectedPc = (selectedMidi % 12 + 12) % 12;
                
                // Check each previous voice to see if this could be its 7th resolution
                for (int prevVoiceIdx = 0; prevVoiceIdx < prevUpper.Count && prevVoiceIdx < tendencyInfos.Length; prevVoiceIdx++)
                {
                    var tendencyInfo = tendencyInfos[prevVoiceIdx];
                    
                    // Skip if this previous voice wasn't a 7th
                    if (!tendencyInfo.isChordSeventh)
                        continue;
                    
                    int prevMidi = prevUpper[prevVoiceIdx];
                    int prevPc = (prevMidi % 12 + 12) % 12;
                    
                    // Determine valid resolution pitch classes (1-2 semitones down)
                    int resolutionPc1 = (prevPc + 11) % 12;   // -1 semitone
                    int resolutionPc2 = (prevPc + 10) % 12;   // -2 semitones
                    
                    // Check if the current voice's pitch class is a valid resolution for this 7th
                    bool isResolvingToThisVoice = (selectedPc == resolutionPc1 || selectedPc == resolutionPc2);
                    
                    if (isResolvingToThisVoice)
                    {
                        // Check if the next chord contains this resolution pitch class
                        bool hasResolutionTone = chordTonePcsSetForLock.Contains(resolutionPc1) || chordTonePcsSetForLock.Contains(resolutionPc2);
                        
                        if (hasResolutionTone)
                        {
                            // Determine voice range for checking
                            int voiceMinMidi = upperMinMidi;
                            int voiceMaxMidi = upperMaxMidi;
                            
                            // Check if this is the soprano voice (last voice index)
                            bool isSopranoVoice = (voiceArrayIndex == voicesArray.Length - 1);
                            
                            // For inner voices (Tenor/Alto), allow them to dip below upperMinMidi for 7th resolution
                            // This is similar to how TryBuildUpperVoicesWithMelodyFullSearch allows tenor to go an octave below
                            if (!isSopranoVoice)
                            {
                                // Allow inner voices to go an octave below upperMinMidi for 7th resolution
                                // Use the minimum of (bass+1) and (upperMinMidi-12) to allow going below bass if needed
                                // This ensures we can resolve 7ths even when bass is high
                                int minFromBass = voicesArray[0] + 1;
                                int minFromUpper = upperMinMidi - 12;
                                voiceMinMidi = Math.Min(minFromBass, minFromUpper);
                                // But ensure it's at least above a reasonable absolute minimum (e.g., C3 = 48)
                                voiceMinMidi = Math.Max(voiceMinMidi, 48);
                            }
                            
                            // If melody is present, inner voices must stay below it; soprano uses full range
                            if (targetSopranoMidi.HasValue && !isSopranoVoice)
                            {
                                voiceMaxMidi = Math.Min(voiceMaxMidi, targetSopranoMidi.Value - 1);
                            }
                            
                            // Try to find the expected downward resolution MIDI
                            int expectedResolutionMidi = -1;
                            
                            // Try resolutionPc1 first
                            if (chordTonePcsSetForLock.Contains(resolutionPc1))
                            {
                                expectedResolutionMidi = FindDownwardSeventhResolution(prevMidi, resolutionPc1, voiceMinMidi, voiceMaxMidi);
                            }
                            
                            // Try resolutionPc2 if resolutionPc1 didn't yield a result
                            if (expectedResolutionMidi < 0 && chordTonePcsSetForLock.Contains(resolutionPc2))
                            {
                                expectedResolutionMidi = FindDownwardSeventhResolution(prevMidi, resolutionPc2, voiceMinMidi, voiceMaxMidi);
                            }
                            
                            // If the selected MIDI matches the expected resolution AND a valid resolution exists in range,
                            // this means Rule A HARD was applied (or post-selection enforcement forced it), so lock this voice
                            if (expectedResolutionMidi >= 0 && selectedMidi == expectedResolutionMidi)
                            {
                                lockedResolutionVoices[voiceArrayIndex] = true;
                                
                                if (enableTendencyDebug)
                                {
                                    string voiceLabel = (voiceArrayIndex == 1) ? "Tenor" : (voiceArrayIndex == 2) ? "Alto" : (isSopranoVoice ? "Soprano" : "Voice" + voiceArrayIndex);
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(prevMidi, current.Key);
                                    string resolutionName = TheoryPitch.GetPitchNameFromMidi(selectedMidi, current.Key);
                                    UnityEngine.Debug.Log($"[Voicing Debug] Locking 7th resolution in voice {voiceArrayIndex} ({voiceLabel}) at step {stepIndex}: prev={prevName}({prevMidi}), chosen={resolutionName}({selectedMidi})");
                                }
                                
                                // Break after finding a match (each voice can only resolve one 7th)
                                break;
                            }
                        }
                    }
                }
            }
            
            // Debug logging before FixChordToneCoverage
            if (enableTendencyDebug && stepIndex >= 0)
            {
                var sbBefore = new System.Text.StringBuilder();
                sbBefore.Append($"[Voicing Debug] Step {stepIndex} BEFORE FixChordToneCoverage: ");
                for (int v = 0; v < voicesArray.Length; v++)
                {
                    int midi = voicesArray[v];
                    string name = TheoryPitch.GetPitchNameFromMidi(midi, current.Key);
                    string voiceLabel = (v == 0) ? "Bass" : (v == 1) ? "Tenor" : (v == 2) ? "Alto" : "Soprano";
                    sbBefore.Append($"{voiceLabel}={name}({midi}) ");
                }
                UnityEngine.Debug.Log(sbBefore.ToString());
            }
            
            // Protect soprano when melody is present (mirror VoiceFirstChord behavior)
            bool protectSoprano = current.MelodyMidi.HasValue;
            
            // TRACE 5: Before FixChordToneCoverage
            if (enableTraceLogs)
            {
                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                if (ShouldTrace(label))
                {
                    var sb = new System.Text.StringBuilder();
                    sb.AppendLine($"[TRACE] R{stepIndex} {label}: SATB before FixChordToneCoverage:");
                    for (int v = 0; v < voicesArray.Length; v++)
                    {
                        int midi = voicesArray[v];
                        string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, current.Key);
                        string voiceLabel = (v == 0) ? "Bass" : (v == 1) ? "Tenor" : (v == 2) ? "Alto" : "Soprano";
                        sb.AppendLine($"  {voiceLabel}: {midi}→{pitchName}");
                    }
                    UnityEngine.Debug.Log(sb.ToString());
                }
            }
            
            // Trace: Log entry into FixChordToneCoverage
            if (s_debugTensionDetect && stepIndex >= 0 && !current.MelodyMidi.HasValue)
            {
                UnityEngine.Debug.Log($"[PLAY_TRACE] step={stepIndex} entering FixChordToneCoverage(...)");
            }
            
            // Debug logging: BEFORE FixChordToneCoverage (for subsequent chords)
            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
            {
                var pcsBefore = new HashSet<int>();
                foreach (int m in voicesArray)
                    pcsBefore.Add((m % 12 + 12) % 12);
                string pcsBeforeStr = string.Join(",", pcsBefore.OrderBy(x => x));
                string token = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                UnityEngine.Debug.Log(
                    $"[PLAY_DEBUG] Chord {stepIndex} BEFORE FixChordToneCoverage:\n" +
                    $"  originalToken='{token}'\n" +
                    $"  voicesArray=[{string.Join(",", voicesArray)}]\n" +
                    $"  realizedPCs=[{pcsBeforeStr}]");
            }
            
            FixChordToneCoverage(current, voicesArray, numVoices, upperMinMidi, upperMaxMidi, protectSoprano, lockedResolutionVoices, stepIndex);
            
            // CHECKPOINT 2: After FixChordToneCoverage (VoiceNextChord)
            LogSeventhCheckpoint("AfterFixChordToneCoverage", stepIndex, current, voicesArray, seventhWasPresentNext ?? false, ref seventhWasPresentNext);
            
            // REGRESSION DIAGNOSTIC: Stage 2 - Post-FixChordToneCoverage
            string diagnosticToken2 = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
            LogRequiredChordTonesDiagnostic("PostFixCoverage", stepIndex, current, voicesArray, diagnosticToken2);
            
            // STAGE SNAPSHOT: PostFixCoverage for diminished triads
            if (current.Recipe.Quality == ChordQuality.Diminished)
            {
                bool dimTriadHasSeventh = current.Recipe.Extension == ChordExtension.Seventh &&
                                          current.Recipe.SeventhQuality != SeventhQuality.None;
                if (!dimTriadHasSeventh) // Only triads, not dim7
                {
                    var dimTriadChordTonePcs = GetChordTonePitchClasses(current);
                    if (dimTriadChordTonePcs != null && dimTriadChordTonePcs.Count >= 3)
                    {
                        int dimTriadRootPc = dimTriadChordTonePcs[0];
                        int dimTriadThirdPc = dimTriadChordTonePcs[1];
                        int dimTriadFifthPc = dimTriadChordTonePcs[2];
                        int dimTriadThirdInterval = (dimTriadThirdPc - dimTriadRootPc + 12) % 12;
                        int dimTriadFifthInterval = (dimTriadFifthPc - dimTriadRootPc + 12) % 12;
                        if (dimTriadThirdInterval == 3 && dimTriadFifthInterval == 6) // Valid dim triad
                        {
                            var requiredIdentityPcs = new HashSet<int> { dimTriadRootPc, dimTriadThirdPc, dimTriadFifthPc };
                            string label = regionDebugLabel ?? diagnosticToken2;
                            LogStageSnapshot_DimTriad(
                                "PostFixCoverage",
                                stepIndex,
                                diagnosticToken2,
                                label,
                                voicesArray,
                                requiredIdentityPcs,
                                current.Key);
                        }
                    }
                }
            }
            
            // Debug logging: AFTER FixChordToneCoverage (for subsequent chords)
            if (s_debugTensionDetect && stepIndex >= 0)
            {
                var pcsAfter = new HashSet<int>();
                foreach (int m in voicesArray)
                    pcsAfter.Add((m % 12 + 12) % 12);
                string pcsAfterStr = string.Join(",", pcsAfter.OrderBy(x => x));
                var req = current.Recipe.RequestedExtensions;
                int rootPc = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                if (rootPc < 0) rootPc = 0;
                rootPc = (rootPc + current.Recipe.RootSemitoneOffset + 12) % 12;
                if (rootPc < 0) rootPc += 12;
                int b9Pc = (rootPc + 1) % 12;
                bool b9Present = pcsAfter.Contains(b9Pc);
                string token = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                // High-level summary for missing tensions (always on)
                if (req.TensionFlat9 && !b9Present)
                {
                    UnityEngine.Debug.LogWarning($"WARNING: {token} missing requested tension b9");
                }
                
                // Verbose details (gated)
                if (s_debugTensionVerbose && s_debugTensionDetect)
                {
                    UnityEngine.Debug.Log(
                        $"[PLAY_DEBUG] Chord {stepIndex} AFTER FixChordToneCoverage:\n" +
                        $"  originalToken='{token}'\n" +
                        $"  FixChordToneCoverage called=true\n" +
                        $"  voicesArray=[{string.Join(",", voicesArray)}]\n" +
                        $"  finalRealizedPCs=[{pcsAfterStr}]\n" +
                        $"  RequestedExtensions.b9={req.TensionFlat9}, b9PC={b9Pc}, b9Present={b9Present}");
                }
            }
            
            // TRACE: After FixChordToneCoverage
            {
                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                string debugLabel = regionDebugLabel ?? label;
                TraceDumpSATB("After FixChordToneCoverage", stepIndex, label, debugLabel, voicesArray, chordTonePcsSet, current.Key, diags);
            }
            
            // Compute spacing penalty after FixChordToneCoverage (for diagnostics)
            if (voicesArray.Length >= 4)
            {
                int finalBass = voicesArray[0];
                int finalTenor = voicesArray[1];
                int finalAlto = voicesArray[2];
                int finalSoprano = voicesArray[3];
                
                float spacingPenalty = GetSpacingPenalty(finalBass, finalTenor, finalAlto, finalSoprano);
                if (spacingPenalty != 0f && GetTendencyDebug())
                {
                    UnityEngine.Debug.Log(
                        $"[Spacing Soft] After FixChordToneCoverage: B={finalBass}, T={finalTenor}, A={finalAlto}, S={finalSoprano}, penalty={spacingPenalty}");
                }
            }
            
            // Debug logging after FixChordToneCoverage
            if (enableTendencyDebug && stepIndex >= 0)
            {
                var sbAfter = new System.Text.StringBuilder();
                sbAfter.Append($"[Voicing Debug] Step {stepIndex} AFTER FixChordToneCoverage: ");
                for (int v = 0; v < voicesArray.Length; v++)
                {
                    int midi = voicesArray[v];
                    string name = TheoryPitch.GetPitchNameFromMidi(midi, current.Key);
                    string voiceLabel = (v == 0) ? "Bass" : (v == 1) ? "Tenor" : (v == 2) ? "Alto" : "Soprano";
                    sbAfter.Append($"{voiceLabel}={name}({midi}) ");
                }
                UnityEngine.Debug.Log(sbAfter.ToString());
            }

            // NO DOUBLED TENSIONS VALIDATION: Check if any tension appears in multiple voices
            // This is a hard veto - if doubled tensions are found, we need to reject this voicing
            if (voicesArray.Length >= 4)
            {
                // Build tension pitch class set for this chord
                var tensionPcSetForValidation = new HashSet<int>();
                var reqForValidation = current.Recipe.RequestedExtensions;
                int rootPcForTensionValidation = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                if (rootPcForTensionValidation < 0) rootPcForTensionValidation = 0;
                rootPcForTensionValidation = (rootPcForTensionValidation + current.Recipe.RootSemitoneOffset + 12) % 12;
                if (rootPcForTensionValidation < 0) rootPcForTensionValidation += 12;
                
                // Add requested tensions
                if (reqForValidation.TensionFlat9) tensionPcSetForValidation.Add((rootPcForTensionValidation + 1) % 12);
                if (reqForValidation.Tension9) tensionPcSetForValidation.Add((rootPcForTensionValidation + 2) % 12);
                if (reqForValidation.TensionSharp9) tensionPcSetForValidation.Add((rootPcForTensionValidation + 3) % 12);
                if (reqForValidation.TensionSharp11) tensionPcSetForValidation.Add((rootPcForTensionValidation + 6) % 12);
                if (reqForValidation.Add9) tensionPcSetForValidation.Add((rootPcForTensionValidation + 2) % 12);
                if (reqForValidation.Add11) tensionPcSetForValidation.Add((rootPcForTensionValidation + 5) % 12);
                
                // Also include natural 9 from dominant 7th extensions (e.g., V9)
                bool chordHasSeventhForValidation = current.Recipe.Extension == ChordExtension.Seventh &&
                                                   current.Recipe.SeventhQuality != SeventhQuality.None;
                if (chordHasSeventhForValidation && current.Recipe.SeventhQuality == SeventhQuality.Dominant7 && 
                    !reqForValidation.TensionFlat9 && !reqForValidation.TensionSharp9)
                {
                    tensionPcSetForValidation.Add((rootPcForTensionValidation + 2) % 12);
                }
                
                // Check for doubled tensions
                bool hasDoubledTension = false;
                int doubledTensionPcForValidation = -1;
                var tensionOccurrencesForValidation = new Dictionary<int, List<string>>();
                
                foreach (int tensionPc in tensionPcSetForValidation)
                {
                    int count = 0;
                    var voicesWithTension = new List<string>();
                    
                    for (int v = 0; v < voicesArray.Length; v++)
                    {
                        int voicePc = (voicesArray[v] % 12 + 12) % 12;
                        if (voicePc == tensionPc)
                        {
                            count++;
                            string voiceName = v == 0 ? "Bass" : v == 1 ? "Tenor" : v == 2 ? "Alto" : "Soprano";
                            voicesWithTension.Add(voiceName);
                        }
                    }
                    
                    if (count > 1)
                    {
                        hasDoubledTension = true;
                        doubledTensionPcForValidation = tensionPc;
                        tensionOccurrencesForValidation[tensionPc] = voicesWithTension;
                        break;
                    }
                }
                
                if (hasDoubledTension)
                {
                    // This should not happen if the veto in candidate evaluation is working correctly
                    // But log it as a warning for debugging
                    string chordName = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                    string voicesStr = string.Join(",", tensionOccurrencesForValidation[doubledTensionPcForValidation]);
                    string tensionName = "";
                    if (doubledTensionPcForValidation == (rootPcForTensionValidation + 1) % 12) tensionName = "b9";
                    else if (doubledTensionPcForValidation == (rootPcForTensionValidation + 2) % 12) tensionName = "9";
                    else if (doubledTensionPcForValidation == (rootPcForTensionValidation + 3) % 12) tensionName = "#9";
                    else if (doubledTensionPcForValidation == (rootPcForTensionValidation + 6) % 12) tensionName = "#11";
                    else tensionName = $"pc={doubledTensionPcForValidation}";
                    
                    UnityEngine.Debug.LogWarning(
                        $"[NO_DOUBLE_TENSION] WARNING: Doubled tension {tensionName} (pc={doubledTensionPcForValidation}) detected in final voicing " +
                        $"(voices: {voicesStr}) for chord {chordName} at step {stepIndex}. " +
                        $"This should have been vetoed during candidate evaluation. " +
                        $"Voicing: B={voicesArray[0]}, T={voicesArray[1]}, A={voicesArray[2]}, S={voicesArray[3]}");
                }
            }

            // Final validation: check for voice crossing (debug/assertion only - should never trigger after fixes)
            if (!ValidateVoiceOrder(voicesArray, out string validationError))
            {
                if (enableTendencyDebug)
                {
                    UnityEngine.Debug.LogWarning($"[Voice Crossing] Final validation failed at step {stepIndex}: {validationError}");
                }
            }

            // Final validation: check for hard spacing violations (debug/assertion only - should never trigger after fixes)
            if (voicesArray.Length >= 4)
            {
                int finalBassMidi = voicesArray[0];
                int finalTenorMidi = voicesArray[1];
                int finalAltoMidi = voicesArray[2];
                int finalSopranoMidi = voicesArray[3];
                
                if (ViolatesHardSpacing(finalBassMidi, finalTenorMidi, finalAltoMidi, finalSopranoMidi))
                {
                    if (GetTendencyDebug())
                    {
                        UnityEngine.Debug.LogWarning($"[Spacing Final Check] Chosen voicing violates hard spacing at step {stepIndex}: B={finalBassMidi}, T={finalTenorMidi}, A={finalAltoMidi}, S={finalSopranoMidi}");
                    }
                }
            }

            // TRACE 6: Final output snapshot before returning
            if (enableTraceLogs)
            {
                string label = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                if (ShouldTrace(label))
                {
                    var chordTonePcsSet = new HashSet<int>(chordTonePcs);
                    var sb = new System.Text.StringBuilder();
                    sb.AppendLine($"[TRACE] R{stepIndex} {label}: Final SATB output:");
                    string allowedPCs = string.Join(",", chordTonePcs);
                    for (int v = 0; v < voicesArray.Length; v++)
                    {
                        int midi = voicesArray[v];
                        int pc = (midi % 12 + 12) % 12;
                        string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, current.Key);
                        string voiceLabel = (v == 0) ? "Bass" : (v == 1) ? "Tenor" : (v == 2) ? "Alto" : "Soprano";
                        bool isIllegal = !chordTonePcsSet.Contains(pc);
                        string illegalFlag = isIllegal ? " [ILLEGAL]" : "";
                        sb.AppendLine($"  {voiceLabel}: {midi}→{pitchName} (PC={pc}){illegalFlag}, allowedPCs=[{allowedPCs}]");
                    }
                    UnityEngine.Debug.Log(sb.ToString());
                }
            }

            // CRITICAL: Check BTAS invariant before returning (after all post-processing)
            if (voicesArray != null && voicesArray.Length >= 2)
            {
                string chordLabel = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                CheckAndLogBTASInvariant(voicesArray, stepIndex, chordLabel);
            }
            
            // CHECKPOINT 3: Before enforcement (VoiceNextChord)
            LogSeventhCheckpoint("BeforeEnforcement", stepIndex, current, voicesArray, seventhWasPresentNext ?? false, ref seventhWasPresentNext);
            
            // ENFORCEMENT: Ensure required 7th is present before returning (strict invariant)
            EnsureRequiredSeventhPresent(
                current,
                voicesArray,
                numVoices,
                upperMinMidi,
                upperMaxMidi,
                protectSoprano,
                stepIndex);
            
            // CHECKPOINT 4: Before return (final check - VoiceNextChord)
            LogSeventhCheckpoint("BeforeReturn", stepIndex, current, voicesArray, seventhWasPresentNext ?? false, ref seventhWasPresentNext);
            
            // CHECKPOINT 3: Log voicing array before creating VoicedChord (VoiceNextChord)
            var reqForCheckpoint3Next = current.Recipe.RequestedExtensions;
            bool hasB9ForCheckpoint3Next = reqForCheckpoint3Next.TensionFlat9;
            bool shouldLogCheckpoint3Next = hasB9ForCheckpoint3Next || 
                                           (s_extensionPlacementMode == RequestedExtensionPlacementMode.PreferSoprano && reqForCheckpoint3Next.TensionFlat9);
            
            if (shouldLogCheckpoint3Next && voicesArray.Length >= 4)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                UnityEngine.Debug.Log(
                    $"[CHECKPOINT_BEFORE_VOICEDCHORD] step={stepIndex} chord={chordLabel} (VoiceNextChord)\n" +
                    $"  SATB MIDI array: [{string.Join(", ", voicesArray)}]");
            }
            
            // SUMMARY LOG: Single low-noise summary for Play voicing (non-melody path)
            if (!current.MelodyMidi.HasValue && stepIndex >= 0)
            {
                string rawToken = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                var req = current.Recipe.RequestedExtensions;
                
                // Build requested tension info
                int rootPc = TheoryScale.GetDegreePitchClass(current.Key, current.Recipe.Degree);
                if (rootPc < 0) rootPc = 0;
                rootPc = (rootPc + current.Recipe.RootSemitoneOffset + 12) % 12;
                if (rootPc < 0) rootPc += 12;
                
                var requestedTensionPcs = new List<int>();
                var requestedTensionNames = new List<string>();
                if (req.TensionFlat9) { requestedTensionPcs.Add((rootPc + 1) % 12); requestedTensionNames.Add("b9"); }
                if (req.Tension9) { requestedTensionPcs.Add((rootPc + 2) % 12); requestedTensionNames.Add("9"); }
                if (req.TensionSharp9) { requestedTensionPcs.Add((rootPc + 3) % 12); requestedTensionNames.Add("#9"); }
                if (req.TensionSharp11) { requestedTensionPcs.Add((rootPc + 6) % 12); requestedTensionNames.Add("#11"); }
                
                string requestedTensionsStr = requestedTensionNames.Count > 0 ? string.Join(",", requestedTensionNames) : "none";
                string requestedTensionPcsStr = requestedTensionPcs.Count > 0 ? string.Join(",", requestedTensionPcs) : "none";
                
                // Get chord tone PCs
                string chordTonePcsStr = string.Join(",", chordTonePcs);
                
                // Get realized PCs from final voicing
                var realizedPcs = new List<int>();
                for (int i = 0; i < voicesArray.Length && i < 4; i++)
                {
                    int pc = (voicesArray[i] % 12 + 12) % 12;
                    realizedPcs.Add(pc);
                }
                string realizedPcsStr = string.Join(",", realizedPcs.OrderBy(x => x));
                
                // Recipe flags
                string recipeFlags = $"Extension={current.Recipe.Extension}, Quality={current.Recipe.Quality}";
                if (current.Recipe.Extension == ChordExtension.Seventh)
                    recipeFlags += $", SeventhQuality={current.Recipe.SeventhQuality}";
                recipeFlags += $", b9={req.TensionFlat9}, nat9={req.Tension9}";
                
                UnityEngine.Debug.Log(
                    $"[PLAY_SUMMARY] step={stepIndex} token='{rawToken}' label='{chordLabel}'\n" +
                    $"  recipeFlags: {recipeFlags}\n" +
                    $"  requestedTensions=[{requestedTensionsStr}] (pcs=[{requestedTensionPcsStr}])\n" +
                    $"  chordTonePCs=[{chordTonePcsStr}]\n" +
                    $"  realizedPCs=[{realizedPcsStr}]");
            }
            
            VoicedChord result = new VoicedChord
            {
                TimeBeats = current.TimeBeats,
                VoicesMidi = voicesArray
            };
            
            // CHECKPOINT 4: Log voicing array after creating VoicedChord (what gets returned - VoiceNextChord)
            if (shouldLogCheckpoint3Next && result.VoicesMidi != null && result.VoicesMidi.Length >= 4)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                UnityEngine.Debug.Log(
                    $"[CHECKPOINT_AFTER_VOICEDCHORD] step={stepIndex} chord={chordLabel} (VoiceNextChord return)\n" +
                    $"  VoicedChord.VoicesMidi: [{string.Join(", ", result.VoicesMidi)}]");
            }
            
            // AUG5_DBG Log #1: Identify which voice holds the augmented 5th in the current chord
            if (s_enableAug5Debug && result.VoicesMidi != null && result.VoicesMidi.Length >= 4)
            {
                // Check if current chord has augmented quality
                if (current.Recipe.Quality == ChordQuality.Augmented)
                {
                    var aug5ChordTonePcs = GetChordTonePitchClasses(current);
                    if (aug5ChordTonePcs != null && aug5ChordTonePcs.Count >= 3)
                    {
                        int rootPc = aug5ChordTonePcs[0];
                        int fifthPc = aug5ChordTonePcs[2]; // Augmented 5th
                        int aug5Pc = fifthPc;
                        
                        string roman = regionDebugLabel ?? TheoryChord.RecipeToRomanNumeral(current.Key, current.Recipe);
                        // SATB voice order: [0=Bass, 1=Tenor, 2=Alto, 3=Soprano] (same as VoicingViewer)
                        string[] satbLanes = { "Bass", "Tenor", "Alto", "Soprano" };
                        var voiceDetails = new List<string>();
                        int aug5VoiceIndex = -1;
                        bool melodyLock = current.MelodyMidi.HasValue;
                        
                        for (int v = 0; v < result.VoicesMidi.Length && v < 4; v++)
                        {
                            int midi = result.VoicesMidi[v];
                            int pc = (midi % 12 + 12) % 12;
                            string noteName = TheoryPitch.GetPitchNameFromMidi(midi, current.Key);
                            bool isAug5 = (pc == aug5Pc && ChordTensionHelper.IsAugmentedFifth(current.Recipe, ChordToneRole.Fifth));
                            
                            string marker = isAug5 ? " <--AUG5" : "";
                            string satbLane = satbLanes[v];
                            voiceDetails.Add($"V{v} lane={satbLane} midi={midi} {noteName} pc{pc}{marker}");
                            
                            if (isAug5)
                            {
                                aug5VoiceIndex = v;
                            }
                        }
                        
                        string voicesStr = string.Join(" | ", voiceDetails);
                        UnityEngine.Debug.Log(
                            $"[AUG5_DBG] chordIndex={stepIndex} roman={roman} rootPc={rootPc} | {voicesStr} (melodyLock={melodyLock})");
                    }
                }
            }
            
            // DIAGNOSTIC: Log final voicing for step 1 (when resolving b9 from step 0)
            if (stepIndex == 1 && previousEvent.Recipe.RequestedExtensions.HasAny)
            {
                var req = previousEvent.Recipe.RequestedExtensions;
                int prevRootPc = TheoryScale.GetDegreePitchClass(previousEvent.Key, previousEvent.Recipe.Degree);
                if (prevRootPc < 0) prevRootPc = 0;
                prevRootPc = (prevRootPc + previousEvent.Recipe.RootSemitoneOffset + 12) % 12;
                if (prevRootPc < 0) prevRootPc += 12;
                int requiredB9Pc = req.TensionFlat9 ? (prevRootPc + 1) % 12 : -1;
                int targetResolutionPc = requiredB9Pc >= 0 ? (requiredB9Pc + 11) % 12 : -1; // -1 semitone from b9
                
                var finalPcs = new List<int>();
                for (int i = 0; i < result.VoicesMidi.Length; i++)
                {
                    finalPcs.Add((result.VoicesMidi[i] % 12 + 12) % 12);
                }
                
                // Check which voice had the b9 in previous chord and what it resolved to
                int b9VoiceIndex = -1;
                int b9PrevMidi = -1;
                for (int v = 0; v < prevUpper.Count; v++)
                {
                    int prevPc = (prevUpper[v] % 12 + 12) % 12;
                    if (prevPc == requiredB9Pc)
                    {
                        b9VoiceIndex = v;
                        b9PrevMidi = prevUpper[v];
                        break;
                    }
                }
                
                int b9ResolvedMidi = -1;
                if (b9VoiceIndex >= 0 && b9VoiceIndex < result.VoicesMidi.Length - 1) // -1 because voicesArray[0] is bass
                {
                    // Map voice index: prevUpper[0]=Tenor -> voicesArray[1], prevUpper[1]=Alto -> voicesArray[2], etc.
                    int resolvedVoiceIndex = b9VoiceIndex + 1; // +1 because voicesArray[0] is bass
                    if (resolvedVoiceIndex < result.VoicesMidi.Length)
                    {
                        b9ResolvedMidi = result.VoicesMidi[resolvedVoiceIndex];
                    }
                }
                
                int resolutionDelta = b9ResolvedMidi >= 0 && b9PrevMidi >= 0 ? b9ResolvedMidi - b9PrevMidi : 0;
                bool isStrictStep = (resolutionDelta == -1);
                bool hasResolutionPc = targetResolutionPc >= 0 && finalPcs.Contains(targetResolutionPc);
                
                UnityEngine.Debug.Log(
                    $"[STEP1_FINAL_DIAG] === VoiceNextChord FINAL voicing (step=1, resolving b9 from step 0) ===\n" +
                    $"  result.VoicesMidi (BTAS): [{string.Join(", ", result.VoicesMidi)}]\n" +
                    $"  pitch classes: [{string.Join(", ", finalPcs)}]\n" +
                    $"  Previous chord b9: voiceIndex={b9VoiceIndex}, prevMidi={b9PrevMidi} ({TheoryPitch.GetPitchNameFromMidi(b9PrevMidi, previousEvent.Key)})\n" +
                    $"  Resolution: resolvedMidi={b9ResolvedMidi} ({TheoryPitch.GetPitchNameFromMidi(b9ResolvedMidi, current.Key)}), delta={resolutionDelta}\n" +
                    $"  targetResolutionPc={targetResolutionPc}, hasResolutionPc={hasResolutionPc}, isStrictStep={isStrictStep} (expected: -1 semitone)");
            }
            
            return result;
        }

        /// <summary>
        /// Gets the pitch class that should be in the bass based on the chord's inversion.
        /// Inversion-aware: respects Root, First (3rd in bass), Second (5th in bass), Third (7th in bass).
        /// </summary>
        /// <param name="key">The key context</param>
        /// <param name="recipe">The chord recipe with inversion information</param>
        /// <returns>Pitch class (0-11) for the bass note</returns>
        private static int GetBassPitchClassForChord(TheoryKey key, ChordRecipe recipe)
        {
            // Calculate root pitch class
            int rootPc = TheoryScale.GetDegreePitchClass(key, recipe.Degree);
            if (rootPc < 0)
            {
                rootPc = 0; // Fallback to C
            }
            rootPc = (rootPc + recipe.RootSemitoneOffset) % 12;
            if (rootPc < 0) rootPc += 12;

            // Root position: bass is the root
            if (recipe.Inversion == ChordInversion.Root)
            {
                return rootPc;
            }

            // Calculate intervals from root based on chord quality
            int thirdInterval, fifthInterval, seventhInterval = 0;

            switch (recipe.Quality)
            {
                case ChordQuality.Major:
                    thirdInterval = 4;
                    fifthInterval = 7;
                    break;
                case ChordQuality.Minor:
                    thirdInterval = 3;
                    fifthInterval = 7;
                    break;
                case ChordQuality.Diminished:
                    thirdInterval = 3;
                    fifthInterval = 6;
                    break;
                case ChordQuality.Augmented:
                    thirdInterval = 4;
                    fifthInterval = 8;
                    break;
                default:
                    thirdInterval = 4;
                    fifthInterval = 7;
                    break;
            }

            // Calculate 7th interval if needed for third inversion
            bool hasSeventh = recipe.Extension == ChordExtension.Seventh &&
                              recipe.SeventhQuality != SeventhQuality.None;
            if (hasSeventh && recipe.Inversion == ChordInversion.Third)
            {
                switch (recipe.SeventhQuality)
                {
                    case SeventhQuality.Major7:
                        seventhInterval = 11;
                        break;
                    case SeventhQuality.Minor7:
                    case SeventhQuality.Dominant7:
                    case SeventhQuality.HalfDiminished7:
                        seventhInterval = 10;
                        break;
                    case SeventhQuality.Diminished7:
                        seventhInterval = 9;
                        break;
                    default:
                        seventhInterval = 10;
                        break;
                }
            }

            // Return bass pitch class based on inversion
            switch (recipe.Inversion)
            {
                case ChordInversion.First:
                    // First inversion: 3rd in bass
                    return (rootPc + thirdInterval) % 12;
                case ChordInversion.Second:
                    // Second inversion: 5th in bass
                    return (rootPc + fifthInterval) % 12;
                case ChordInversion.Third:
                    // Third inversion: 7th in bass (only valid for 7th chords)
                    if (hasSeventh)
                    {
                        return (rootPc + seventhInterval) % 12;
                    }
                    // Fallback: if no 7th, treat as root position
                    return rootPc;
                default:
                    return rootPc;
            }
        }

        /// <summary>
        /// Robustly determines if a chord requires a 7th by checking chord tone pitch classes first,
        /// then falling back to Extension enum. This handles cases like V9 where Extension may be
        /// Nine instead of Seventh, but the chord still requires a 7th.
        /// </summary>
        /// <param name="chordEvent">The chord event to check</param>
        /// <param name="seventhPc">Output: the required 7th pitch class, or -1 if not required</param>
        /// <param name="reason">Output: explanation of how the 7th was detected ("ChordTonePcs" or "ExtensionEnum")</param>
        /// <returns>True if the chord requires a 7th, false otherwise</returns>
        private static bool TryGetRequiredSeventhPc(ChordEvent chordEvent, out int seventhPc, out string reason)
        {
            seventhPc = -1;
            reason = "None";
            
            // PRIMARY METHOD: Check GetChordTonePitchClasses (most reliable source of truth)
            // Chord tones are ordered [root, 3rd, 5th, 7th, ...] in this engine
            var chordTonePcs = GetChordTonePitchClasses(chordEvent);
            if (chordTonePcs.Count >= 4)
            {
                // 4th element (index 3) is the 7th
                seventhPc = chordTonePcs[3];
                reason = "ChordTonePcs";
                return true;
            }
            
            // FALLBACK: Use Extension enum (less reliable but handles edge cases)
            var (requiresSeventh, seventhPcFromExtension) = GetRequiredSeventh(chordEvent);
            if (requiresSeventh && seventhPcFromExtension >= 0)
            {
                seventhPc = seventhPcFromExtension;
                reason = "ExtensionEnum";
                return true;
            }
            
            return false;
        }
        
        /// <summary>
        /// Determines if a chord requires a 7th and returns the required 7th pitch class.
        /// Returns (requiresSeventh: bool, seventhPc: int). seventhPc is -1 if not required.
        /// DEPRECATED: Use TryGetRequiredSeventhPc for more robust detection.
        /// </summary>
        private static (bool requiresSeventh, int seventhPc) GetRequiredSeventh(ChordEvent chordEvent)
        {
            bool hasSeventh = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                              chordEvent.Recipe.SeventhQuality != SeventhQuality.None;
            
            if (!hasSeventh)
            {
                return (false, -1);
            }
            
            // Calculate root pitch class
            int rootPc = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + chordEvent.Recipe.RootSemitoneOffset) % 12;
            if (rootPc < 0) rootPc += 12;
            
            // Calculate 7th interval based on quality
            int seventhInterval = 10; // Default
            switch (chordEvent.Recipe.SeventhQuality)
            {
                case SeventhQuality.Major7:
                    seventhInterval = 11;
                    break;
                case SeventhQuality.Minor7:
                case SeventhQuality.Dominant7:
                case SeventhQuality.HalfDiminished7:
                    seventhInterval = 10;
                    break;
                case SeventhQuality.Diminished7:
                    seventhInterval = 9;
                    break;
            }
            
            int seventhPc = (rootPc + seventhInterval) % 12;
            return (true, seventhPc);
        }
        
        /// <summary>
        /// Checks if a required 7th pitch class is present in the voicing.
        /// </summary>
        private static bool IsSeventhPresent(int[] voicesMidi, int requiredSeventhPc)
        {
            if (requiredSeventhPc < 0) return true; // No 7th required
            if (voicesMidi == null) return false;
            
            foreach (int midi in voicesMidi)
            {
                int pc = (midi % 12 + 12) % 12;
                if (pc == requiredSeventhPc)
                    return true;
            }
            return false;
        }
        
        /// <summary>
        /// Logs a checkpoint for 7th presence tracking.
        /// Only logs when 7th was present at an earlier checkpoint but is now missing.
        /// Uses TryGetRequiredSeventhPc for robust detection.
        /// </summary>
        private static void LogSeventhCheckpoint(
            string checkpointName,
            int stepIndex,
            ChordEvent chordEvent,
            int[] voicesMidi,
            bool wasPresentEarlier,
            ref bool? wasPresentAtLastCheckpoint)
        {
            if (!TryGetRequiredSeventhPc(chordEvent, out int seventhPc, out string detectionReason))
                return; // No 7th required
            
            bool isPresentNow = IsSeventhPresent(voicesMidi, seventhPc);
            
            // Log checkpoint state (minimal, only when enabled)
            if (s_debugTensionDetect && stepIndex >= 0)
            {
                string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                var realizedPcs = new HashSet<int>();
                foreach (int midi in voicesMidi)
                    realizedPcs.Add((midi % 12 + 12) % 12);
                
                UnityEngine.Debug.Log(
                    $"[7TH_CHECKPOINT] step={stepIndex} checkpoint={checkpointName} chord={token}\n" +
                    $"  required7thPC={seventhPc} (detected via {detectionReason}), present={isPresentNow}\n" +
                    $"  realizedPCs=[{string.Join(",", realizedPcs.OrderBy(x => x))}]");
            }
            
            // Log only when 7th was present earlier but missing now
            if (wasPresentEarlier && !isPresentNow)
            {
                string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                string qualityFlags = $"{chordEvent.Recipe.Extension}, {chordEvent.Recipe.SeventhQuality}";
                
                var realizedPcs = new List<int>();
                var voiceDetails = new List<string>();
                for (int i = 0; i < voicesMidi.Length && i < 4; i++)
                {
                    int midi = voicesMidi[i];
                    int pc = (midi % 12 + 12) % 12;
                    realizedPcs.Add(pc);
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    voiceDetails.Add($"{voiceName}={midi}(pc={pc})");
                }
                
                UnityEngine.Debug.LogWarning(
                    $"[7TH_LOST] step={stepIndex} checkpoint={checkpointName} chord={token}\n" +
                    $"  Required 7th PC={seventhPc} (detected via {detectionReason})\n" +
                    $"  Voices MIDI=[{string.Join(", ", voicesMidi)}]\n" +
                    $"  Realized PCs=[{string.Join(", ", realizedPcs)}]\n" +
                    $"  Voice details: {string.Join(" ", voiceDetails)}\n" +
                    $"  Status: 7th was PRESENT at earlier checkpoint but is now MISSING");
            }
            
            wasPresentAtLastCheckpoint = isPresentNow;
        }

        /// <summary>
        /// Logs required chord tones vs realized BTAS PCs at a specific stage (gated by regression flag).
        /// Used to diagnose where required chord tones (e.g., diminished 5th) get lost in the voicing pipeline.
        /// </summary>
        private static void LogRequiredChordTonesDiagnostic(
            string stageName,
            int stepIndex,
            ChordEvent chordEvent,
            int[] voicesMidi,
            string originalToken = null)
        {
            // Gate by regression flag
            if (!Sonoria.MusicTheory.RegressionHarness.EnableRegressionHarness)
                return;

            if (voicesMidi == null || voicesMidi.Length == 0)
                return;

            // Get all chord tone pitch classes
            var chordTonePcs = GetChordTonePitchClasses(chordEvent);
            if (chordTonePcs == null || chordTonePcs.Count < 2)
                return;

            // For diminished triads, also log specific identity tone diagnostics
            if (chordEvent.Recipe.Quality == ChordQuality.Diminished)
            {
                bool hasSeventh = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                                  chordEvent.Recipe.SeventhQuality != SeventhQuality.None;
                if (!hasSeventh && chordTonePcs.Count >= 3)
                {
                    // This is a diminished triad (not dim7)
                    LogDiminishedTriadDiagnostic(stageName, stepIndex, chordEvent, voicesMidi, originalToken, chordTonePcs);
                }
            }

            // Determine which chord tones are required using ChordTonePriorityHelper
            var requiredPcs = new HashSet<int>();
            var requiredPcNames = new List<string>();
            
            bool chordHasSeventh = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                                   chordEvent.Recipe.SeventhQuality != SeventhQuality.None;

            // Check each chord tone role
            if (chordTonePcs.Count >= 1)
            {
                int rootPc = chordTonePcs[0];
                var rootPriority = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Root);
                if (rootPriority == ChordTonePriority.Required)
                {
                    requiredPcs.Add(rootPc);
                    requiredPcNames.Add($"Root(PC={rootPc})");
                }
            }
            
            if (chordTonePcs.Count >= 2)
            {
                int thirdPc = chordTonePcs[1];
                var thirdPriority = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Third);
                if (thirdPriority == ChordTonePriority.Required)
                {
                    requiredPcs.Add(thirdPc);
                    requiredPcNames.Add($"3rd(PC={thirdPc})");
                }
            }
            
            if (chordTonePcs.Count >= 3)
            {
                int fifthPc = chordTonePcs[2];
                var fifthPriority = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Fifth);
                if (fifthPriority == ChordTonePriority.Required)
                {
                    requiredPcs.Add(fifthPc);
                    requiredPcNames.Add($"5th(PC={fifthPc})");
                }
            }
            
            if (chordTonePcs.Count >= 4 && chordHasSeventh)
            {
                int seventhPc = chordTonePcs[3];
                var seventhPriority = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Seventh);
                if (seventhPriority == ChordTonePriority.Required)
                {
                    requiredPcs.Add(seventhPc);
                    requiredPcNames.Add($"7th(PC={seventhPc})");
                }
            }

            // Get realized BTAS pitch classes
            var realizedPcs = new HashSet<int>();
            var voiceDetails = new List<string>();
            for (int i = 0; i < voicesMidi.Length && i < 4; i++)
            {
                int midi = voicesMidi[i];
                int pc = (midi % 12 + 12) % 12;
                realizedPcs.Add(pc);
                string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                voiceDetails.Add($"{voiceName}={midi}({pitchName},pc={pc})");
            }

            // Find missing required tones
            var missingRequired = new List<int>();
            var missingRequiredNames = new List<string>();
            var presentRequired = new List<int>();
            var presentRequiredNames = new List<string>();
            
            foreach (int requiredPc in requiredPcs)
            {
                if (realizedPcs.Contains(requiredPc))
                {
                    presentRequired.Add(requiredPc);
                    // Find the name for this PC
                    string pcName = null;
                    if (chordTonePcs.Count >= 1 && chordTonePcs[0] == requiredPc)
                        pcName = "Root";
                    else if (chordTonePcs.Count >= 2 && chordTonePcs[1] == requiredPc)
                        pcName = "3rd";
                    else if (chordTonePcs.Count >= 3 && chordTonePcs[2] == requiredPc)
                        pcName = "5th";
                    else if (chordTonePcs.Count >= 4 && chordTonePcs[3] == requiredPc)
                        pcName = "7th";
                    presentRequiredNames.Add($"{pcName}(PC={requiredPc})");
                }
                else
                {
                    missingRequired.Add(requiredPc);
                    // Find the name for this PC
                    string pcName = null;
                    if (chordTonePcs.Count >= 1 && chordTonePcs[0] == requiredPc)
                        pcName = "Root";
                    else if (chordTonePcs.Count >= 2 && chordTonePcs[1] == requiredPc)
                        pcName = "3rd";
                    else if (chordTonePcs.Count >= 3 && chordTonePcs[2] == requiredPc)
                        pcName = "5th";
                    else if (chordTonePcs.Count >= 4 && chordTonePcs[3] == requiredPc)
                        pcName = "7th";
                    missingRequiredNames.Add($"{pcName}(PC={requiredPc})");
                }
            }

            // Build log message
            string token = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
            string chordTonePcsStr = string.Join(",", chordTonePcs);
            string requiredPcsStr = requiredPcs.Count > 0 ? string.Join(",", requiredPcs.OrderBy(x => x)) : "none";
            string realizedPcsStr = string.Join(",", realizedPcs.OrderBy(x => x));
            string presentStr = presentRequired.Count > 0 ? string.Join(",", presentRequiredNames) : "none";
            string missingStr = missingRequired.Count > 0 ? string.Join(",", missingRequiredNames) : "none";
            string voiceDetailsStr = string.Join(" ", voiceDetails);

            UnityEngine.Debug.Log(
                $"[REGRESSION_DIAG] stage={stageName} step={stepIndex} chord={token}\n" +
                $"  chordTonePCs=[{chordTonePcsStr}]\n" +
                $"  requiredPCs=[{requiredPcsStr}] ({string.Join(", ", requiredPcNames)})\n" +
                $"  realizedPCs=[{realizedPcsStr}]\n" +
                $"  BTAS: {voiceDetailsStr}\n" +
                $"  presentRequired=[{presentStr}]\n" +
                $"  missingRequired=[{missingStr}]");
        }

        /// <summary>
        /// Logs diminished triad identity tone diagnostics at a specific stage (gated by regression flag and current test case).
        /// Only logs for diminished triads (not dim7). Shows required identity tones {root, root+3, root+6} vs realized.
        /// </summary>
        private static void LogDiminishedTriadDiagnostic(
            string stageName,
            int stepIndex,
            ChordEvent chordEvent,
            int[] voicesMidi,
            string originalToken,
            List<int> chordTonePcs)
        {
            // Gate by regression flag and current test case (only log for diminished triad tests)
            if (!Sonoria.MusicTheory.RegressionHarness.ShouldLogDiminishedTriadDiagnostics())
                return;

            if (voicesMidi == null || voicesMidi.Length == 0 || chordTonePcs == null || chordTonePcs.Count < 3)
                return;

            // For diminished triad, required identity tones are: root, root+3 (minor 3rd), root+6 (diminished 5th)
            int rootPc = chordTonePcs[0];
            int thirdPc = chordTonePcs[1];
            int fifthPc = chordTonePcs[2];

            // Verify the intervals are correct (sanity check)
            int thirdInterval = (thirdPc - rootPc + 12) % 12;
            int fifthInterval = (fifthPc - rootPc + 12) % 12;
            if (thirdInterval != 3 || fifthInterval != 6)
            {
                // Not a standard diminished triad - skip
                return;
            }

            var requiredPcs = new HashSet<int> { rootPc, thirdPc, fifthPc };
            var requiredPcNames = new List<string>
            {
                TheoryPitch.GetPitchNameFromMidi(rootPc + 60, chordEvent.Key) + " (root)",
                TheoryPitch.GetPitchNameFromMidi(thirdPc + 60, chordEvent.Key) + " (m3)",
                TheoryPitch.GetPitchNameFromMidi(fifthPc + 60, chordEvent.Key) + " (b5)"
            };

            // Get realized BTAS pitch classes
            var realizedPcs = new HashSet<int>();
            var voiceDetails = new List<string>();
            for (int i = 0; i < voicesMidi.Length && i < 4; i++)
            {
                int midi = voicesMidi[i];
                int pc = (midi % 12 + 12) % 12;
                realizedPcs.Add(pc);
                string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                voiceDetails.Add($"{voiceName}={midi}({pitchName},pc={pc})");
            }

            // Find missing required tones
            var missingPcs = new List<int>();
            var missingPcNames = new List<string>();
            var presentPcs = new List<int>();
            var presentPcNames = new List<string>();

            if (realizedPcs.Contains(rootPc))
            {
                presentPcs.Add(rootPc);
                presentPcNames.Add($"root(PC={rootPc})");
            }
            else
            {
                missingPcs.Add(rootPc);
                missingPcNames.Add($"root(PC={rootPc})");
            }

            if (realizedPcs.Contains(thirdPc))
            {
                presentPcs.Add(thirdPc);
                presentPcNames.Add($"m3(PC={thirdPc})");
            }
            else
            {
                missingPcs.Add(thirdPc);
                missingPcNames.Add($"m3(PC={thirdPc})");
            }

            if (realizedPcs.Contains(fifthPc))
            {
                presentPcs.Add(fifthPc);
                presentPcNames.Add($"b5(PC={fifthPc})");
            }
            else
            {
                missingPcs.Add(fifthPc);
                missingPcNames.Add($"b5(PC={fifthPc})");
            }

            // Only log if there are missing tones (failing cases only)
            if (missingPcs.Count > 0)
            {
                string token = originalToken ?? TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                string requiredPcsStr = string.Join(",", requiredPcs.OrderBy(x => x));
                string realizedPcsStr = string.Join(",", realizedPcs.OrderBy(x => x));
                string presentStr = presentPcs.Count > 0 ? string.Join(",", presentPcNames) : "none";
                string missingStr = string.Join(",", missingPcNames);
                string voiceDetailsStr = string.Join(" ", voiceDetails);

                UnityEngine.Debug.Log(
                    $"[DIM_TRIAD_DIAG] stage={stageName} step={stepIndex} chord={token}\n" +
                    $"  requiredIdentityPCs=[{requiredPcsStr}] (root={rootPc}, m3={thirdPc}, b5={fifthPc})\n" +
                    $"  realizedPCs=[{realizedPcsStr}]\n" +
                    $"  BTAS: {voiceDetailsStr}\n" +
                    $"  presentIdentityTones=[{presentStr}]\n" +
                    $"  missingIdentityTones=[{missingStr}]");
            }
        }

        /// <summary>
        /// Logs a compact stage snapshot for diminished triad identity tones.
        /// Only logs when regression harness is enabled and current test case is a diminished triad test.
        /// Filters: only logs when missing required PCs OR VerboseRegressionStageSnapshots is true.
        /// </summary>
        private static void LogStageSnapshot_DimTriad(
            string stage,
            int stepIndex,
            string token,
            string label,
            int[] voicesMidiBTAS,
            IReadOnlyCollection<int> requiredIdentityPcs,
            TheoryKey key,
            string extra = null)
        {
            // Gate by regression flag and current test case (only log for diminished triad tests)
            if (!Sonoria.MusicTheory.RegressionHarness.ShouldLogDiminishedTriadDiagnostics())
                return;

            if (voicesMidiBTAS == null || voicesMidiBTAS.Length == 0 || requiredIdentityPcs == null || requiredIdentityPcs.Count == 0)
                return;

            // Compute realized PCs
            var realizedPcs = new HashSet<int>();
            var voiceDetails = new List<string>();
            for (int i = 0; i < voicesMidiBTAS.Length && i < 4; i++)
            {
                int midi = voicesMidiBTAS[i];
                int pc = (midi % 12 + 12) % 12;
                realizedPcs.Add(pc);
                string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, key);
                voiceDetails.Add($"{voiceName}={pitchName}({midi} pc={pc})");
            }

            // Compute missing required PCs
            var missingPcs = new List<int>();
            foreach (int requiredPc in requiredIdentityPcs)
            {
                if (!realizedPcs.Contains(requiredPc))
                {
                    missingPcs.Add(requiredPc);
                }
            }

            // Filter: only log when missing OR verbose flag is true (default: only when missing)
            // For now, always log when missing (default behavior - no separate verbose flag needed)
            if (missingPcs.Count == 0)
                return; // No missing PCs and not verbose - skip

            // Format required and realized PCs
            string requiredStr = string.Join(",", requiredIdentityPcs.OrderBy(pc => pc));
            string realizedStr = string.Join(",", realizedPcs.OrderBy(pc => pc));
            string missingStr = missingPcs.Count > 0 ? string.Join(",", missingPcs.OrderBy(pc => pc)) : "";
            string voicesStr = string.Join(" ", voiceDetails);

            // Build log message
            string logMsg = $"[DIM_TRIAD_STAGE] stage={stage} step={stepIndex} token={token} label={label}\n" +
                           $"  required=[{requiredStr}] realized=[{realizedStr}]";
            
            if (missingPcs.Count > 0)
            {
                logMsg += $" missing=[{missingStr}]";
            }
            
            logMsg += $"\n  voices: {voicesStr}";
            
            if (!string.IsNullOrEmpty(extra))
            {
                logMsg += $"\n  {extra}";
            }

            // Use Warning when missing, Log otherwise
            if (missingPcs.Count > 0)
            {
                UnityEngine.Debug.LogWarning(logMsg);
            }
            else
            {
                UnityEngine.Debug.Log(logMsg);
            }
        }

        /// <summary>
        /// Gets the set of required chord tone pitch classes for a chord event.
        /// Uses ChordTonePriorityHelper to determine which tones are Required.
        /// </summary>
        private static HashSet<int> GetRequiredChordTonePcs(ChordEvent chordEvent)
        {
            var requiredPcs = new HashSet<int>();

            var chordTonePcs = GetChordTonePitchClasses(chordEvent);
            if (chordTonePcs == null || chordTonePcs.Count < 1)
                return requiredPcs;

            bool hasSeventh = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                              chordEvent.Recipe.SeventhQuality != SeventhQuality.None;

            // Check each chord tone role
            if (chordTonePcs.Count >= 1)
            {
                int rootPc = chordTonePcs[0];
                var rootPriority = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Root);
                if (rootPriority == ChordTonePriority.Required)
                    requiredPcs.Add(rootPc);
            }

            if (chordTonePcs.Count >= 2)
            {
                int thirdPc = chordTonePcs[1];
                var thirdPriority = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Third);
                if (thirdPriority == ChordTonePriority.Required)
                    requiredPcs.Add(thirdPc);
            }

            if (chordTonePcs.Count >= 3)
            {
                int fifthPc = chordTonePcs[2];
                var fifthPriority = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Fifth);
                if (fifthPriority == ChordTonePriority.Required)
                    requiredPcs.Add(fifthPc);
            }

            if (chordTonePcs.Count >= 4 && hasSeventh)
            {
                int seventhPc = chordTonePcs[3];
                var seventhPriority = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Seventh);
                if (seventhPriority == ChordTonePriority.Required)
                    requiredPcs.Add(seventhPc);
            }

            return requiredPcs;
        }
        
        /// <summary>
        /// Ensures that a required 7th is present in the final voicing.
        /// This is a strict invariant: if a chord requires a 7th, it must be present.
        /// Uses TryGetRequiredSeventhPc for robust detection (doesn't rely solely on Extension enum).
        /// Returns true if the voicing was modified to include the 7th.
        /// </summary>
        private static bool EnsureRequiredSeventhPresent(
            ChordEvent chordEvent,
            int[] voicesMidi,
            int numVoices,
            int upperMinMidi,
            int upperMaxMidi,
            bool protectSoprano,
            int stepIndex)
        {
            // Use robust detection method (checks chord tone pitch classes first)
            if (!TryGetRequiredSeventhPc(chordEvent, out int seventhPc, out string detectionReason))
                return false; // No 7th required
            
            if (IsSeventhPresent(voicesMidi, seventhPc))
                return false; // Already present, no action needed
            
            // 7th is missing - we must add it
            string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
            UnityEngine.Debug.LogWarning(
                $"[7TH_ENFORCE] step={stepIndex} chord={token}: Required 7th PC={seventhPc} is MISSING (detected via {detectionReason}). Attempting repair...");
            
            // Get chord tone pitch classes to determine what we can replace
            var chordTonePcs = GetChordTonePitchClasses(chordEvent);
            if (chordTonePcs.Count < 2) return false; // Can't repair without chord structure
            
            int rootPc = chordTonePcs[0];
            int thirdPc = chordTonePcs.Count > 1 ? chordTonePcs[1] : -1;
            int fifthPc = chordTonePcs.Count > 2 ? chordTonePcs[2] : -1;
            
            // Count current occurrences of each pitch class in voicing
            var pcCounts = new Dictionary<int, int>();
            foreach (int midi in voicesMidi)
            {
                int pc = (midi % 12 + 12) % 12;
                pcCounts[pc] = pcCounts.GetValueOrDefault(pc, 0) + 1;
            }
            
            // Find the best voice to replace using deterministic priority:
            // 1. Doubled root (if root appears >= 2 times)
            // 2. Doubled 5th (if 5th appears >= 2 times)
            // 3. Single 5th (optional tone)
            // 4. Single root (only if root is doubled elsewhere)
            // NEVER replace 3rd
            // Priority order: Alto > Tenor > Soprano > Bass (avoid bass unless necessary)
            int[] voiceOrder = voicesMidi.Length >= 4 
                ? new[] { 2, 1, 3, 0 } // Alto, Tenor, Soprano, Bass
                : new[] { 1, 0 };      // Alto/Tenor, Bass (for 3-voice)
            
            // Score each voice for replaceability (lower score = better to replace)
            var voiceScores = new Dictionary<int, int>();
            for (int i = 0; i < voicesMidi.Length; i++)
            {
                int pc = (voicesMidi[i] % 12 + 12) % 12;
                int count = pcCounts.GetValueOrDefault(pc, 0);
                
                if (pc == thirdPc)
                {
                    voiceScores[i] = 1000; // Never replace 3rd
                }
                else if (pc == rootPc && count >= 2)
                {
                    voiceScores[i] = 1; // Doubled root - highest priority to replace
                }
                else if (pc == fifthPc && count >= 2)
                {
                    voiceScores[i] = 2; // Doubled 5th - second priority
                }
                else if (pc == fifthPc)
                {
                    voiceScores[i] = 3; // Single 5th (optional) - third priority
                }
                else if (pc == rootPc && pcCounts.GetValueOrDefault(rootPc, 0) >= 2)
                {
                    voiceScores[i] = 4; // Root when root is doubled elsewhere
                }
                else
                {
                    voiceScores[i] = 100; // Other tones - only replace as last resort
                }
            }
            
            // Sort voices by score (best replacement candidates first), then by voice order preference
            var sortedVoices = voiceOrder
                .Where(v => v < voicesMidi.Length)
                .Where(v => !(protectSoprano && v == voicesMidi.Length - 1)) // Skip protected soprano
                .OrderBy(v => voiceScores.GetValueOrDefault(v, 100))
                .ThenBy(v => Array.IndexOf(voiceOrder, v))
                .ToList();
            
            foreach (int voiceIdx in sortedVoices)
            {
                int currentMidi = voicesMidi[voiceIdx];
                int currentPc = (currentMidi % 12 + 12) % 12;
                
                // Skip if this voice already has the 7th (shouldn't happen, but be safe)
                if (currentPc == seventhPc) continue;
                
                // Try to place the 7th in the nearest octave to current voice that preserves ordering
                // Start with current octave, then try ±12 variants
                int baseOctave = currentMidi / 12;
                var candidateOctaves = new List<int> { baseOctave, baseOctave + 1, baseOctave - 1 };
                
                int bestCandidateMidi = -1;
                int bestMovement = int.MaxValue;
                
                foreach (int octave in candidateOctaves)
                {
                    int candidateMidi = octave * 12 + seventhPc;
                    if (candidateMidi < 0 || candidateMidi > 127) continue;
                    
                    // Check if this octave maintains BTAS ordering
                    bool violatesOrdering = false;
                    if (voiceIdx == 0 && voicesMidi.Length > 1 && candidateMidi > voicesMidi[1]) violatesOrdering = true;
                    else if (voiceIdx == 1 && voicesMidi.Length > 0 && candidateMidi <= voicesMidi[0]) violatesOrdering = true;
                    else if (voiceIdx == 1 && voicesMidi.Length > 2 && candidateMidi > voicesMidi[2]) violatesOrdering = true;
                    else if (voiceIdx == 2 && voicesMidi.Length > 1 && candidateMidi <= voicesMidi[1]) violatesOrdering = true;
                    else if (voiceIdx == 2 && voicesMidi.Length > 3 && candidateMidi > voicesMidi[3]) violatesOrdering = true;
                    else if (voiceIdx == 3 && voicesMidi.Length > 2 && candidateMidi <= voicesMidi[2]) violatesOrdering = true;
                    
                    if (violatesOrdering) continue;
                    
                    // Check voice range constraints
                    if (voiceIdx == 0)
                    {
                        if (candidateMidi < 35 || candidateMidi > 60) continue; // Bass range (B1-C4)
                    }
                    else
                    {
                        if (candidateMidi < upperMinMidi || candidateMidi > upperMaxMidi) continue;
                    }
                    
                    // Calculate movement distance (prefer minimal movement)
                    int movement = Math.Abs(candidateMidi - currentMidi);
                    if (movement < bestMovement)
                    {
                        bestMovement = movement;
                        bestCandidateMidi = candidateMidi;
                    }
                }
                
                if (bestCandidateMidi < 0) continue; // No valid placement for this voice
                
                // Verify pitch class is correct
                int bestPc = (bestCandidateMidi % 12 + 12) % 12;
                if (bestPc != seventhPc) continue;
                
                // Replace this voice with the 7th
                int oldMidi = voicesMidi[voiceIdx];
                voicesMidi[voiceIdx] = bestCandidateMidi;
                
                string voiceName = voiceIdx == 0 ? "Bass" : voiceIdx == 1 ? "Tenor" : voiceIdx == 2 ? "Alto" : "Soprano";
                string replacedTone = currentPc == rootPc ? "root" : currentPc == fifthPc ? "5th" : $"pc{currentPc}";
                UnityEngine.Debug.Log(
                    $"[7TH_ENFORCE] step={stepIndex} chord={token}: Replaced {voiceName} {oldMidi}({replacedTone},PC={currentPc}) " +
                    $"with {bestCandidateMidi}(7th,PC={seventhPc}) to include required 7th (movement={bestMovement})");
                
                // Re-enforce ordering in case the replacement caused issues
                EnforceVoiceOrderingBTAS(voicesMidi);
                
                return true; // Successfully repaired
            }
            
            // If we couldn't place it in any voice, log an error
            UnityEngine.Debug.LogError(
                $"[7TH_ENFORCE] step={stepIndex} chord={token}: FAILED to place required 7th PC={seventhPc}. " +
                $"Voicing may be incomplete. Voices={string.Join(",", voicesMidi)}");
            
            return false;
        }
        
        /// <summary>
        /// Extracts chord tone pitch classes from a chord event.
        /// Returns list of pitch classes: [root, 3rd, 5th, 7th] (7th only if present).
        /// </summary>
        internal static List<int> GetChordTonePitchClasses(ChordEvent chordEvent)
        {
            var pitchClasses = new List<int>();

            // Calculate root pitch class
            int rootPc = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPc < 0)
            {
                rootPc = 0; // Fallback to C
            }
            rootPc = (rootPc + chordEvent.Recipe.RootSemitoneOffset) % 12;
            if (rootPc < 0) rootPc += 12;
            pitchClasses.Add(rootPc);

            // Determine if this is a 7th chord
            // CRITICAL: For dominant 9 chords (V9, etc.), the 7th MUST be included even if Extension != Seventh
            // V9 is "dominant seventh + 9", not "triad + 9"
            bool hasSeventh = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                              chordEvent.Recipe.SeventhQuality != SeventhQuality.None;
            
            // FIX: Force 7th for dominant chords with natural 9
            // This handles cases where V9 is parsed as Extension=None but should include the 7th
            bool forcedSeventhForDominant9 = false;
            if (!hasSeventh)
            {
                bool isDominant = (chordEvent.Recipe.Quality == ChordQuality.Major) && 
                                  (chordEvent.Recipe.Degree == 5 || chordEvent.Recipe.Degree == 7); // V or viidim
                bool hasNatural9 = chordEvent.Recipe.RequestedExtensions.Tension9;
                
                // For dominant+9, treat as dominant 7th chord (include the b7)
                if (isDominant && hasNatural9)
                {
                    hasSeventh = true;
                    forcedSeventhForDominant9 = true;
                }
            }

            // Calculate intervals from root based on chord quality
            int thirdInterval, fifthInterval, seventhInterval = 0;

            switch (chordEvent.Recipe.Quality)
            {
                case ChordQuality.Major:
                    thirdInterval = 4;
                    fifthInterval = 7;
                    break;
                case ChordQuality.Minor:
                    thirdInterval = 3;
                    fifthInterval = 7;
                    break;
                case ChordQuality.Diminished:
                    thirdInterval = 3;
                    fifthInterval = 6;
                    break;
                case ChordQuality.Augmented:
                    thirdInterval = 4;
                    fifthInterval = 8;
                    break;
                default:
                    thirdInterval = 4;
                    fifthInterval = 7;
                    break;
            }

            // Calculate 7th interval if present
            if (hasSeventh)
            {
                if (forcedSeventhForDominant9 || chordEvent.Recipe.SeventhQuality == SeventhQuality.None)
                {
                    // For dominant+9 forced case or when SeventhQuality is None but we need the 7th, use dominant 7th interval (b7)
                    seventhInterval = 10;
                }
                else
                {
                    switch (chordEvent.Recipe.SeventhQuality)
                    {
                        case SeventhQuality.Major7:
                            seventhInterval = 11;
                            break;
                        case SeventhQuality.Minor7:
                        case SeventhQuality.Dominant7:
                        case SeventhQuality.HalfDiminished7:
                            seventhInterval = 10;
                            break;
                        case SeventhQuality.Diminished7:
                            seventhInterval = 9;
                            break;
                        default:
                            seventhInterval = 10;
                            break;
                    }
                }
            }

            // Handle sus4: if requested, use 4 instead of 3 (but don't remove 3 entirely - allow both)
            bool hasSus4 = chordEvent.Recipe.RequestedExtensions.Sus4;
            int fourthPc = (rootPc + 5) % 12; // Perfect 4th = +5 semitones

            // Calculate pitch classes for each chord tone
            int thirdPc = (rootPc + thirdInterval) % 12;
            int fifthPc = (rootPc + fifthInterval) % 12;
            
            // Add root
            // (already added above)
            
            // Add 3rd or 4th based on sus4 request
            if (hasSus4)
            {
                pitchClasses.Add(fourthPc); // sus4: use 4th instead of 3rd as primary
                // Note: we don't add 3rd here, but voicing can still include it (warn if both present)
            }
            else
            {
                pitchClasses.Add(thirdPc); // Normal: use 3rd
            }
            
            pitchClasses.Add(fifthPc);

            if (hasSeventh)
            {
                int seventhPc = (rootPc + seventhInterval) % 12;
                pitchClasses.Add(seventhPc);
            }
            
            // Add requested "add" tones (add9, add11) as valid chord tones
            if (chordEvent.Recipe.RequestedExtensions.Add9)
            {
                int add9Pc = (rootPc + 2) % 12; // Major 9th = +2 semitones (or +14, but we use PC)
                if (!pitchClasses.Contains(add9Pc))
                    pitchClasses.Add(add9Pc);
            }
            
            if (chordEvent.Recipe.RequestedExtensions.Add11)
            {
                int add11Pc = (rootPc + 5) % 12; // Perfect 11th = +5 semitones
                if (!pitchClasses.Contains(add11Pc))
                    pitchClasses.Add(add11Pc);
            }

            return pitchClasses;
        }

        /// <summary>
        /// Generates all candidate MIDI notes for given pitch classes within a range.
        /// Returns all valid MIDI notes (pc + 12*k) that fall within [minMidi, maxMidi].
        /// </summary>
        private static List<int> GenerateCandidatesInRange(List<int> pitchClasses, int minMidi, int maxMidi)
        {
            var candidates = new List<int>();

            foreach (int pc in pitchClasses)
            {
                // Find the lowest octave that fits in range
                int octave = (minMidi - pc) / 12;
                int midi = octave * 12 + pc;

                // Generate all octaves within range
                while (midi <= maxMidi)
                {
                    if (midi >= minMidi)
                    {
                        candidates.Add(midi);
                    }
                    midi += 12;
                }
            }

            return candidates;
        }

        /// <summary>
        /// Finds the nearest MIDI note with the target pitch class within the specified range.
        /// Used for converting duplicate chord tones to required tones (e.g., duplicate root to 3rd).
        /// </summary>
        private static int SnapToNearestPitchClassWithinRange(
            int targetPc,
            int referenceMidi,
            int minMidi,
            int maxMidi)
        {
            // Normalize target PC
            targetPc = (targetPc % 12 + 12) % 12;

            int bestMidi = -1;
            int bestDist = int.MaxValue;

            for (int midi = minMidi; midi <= maxMidi; midi++)
            {
                int pc = (midi % 12 + 12) % 12;
                if (pc != targetPc) continue;

                int dist = Math.Abs(midi - referenceMidi);
                if (dist < bestDist)
                {
                    bestDist = dist;
                    bestMidi = midi;
                }
            }

            return bestMidi;
        }

        /// <summary>
        /// Finds the nearest MIDI note within [minMidi, maxMidi] whose pitch class equals targetPitchClass
        /// and whose absolute distance from referenceMidi is minimal.
        /// Returns -1 if no such note exists in range.
        /// </summary>
        private static int FindNearestPitchClassInRange(
            int targetPitchClass,
            int referenceMidi,
            int minMidi,
            int maxMidi)
        {
            // Normalize pitch class to 0-11
            targetPitchClass = (targetPitchClass % 12 + 12) % 12;
            
            // Find the first occurrence of targetPitchClass at or below maxMidi
            int baseOctave = (maxMidi - targetPitchClass) / 12;
            int candidate = baseOctave * 12 + targetPitchClass;
            
            int bestCandidate = -1;
            int bestDistance = int.MaxValue;
            
            // Search downward from maxMidi to minMidi
            while (candidate >= minMidi - 12) // Allow one octave below min to catch edge cases
            {
                if (candidate >= minMidi && candidate <= maxMidi)
                {
                    int distance = Math.Abs(candidate - referenceMidi);
                    if (distance < bestDistance)
                    {
                        bestCandidate = candidate;
                        bestDistance = distance;
                    }
                }
                candidate -= 12;
            }
            
            // Also search upward (in case we're near the bottom of range)
            candidate = baseOctave * 12 + targetPitchClass + 12;
            while (candidate <= maxMidi + 12) // Allow one octave above max
            {
                if (candidate >= minMidi && candidate <= maxMidi)
                {
                    int distance = Math.Abs(candidate - referenceMidi);
                    if (distance < bestDistance)
                    {
                        bestCandidate = candidate;
                        bestDistance = distance;
                    }
                }
                candidate += 12;
            }
            
            return bestCandidate;
        }

        /// <summary>
        /// Finds a nearby target root for local leading tone resolution.
        /// Only searches within ±3 semitones of the current note.
        /// Prioritizes upward movement (1-3 semitones up) then downward (1-3 semitones down).
        /// Returns -1 if no target root is found within this small window.
        /// </summary>
        private static int FindNearbyTargetRootForLocalLeadingTone(
            int fromMidi,
            int targetPitchClass)
        {
            // Normalize pitch class to 0-11
            targetPitchClass = (targetPitchClass % 12 + 12) % 12;
            
            // First, try upward moves (1-3 semitones)
            for (int delta = 1; delta <= 3; delta++)
            {
                int candidate = fromMidi + delta;
                int candidatePc = (candidate % 12 + 12) % 12;
                if (candidatePc == targetPitchClass)
                {
                    return candidate;
                }
            }
            
            // Then, try downward moves (1-3 semitones)
            for (int delta = 1; delta <= 3; delta++)
            {
                int candidate = fromMidi - delta;
                int candidatePc = (candidate % 12 + 12) % 12;
                if (candidatePc == targetPitchClass)
                {
                    return candidate;
                }
            }
            
            // No target root found within ±3 semitones
            return -1;
        }

        /// <summary>
        /// Finds a nearby resolution candidate for a chord 7th.
        /// Prioritizes downward step resolution in the same octave region (e.g., G3→F3, not G3→F4).
        /// Searches for a pitch class that is 1-2 semitones below the 7th's pitch class.
        /// Returns -1 if no valid resolution is found within range.
        /// </summary>
        private static int FindSeventhResolutionCandidate(
            int fromMidi,
            int fromPc,
            int minMidi,
            int maxMidi,
            HashSet<int> chordTonePcs,
            int? melodyMidi = null)
        {
            // First, check if melody is on a valid resolution tone (1-2 semitones down)
            if (melodyMidi.HasValue && melodyMidi.Value >= 0)
            {
                int melodyPc = (melodyMidi.Value % 12 + 12) % 12;
                int pcDown1 = (fromPc + 11) % 12;   // -1 semitone
                int pcDown2 = (fromPc + 10) % 12;   // -2 semitones
                
                if (melodyPc == pcDown1 || melodyPc == pcDown2)
                {
                    // Melody is on a valid resolution tone - use that pitch class
                    if (chordTonePcs.Contains(melodyPc))
                    {
                        // Prefer downward resolution in same octave region
                        int downwardCandidate = FindDownwardSeventhResolution(fromMidi, melodyPc, minMidi, maxMidi);
                        if (downwardCandidate >= 0)
                            return downwardCandidate;
                        
                        // Fallback to nearest if downward not found
                        return FindNearestPitchClassInRange(melodyPc, fromMidi, minMidi, maxMidi);
                    }
                }
            }
            
            // Fallback: find any chord tone that's 1-2 semitones down
            int fallbackPcDown1 = (fromPc + 11) % 12;   // -1 semitone
            int fallbackPcDown2 = (fromPc + 10) % 12;   // -2 semitones
            
            // Try fallbackPcDown1 first (more common resolution) - prioritize downward
            if (chordTonePcs.Contains(fallbackPcDown1))
            {
                int downwardCandidate = FindDownwardSeventhResolution(fromMidi, fallbackPcDown1, minMidi, maxMidi);
                if (downwardCandidate >= 0)
                    return downwardCandidate;
                
                // Fallback to nearest if downward not found
                int candidate = FindNearestPitchClassInRange(fallbackPcDown1, fromMidi, minMidi, maxMidi);
                if (candidate >= 0)
                    return candidate;
            }
            
            // Try fallbackPcDown2 as fallback - prioritize downward
            if (chordTonePcs.Contains(fallbackPcDown2))
            {
                int downwardCandidate = FindDownwardSeventhResolution(fromMidi, fallbackPcDown2, minMidi, maxMidi);
                if (downwardCandidate >= 0)
                    return downwardCandidate;
                
                // Fallback to nearest if downward not found
                int candidate = FindNearestPitchClassInRange(fallbackPcDown2, fromMidi, minMidi, maxMidi);
                if (candidate >= 0)
                    return candidate;
            }
            
            return -1;
        }
        
        /// <summary>
        /// Checks if a MIDI note's pitch class is allowed in the destination chord.
        /// </summary>
        private static bool IsPitchClassAllowedInChord(TheoryKey key, ChordEvent destChord, int midi)
        {
            var pcs = GetChordTonePitchClasses(destChord);
            int pc = ((midi % 12) + 12) % 12;
            return pcs.Contains(pc);
        }
        
        /// <summary>
        /// Gets a formatted string of allowed destination pitch classes for diagnostics.
        /// </summary>
        private static string GetAllowedDestinationPCsString(List<int> chordTonePcs, TheoryKey key)
        {
            var names = chordTonePcs.OrderBy(pc => pc)
                .Select(pc => TheoryPitch.GetPitchNameFromMidi(pc + 60, key))
                .ToList();
            return string.Join(",", names);
        }
        
        /// <summary>
        /// Validates a tendency candidate and tries to find a legal alternative if the candidate is illegal.
        /// Returns the legal candidate MIDI, or -1 if no legal alternative is found.
        /// </summary>
        private static int ValidateAndRedirectTendencyCandidate(
            int candidateMidi,
            HashSet<int> allowedChordPcs,
            int minMidi,
            int maxMidi,
            int? stepIndex = null,
            DiagnosticsCollector diags = null,
            string voiceName = null,
            int fromMidi = -1)
        {
            if (candidateMidi < 0) return -1;
            
            int candidatePc = (candidateMidi % 12 + 12) % 12;
            
            // If candidate is legal, return it
            if (allowedChordPcs.Contains(candidatePc))
            {
                return candidateMidi;
            }
            
            // Candidate is illegal - try to find a legal alternative
            // Prefer opposite direction: if candidate is +1, try -1 first; if -1, try +1 first
            int candidateDelta = candidateMidi - (fromMidi >= 0 ? fromMidi : candidateMidi);
            bool preferDownward = candidateDelta > 0;
            
            // Try ±1 semitones (prefer opposite direction)
            int[] deltas = preferDownward ? new int[] { -1, 1, -2, 2 } : new int[] { 1, -1, 2, -2 };
            
            foreach (int delta in deltas)
            {
                int alternativeMidi = candidateMidi + delta;
                if (alternativeMidi >= minMidi && alternativeMidi <= maxMidi)
                {
                    int alternativePc = (alternativeMidi % 12 + 12) % 12;
                    if (allowedChordPcs.Contains(alternativePc))
                    {
                        return alternativeMidi;
                    }
                }
            }
            
            // No legal alternative found - return -1 to reject
            return -1;
        }
        
        /// <summary>
        /// Tries to redirect an illegal resolution to a legal stepwise resolution.
        /// Checks both -1 and +1 semitone steps from the source MIDI.
        /// </summary>
        private static int TryRedirectResolution(int sourceMidi, int illegalPc, HashSet<int> allowedPCs, int minMidi, int maxMidi)
        {
            // Try -1 semitone (downward step)
            int candidateDown = sourceMidi - 1;
            if (candidateDown >= minMidi && candidateDown <= maxMidi)
            {
                int pcDown = (candidateDown % 12 + 12) % 12;
                if (allowedPCs.Contains(pcDown))
                {
                    return candidateDown;
                }
            }
            
            // Try +1 semitone (upward step)
            int candidateUp = sourceMidi + 1;
            if (candidateUp >= minMidi && candidateUp <= maxMidi)
            {
                int pcUp = (candidateUp % 12 + 12) % 12;
                if (allowedPCs.Contains(pcUp))
                {
                    return candidateUp;
                }
            }
            
            // Try -2 semitones (minor second down)
            int candidateDown2 = sourceMidi - 2;
            if (candidateDown2 >= minMidi && candidateDown2 <= maxMidi)
            {
                int pcDown2 = (candidateDown2 % 12 + 12) % 12;
                if (allowedPCs.Contains(pcDown2))
                {
                    return candidateDown2;
                }
            }
            
            // Try +2 semitones (minor second up)
            int candidateUp2 = sourceMidi + 2;
            if (candidateUp2 >= minMidi && candidateUp2 <= maxMidi)
            {
                int pcUp2 = (candidateUp2 % 12 + 12) % 12;
                if (allowedPCs.Contains(pcUp2))
                {
                    return candidateUp2;
                }
            }
            
            return -1; // No legal redirect found
        }
        
        /// <summary>
        /// Finds a downward step resolution candidate for a 7th, starting from prevMidi - 1 and scanning downward.
        /// Returns the closest valid downward step (1-2 semitones) in the same octave region.
        /// Returns -1 if no such candidate exists within range.
        /// </summary>
        private static int FindDownwardSeventhResolution(
            int prevMidi,
            int targetPc,
            int minMidi,
            int maxMidi)
        {
            // Start from prevMidi - 1 and scan downward to find the closest valid resolution
            // This ensures we get G3→F3, not G3→F4
            for (int offset = 1; offset <= 2; offset++) // Check 1-2 semitones down
            {
                int candidateMidi = prevMidi - offset;
                if (candidateMidi < minMidi)
                    break; // Gone below range
                
                int candidatePc = (candidateMidi % 12 + 12) % 12;
                if (candidatePc == targetPc)
                {
                    // Found a valid downward step resolution
                    return candidateMidi;
                }
            }
            
            // If no step-down found in immediate range, try one octave down
            for (int offset = 10; offset <= 11; offset++) // Check 10-11 semitones down (octave - 1 or 2)
            {
                int candidateMidi = prevMidi - offset;
                if (candidateMidi < minMidi)
                    break; // Gone below range
                
                int candidatePc = (candidateMidi % 12 + 12) % 12;
                if (candidatePc == targetPc)
                {
                    // Found a valid downward resolution (octave down)
                    return candidateMidi;
                }
            }
            
            return -1;
        }

        /// <summary>
        /// Finds the nearest bass note with the target pitch class, starting from the previous bass.
        /// Tries ±2 octaves from previous bass, within reasonable bass band [35, 60] (B1-C4).
        /// Allows one candidate slightly above the upper bound (≤2 semitones) if it produces a smaller interval.
        /// </summary>
        private static int FindNearestBassNote(int prevBass, int targetPc, int fallbackOctave)
        {
            const int bassMinMidi = 35; // B1
            const int bassMaxMidi = 60; // C4

            int bestInRangeNote = -1;
            int bestInRangeDistance = int.MaxValue;

            // Generate all in-range candidates for targetPc
            // Try ±2 octaves from previous bass to find candidates with targetPc
            for (int octaveOffset = -2; octaveOffset <= 2; octaveOffset++)
            {
                int candidate = prevBass + (octaveOffset * 12);
                int candidatePc = (candidate % 12 + 12) % 12;

                if (candidatePc == targetPc && candidate >= bassMinMidi && candidate <= bassMaxMidi)
                {
                    int distance = Math.Abs(candidate - prevBass);
                    if (distance < bestInRangeDistance)
                    {
                        bestInRangeNote = candidate;
                        bestInRangeDistance = distance;
                    }
                }
            }

            // Also generate candidates directly from targetPc within range
            int startOctave = (bassMinMidi - targetPc + 11) / 12; // Ceiling division
            int directCandidate = startOctave * 12 + targetPc;
            if (directCandidate < bassMinMidi)
            {
                directCandidate += 12;
            }

            while (directCandidate <= bassMaxMidi)
            {
                int distance = Math.Abs(directCandidate - prevBass);
                if (distance < bestInRangeDistance)
                {
                    bestInRangeNote = directCandidate;
                    bestInRangeDistance = distance;
                }
                directCandidate += 12;
            }

            // Generate one candidate an octave above the highest in-range candidate (even if slightly out of bounds)
            int octaveAbove = (bassMaxMidi - targetPc) / 12 + 1;
            int outOfRangeCandidate = octaveAbove * 12 + targetPc;
            
            // Check if this out-of-range candidate is within 2 semitones of the upper bound
            bool isWithin2Semitones = (outOfRangeCandidate - bassMaxMidi) <= 2;
            
            int bestNote = bestInRangeNote;
            
            if (isWithin2Semitones && bestInRangeNote >= 0)
            {
                int outOfRangeDistance = Math.Abs(outOfRangeCandidate - prevBass);
                
                // If out-of-range candidate is closer than the best in-range candidate, prefer it
                if (outOfRangeDistance < bestInRangeDistance)
                {
                    bestNote = outOfRangeCandidate;
                }
            }

            // If no candidate found in band, fallback to root in bassOctave
            if (bestNote < 0)
            {
                int rootMidi = (fallbackOctave + 1) * 12 + targetPc;
                // Enforce minimum: if calculated note is below bassMinMidi, move it up an octave
                if (rootMidi < bassMinMidi)
                {
                    rootMidi += 12;
                }
                // Also enforce maximum
                if (rootMidi > bassMaxMidi)
                {
                    rootMidi -= 12;
                }
                bestNote = rootMidi;
            }

            return bestNote;
        }

        /// <summary>
        /// Finds the nearest root pitch class for bass within +/-12 semitones of the previous bass.
        /// Used to guarantee a root candidate is available when inversion is not explicit.
        /// </summary>
        private static int FindNearestRootForBass(int prevBassMidi, int rootPitchClass)
        {
            const int bassMinMidi = 35; // B1 - match the value used in other methods
            const int bassMaxMidi = 60; // C4
            
            int bestMidi = -1;
            int bestDistance = int.MaxValue;

            // Search up and down within +/- 12 semitones
            for (int delta = -12; delta <= 12; delta++)
            {
                if (delta == 0) continue;
                
                int candidate = prevBassMidi + delta;
                // Enforce minimum range: reject candidates below bassMinMidi or above bassMaxMidi
                if (candidate < bassMinMidi || candidate > bassMaxMidi) continue;

                int pc = candidate % 12;
                if (pc < 0) pc += 12;

                if (pc == rootPitchClass)
                {
                    int dist = Math.Abs(delta);
                    if (dist < bestDistance)
                    {
                        bestDistance = dist;
                        bestMidi = candidate;
                    }
                }
            }

            return bestMidi;
        }

        /// <summary>
        /// Finds the best bass note with root position preference when no inversion is specified.
        /// Considers all chord tones (root, 3rd, 5th, 7th) and selects based on distance + inversion preference.
        /// </summary>
        private static int FindBestBassNoteWithInversionPreference(
            int prevBass,
            TheoryKey key,
            ChordRecipe recipe,
            int bassOctave,
            int upperMinMidi = 55,
            int stepIndex = -1)
        {
            const int bassMinMidi = 35; // B1
            const int bassMaxMidi = 60; // C4

            // Determine tenor floor: bass must be strictly lower than the normal tenor minimum
            // The normal tenor minimum is upperMinMidi (tenors typically start at or above this)
            // However, tenors can go lower (down to TenorAbsoluteMinMidi) when needed
            // To allow smooth voice leading while preventing crossing, we use upperMinMidi as the floor
            // This allows bass candidates up to (upperMinMidi - 1), ensuring tenor can always be placed above
            int tenorFloor = upperMinMidi;

            // Calculate root pitch class
            int rootPc = TheoryScale.GetDegreePitchClass(key, recipe.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + recipe.RootSemitoneOffset) % 12;
            if (rootPc < 0) rootPc += 12;

            // Get chord tone pitch classes
            var chordTonePcs = new HashSet<int> { rootPc };
            
            // Add 3rd, 5th, 7th based on chord quality
            int thirdInterval, fifthInterval, seventhInterval = 0;
            switch (recipe.Quality)
            {
                case ChordQuality.Major:
                    thirdInterval = 4; fifthInterval = 7;
                    break;
                case ChordQuality.Minor:
                    thirdInterval = 3; fifthInterval = 7;
                    break;
                case ChordQuality.Diminished:
                    thirdInterval = 3; fifthInterval = 6;
                    break;
                case ChordQuality.Augmented:
                    thirdInterval = 4; fifthInterval = 8;
                    break;
                default:
                    thirdInterval = 4; fifthInterval = 7;
                    break;
            }

            int thirdPc = (rootPc + thirdInterval) % 12;
            int fifthPc = (rootPc + fifthInterval) % 12;
            chordTonePcs.Add(thirdPc);
            chordTonePcs.Add(fifthPc);

            bool hasSeventh = recipe.Extension == ChordExtension.Seventh &&
                              recipe.SeventhQuality != SeventhQuality.None;
            int seventhPc = -1;
            if (hasSeventh)
            {
                // Calculate seventh interval based on seventh quality
                switch (recipe.SeventhQuality)
                {
                    case SeventhQuality.Major7:
                        seventhInterval = 11;
                        break;
                    case SeventhQuality.Minor7:
                    case SeventhQuality.Dominant7:
                    case SeventhQuality.HalfDiminished7:
                        seventhInterval = 10;
                        break;
                    case SeventhQuality.Diminished7:
                        seventhInterval = 9;
                        break;
                    default:
                        seventhInterval = 10;
                        break;
                }
                seventhPc = (rootPc + seventhInterval) % 12;
                chordTonePcs.Add(seventhPc);
            }

            // Determine if inversion is explicitly specified (when Inversion != Root, it was parsed from Roman numeral)
            bool inversionExplicitlySpecified = (recipe.Inversion != ChordInversion.Root);
            int requestedBassPc = GetBassPitchClassForChord(key, recipe);

            // Guarantee candidates when needed
            int forcedRootCandidateMidi = -1;
            int forcedRequestedBassCandidateMidi = -1;
            
            if (!inversionExplicitlySpecified)
            {
                // Guarantee a nearby root candidate when inversion is not explicit
                forcedRootCandidateMidi = FindNearestRootForBass(prevBass, rootPc);
            }
            else
            {
                // Guarantee a nearby candidate for the requested bass when inversion is explicit
                forcedRequestedBassCandidateMidi = FindNearestRootForBass(prevBass, requestedBassPc);
            }

            // Generate candidates and compute costs
            int bestCandidate = -1;
            float bestCost = float.MaxValue;
            bool hasRootCandidateWithin7 = false;
            int bestRootMidi = -1;
            float bestRootTotalCost = float.MaxValue;

            // Track all candidates for debug logging
            var candidateMidis = new List<int>();
            var candidateDegrees = new List<string>();
            var candidateBaseCosts = new List<float>();
            var candidateTotalCosts = new List<float>();

            // First, evaluate the forced root candidate if it exists
            if (forcedRootCandidateMidi >= 0)
            {
                // HARD CONSTRAINT: Bass cannot enter tenor range; reject if > tenorFloor
                // Use > instead of >= to allow candidates at the boundary (e.g., F3 when upperMinMidi=53)
                if (forcedRootCandidateMidi > tenorFloor)
                {
                    // Skip this candidate - bass would be too high
                    if (enableTendencyDebug)
                    {
                        UnityEngine.Debug.Log($"[Bass Selection] Rejected forced root candidate {forcedRootCandidateMidi} because it's >= tenorFloor {tenorFloor}");
                    }
                }
                else
                {
                    float baseCost = Math.Abs(forcedRootCandidateMidi - prevBass);
                    float prefAdjust = -4.0f; // Strong root bonus when no inversion specified
                    float totalCost = baseCost + prefAdjust;

                    // Track for debug
                    candidateMidis.Add(forcedRootCandidateMidi);
                    candidateDegrees.Add("Root(forced)");
                    candidateBaseCosts.Add(baseCost);
                    candidateTotalCosts.Add(totalCost);

                    // Track as best overall candidate
                    if (totalCost < bestCost)
                    {
                        bestCandidate = forcedRootCandidateMidi;
                        bestCost = totalCost;
                    }

                    // Track as root candidate
                    if (baseCost <= 7.0f)
                    {
                        hasRootCandidateWithin7 = true;
                        if (totalCost < bestRootTotalCost)
                        {
                            bestRootMidi = forcedRootCandidateMidi;
                            bestRootTotalCost = totalCost;
                        }
                    }
                }
            }

            // Generate candidates for all chord tones
            foreach (int candidatePc in chordTonePcs)
            {
                // HARD CONSTRAINT: Filter out candidates with wrong pitch class based on inversion
                if (inversionExplicitlySpecified)
                {
                    // Explicit inversion: ONLY allow candidates matching the required bass pitch class
                    if (candidatePc != requestedBassPc)
                    {
                        // Skip this candidate entirely - don't evaluate cost
                        // Inversion veto: candidate pitch class doesn't match required bass pitch class
                        // (Debug log removed to reduce spam - this is expected behavior during candidate filtering)
                        continue; // Skip to next pitch class
                    }
                }
                else
                {
                    // No inversion specified (root position): ONLY allow root pitch class
                    if (candidatePc != rootPc)
                    {
                        // Skip this candidate entirely - root position must have root in bass
                        // (Debug log removed to reduce spam - this is expected behavior during candidate filtering)
                        continue; // Skip to next pitch class
                    }
                }

                // Generate MIDI candidates for this pitch class in bass range
                int startOct = (bassMinMidi - candidatePc + 11) / 12;
                int cand = startOct * 12 + candidatePc;
                if (cand < bassMinMidi) cand += 12;

                while (cand <= bassMaxMidi + 2) // Allow slight out-of-range
                {
                    if (cand < bassMinMidi) { cand += 12; continue; }

                    // HARD CONSTRAINT: Bass cannot enter tenor range; reject if > tenorFloor
                    // Use > instead of >= to allow candidates at the boundary (e.g., F3 when upperMinMidi=53)
                    if (cand > tenorFloor)
                    {
                        // Skip this candidate - bass would be too high
                        cand += 12;
                        continue;
                    }

                    // Base cost: distance from previous bass
                    float baseCost = Math.Abs(cand - prevBass);

                    // Inversion preference adjustments (now only for bonus, not penalty since wrong PCs are filtered)
                    float prefAdjust = 0f;
                    
                    if (inversionExplicitlySpecified)
                    {
                        // Explicit inversion: candidate already matches requestedBassPc (filtered above)
                        // No adjustment needed - all candidates here are correct
                        prefAdjust = 0f;
                    }
                    else
                    {
                        // No inversion specified: candidate already matches rootPc (filtered above)
                        // Give bonus for root position
                        prefAdjust = -4.0f; // Strong bonus for root position
                    }

                    float totalCost = baseCost + prefAdjust;

                    // Determine degree type for debug logging
                    string degreeType;
                    if (candidatePc == rootPc)
                        degreeType = "Root";
                    else if (candidatePc == thirdPc)
                        degreeType = "3rd";
                    else if (candidatePc == fifthPc)
                        degreeType = "5th";
                    else if (hasSeventh && candidatePc == seventhPc)
                        degreeType = "7th";
                    else
                        degreeType = "Other";

                    // Track for debug
                    candidateMidis.Add(cand);
                    candidateDegrees.Add(degreeType);
                    candidateBaseCosts.Add(baseCost);
                    candidateTotalCosts.Add(totalCost);

                    // Track best overall candidate
                    if (totalCost < bestCost)
                    {
                        bestCandidate = cand;
                        bestCost = totalCost;
                    }

                    // Track root candidate for safeguard rule
                    if (candidatePc == rootPc && baseCost <= 7.0f)
                    {
                        hasRootCandidateWithin7 = true;
                        if (totalCost < bestRootTotalCost)
                        {
                            bestRootMidi = cand;
                            bestRootTotalCost = totalCost;
                        }
                    }

                    cand += 12;
                }
            }

            // Apply decisive safeguards
            int chosenMidi;
            if (inversionExplicitlySpecified)
            {
                // When inversion is explicitly specified, find the best candidate matching the requested bass pitch class
                // and force it (similar to root safeguard for implicit inversions)
                int bestRequestedMidi = -1;
                float bestRequestedCost = float.MaxValue;
                
                // Find the best candidate with the requested bass pitch class
                for (int i = 0; i < candidateMidis.Count; i++)
                {
                    int candidateMidi = candidateMidis[i];
                    int candidatePc = candidateMidi % 12;
                    if (candidatePc < 0) candidatePc += 12;
                    
                    if (candidatePc == requestedBassPc)
                    {
                        float candidateCost = candidateTotalCosts[i];
                        if (candidateCost < bestRequestedCost)
                        {
                            bestRequestedCost = candidateCost;
                            bestRequestedMidi = candidateMidi;
                        }
                    }
                }
                
                if (bestRequestedMidi >= 0)
                {
                    // FORCE the bass to the requested inversion bass pitch class
                    chosenMidi = bestRequestedMidi;
                }
                else
                {
                    // Fallback: use best overall candidate (shouldn't happen if candidates are generated correctly)
                    chosenMidi = bestCandidate;
                }
            }
            else if (hasRootCandidateWithin7)
            {
                // FORCE the bass to the best root candidate within 7 semitones when no inversion specified
                chosenMidi = bestRootMidi;
            }
            else
            {
                // Use the normal "best overall" candidate
                chosenMidi = bestCandidate;
            }

            // Fallback if no candidate found
            if (chosenMidi < 0)
            {
                chosenMidi = FindNearestBassNote(prevBass, requestedBassPc, bassOctave);
            }

            // Final validation: ensure chosen bass has correct pitch class (safety assert)
            int chosenPc = (chosenMidi % 12 + 12) % 12;
            if (chosenPc != requestedBassPc)
            {
                // This should never happen after filtering, but correct it if it does
                int oldMidi = chosenMidi;
                chosenMidi = FindNearestBassNote(prevBass, requestedBassPc, bassOctave);
                if (enableTendencyDebug)
                {
                    UnityEngine.Debug.LogWarning($"[Inversion Fix] Bass {oldMidi} (PC {chosenPc}) corrected to {chosenMidi} (required PC {requestedBassPc}).");
                }
            }

            // Unconditional debug logging when tendency debug is on
            if (enableTendencyDebug)
            {
                UnityEngine.Debug.Log($"[Bass Debug] Step {stepIndex}: prevBass={prevBass}, inversionExplicit={inversionExplicitlySpecified}, " +
                    $"hasRootCandidateWithin7={hasRootCandidateWithin7}, chosenBass={chosenMidi}");
                
                // Log all candidates evaluated
                for (int i = 0; i < candidateMidis.Count; i++)
                {
                    string marker = (candidateMidis[i] == chosenMidi) ? " [CHOSEN]" : "";
                    UnityEngine.Debug.Log($"[Bass Debug]   Candidate {i}: midi={candidateMidis[i]}, degree={candidateDegrees[i]}, " +
                        $"baseCost={candidateBaseCosts[i]:F1}, totalCost={candidateTotalCosts[i]:F2}{marker}");
                }
                
                if (hasRootCandidateWithin7)
                {
                    UnityEngine.Debug.Log($"[Bass Debug]   RootCandidate: midi={bestRootMidi}, totalCost={bestRootTotalCost:F2}");
                }
            }

            return chosenMidi;
        }

        /// <summary>
        /// Checks if applying a candidate MIDI to a voice would break spacing rules.
        /// </summary>
        private static bool WouldBreakSpacing(int[] voices, int voiceIndex, int candidateMidi)
        {
            // voices[0] = Bass, 1 = Tenor, 2 = Alto, 3 = Soprano
            // Create a copy with the candidate applied
            if (voices == null || voices.Length < 4) return false;
            int[] tmp = (int[])voices.Clone();
            tmp[voiceIndex] = candidateMidi;
            int b = tmp[0], t = tmp[1], a = tmp[2], s = tmp[3];
            return ViolatesHardSpacing(b, t, a, s);
        }
        
        /// <summary>
        /// Checks if placing #9 in the specified voice would create a minor 2nd crunch with the 3rd in Alto.
        /// This prevents top-voice #9–3rd m2 crunches (e.g., Soprano A#4 with Alto B4).
        /// </summary>
        /// <param name="voices">Current voice array [Bass, Tenor, Alto, Soprano]</param>
        /// <param name="voiceIndex">Voice index where #9 candidate would be placed (0=Bass, 1=Tenor, 2=Alto, 3=Soprano)</param>
        /// <param name="sharp9CandidateMidi">MIDI value of the #9 candidate</param>
        /// <param name="thirdPc">Pitch class of the 3rd (to identify which voice has the 3rd)</param>
        /// <returns>True if placing #9 here would create a m2 crunch with 3rd in Alto</returns>
        private static bool WouldCreateSharp9ThirdCrunch(int[] voices, int voiceIndex, int sharp9CandidateMidi, int thirdPc)
        {
            if (voices == null || voices.Length < 4) return false;
            
            // Only check if #9 is being placed in Soprano (voice index 3)
            if (voiceIndex != 3) return false;
            
            // Check if 3rd is in Alto (voice index 2)
            int altoPc = (voices[2] % 12 + 12) % 12;
            if (altoPc != thirdPc) return false;
            
            int altoThirdMidi = voices[2];
            int interval = Math.Abs(sharp9CandidateMidi - altoThirdMidi);
            
            // Case 1: Minor 2nd crunch (interval == 1 semitone)
            // Example: Soprano A#4 (70) with Alto B4 (71)
            if (interval == 1)
            {
                return true; // Minor 2nd crunch detected
            }
            
            // Case 2: #9 forced to high octave because A#4 was filtered out
            // If #9 is >= altoThirdMidi + 12, it means we jumped to next octave (A#5+)
            // This happens when the hard constraint filtered out A#4, forcing A#5
            // Example: Soprano A#5 (82) with Alto B4 (71) - A#4 (70) would have been better
            if (sharp9CandidateMidi >= altoThirdMidi + 12)
            {
                // Check if a lower octave #9 exists that would be below the 3rd
                int lowerSharp9Midi = sharp9CandidateMidi - 12; // A#4 = 70 when A#5 = 82
                if (lowerSharp9Midi >= 55 && lowerSharp9Midi < altoThirdMidi)
                {
                    // Lower octave #9 exists and is below 3rd - this placement forces high octave unnecessarily
                    return true; // Reject: forces #9 to high octave when 3rd should be moved down instead
                }
            }
            
            return false;
        }

        /// <summary>
        /// Gets a string representation of requested tensions for debug logging.
        /// </summary>
        private static string GetRequestedTensionsString(RequestedExtensions req)
        {
            var parts = new List<string>();
            if (req.Sus4) parts.Add("sus4");
            if (req.Add9) parts.Add("add9");
            if (req.Add11) parts.Add("add11");
            if (req.Tension9) parts.Add("9");
            if (req.TensionFlat9) parts.Add("b9");
            if (req.TensionSharp11) parts.Add("#11");
            return parts.Count > 0 ? string.Join(",", parts) : "none";
        }
        
        /// <summary>
        /// Validates that a candidate voicing (SATB MIDI array) contains all requested tension pitch classes.
        /// Returns true if all requested tensions (9, b9, 11, #11) are present in at least one voice.
        /// </summary>
        private static bool ValidateRequestedTensions(ChordEvent chordEvent, int[] voicesMidi, TheoryKey key)
        {
            if (voicesMidi == null || voicesMidi.Length == 0)
                return true; // Empty voicing - skip validation
            
            var req = chordEvent.Recipe.RequestedExtensions;
            if (!req.HasAny)
                return true; // No requested extensions - always valid
            
            // Compute root PC
            int rootPc = TheoryScale.GetDegreePitchClass(key, chordEvent.Recipe.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
            if (rootPc < 0) rootPc += 12;
            
            // Get realized pitch classes
            var realizedPcs = new HashSet<int>();
            foreach (int midi in voicesMidi)
            {
                int pc = (midi % 12 + 12) % 12;
                realizedPcs.Add(pc);
            }
            
            // Check each requested tension
            if (req.Tension9)
            {
                int ninePc = (rootPc + 2) % 12;
                if (!realizedPcs.Contains(ninePc))
                    return false;
            }
            
            if (req.TensionFlat9)
            {
                int b9Pc = (rootPc + 1) % 12;
                if (!realizedPcs.Contains(b9Pc))
                    return false;
            }
            
            if (req.TensionSharp11)
            {
                int sharp11Pc = (rootPc + 6) % 12;
                if (!realizedPcs.Contains(sharp11Pc))
                    return false;
            }
            
            // Note: Add9 and Add11 are optional color tones - they are not validated here
            // They are rewarded via soft scoring if present, but not enforced
            
            return true; // All requested tensions present
        }

        /// <summary>
        /// Ensures that the voiced chord contains the important chord tones
        /// (root, 3rd, 5th, 7th) at least once, adjusting upper voices if necessary.
        /// Only adjusts upper voices (indices 1..N-1); bass (index 0) remains unchanged.
        /// </summary>
        /// <param name="chordEvent">The chord event being voiced</param>
        /// <param name="voices">Array of MIDI notes (will be modified in-place)</param>
        /// <param name="numVoices">Number of voices</param>
        /// <param name="upperMinMidi">Minimum MIDI for upper voices</param>
        /// <param name="upperMaxMidi">Maximum MIDI for upper voices</param>
        /// <param name="protectSoprano">If true, don't modify the highest voice (soprano)</param>
        /// <param name="lockedResolutionVoices">Array indicating which voices have locked 7th resolutions and should not be modified (null = no locks)</param>
        private static void FixChordToneCoverage(
            ChordEvent chordEvent,
            int[] voices,
            int numVoices,
            int upperMinMidi,
            int upperMaxMidi,
            bool protectSoprano = false,
            bool[] lockedResolutionVoices = null,
            int stepIndex = -1)
        {
            // CRITICAL: SATB identity mode - preserve lane assignments
            // voices[0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano
            // We can modify MIDI values within lanes, but NEVER swap lanes
            // Capture initial lane assignments for safeguard
            int[] initialLaneAssignments = voices != null && voices.Length >= 4 
                ? new int[] { voices[0], voices[1], voices[2], voices[3] } 
                : null;
            
            // Trace B: At entry to FixChordToneCoverage (get rootPc for trace)
            int rootPcForTrace = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPcForTrace < 0) rootPcForTrace = 0;
            rootPcForTrace = (rootPcForTrace + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
            if (rootPcForTrace < 0) rootPcForTrace += 12;

            if (s_debugTensionDetect && stepIndex >= 0)
            {
                var reqTrace = chordEvent.Recipe.RequestedExtensions;
                var reqList = new List<string>();
                if (reqTrace.TensionFlat9) reqList.Add("b9");
                if (reqTrace.Tension9) reqList.Add("9");
                if (reqTrace.TensionSharp11) reqList.Add("#11");
                string reqStr = reqList.Count > 0 ? string.Join(",", reqList) : "none";
                string label = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                
                var voiceInfo = new List<string>();
                var pcs = new List<int>();
                for (int i = 0; i < voices.Length && i < 4; i++)
                {
                    int midi = voices[i];
                    int pc = (midi % 12 + 12) % 12;
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                    voiceInfo.Add($"{voiceName}={midi}({pitchName},pc={pc})");
                    pcs.Add(pc);
                }
                
                if (s_debugTensionVerbose && s_debugTensionDetect)
                {
                    UnityEngine.Debug.Log(
                        $"[PLAY_VOICES_TRACE] B) Entry to FixChordToneCoverage:\n" +
                        $"  step={stepIndex} label='{label}' rootPc={rootPcForTrace} requested=[{reqStr}]\n" +
                        $"  voices: {string.Join(" ", voiceInfo)}\n" +
                        $"  pcs=[{string.Join(",", pcs.OrderBy(x => x))}]");
                }
            }
            
            // Debug instrumentation: log state before FixChordToneCoverage
            if (GetTendencyDebug())
            {
                var pcsBefore = new List<int>();
                foreach (int m in voices)
                    pcsBefore.Add((m % 12 + 12) % 12);

                string chordName = $"{chordEvent.Key} {chordEvent.Recipe}";
                UnityEngine.Debug.Log(
                    $"[Coverage Debug] BEFORE FixChordToneCoverage for {chordName}: " +
                    $"voices=[{string.Join(",", voices)}], pcs=[{string.Join(",", pcsBefore)}]");
            }
            
            // Get chord tone pitch classes
            var chordTonePcs = GetChordTonePitchClasses(chordEvent);
            if (chordTonePcs.Count < 3)
            {
                return; // Can't fix if we don't have enough chord tones
            }

            int rootPc = chordTonePcs[0];
            
            // Trace: Log target PCs before voicing (point 2)
            // Note: stepIndex is not available here, so we'll trace in VoiceNextChord where we have step info
            int thirdPc = chordTonePcs[1];
            int fifthPc = chordTonePcs[2];
            int seventhPc = chordTonePcs.Count > 3 ? chordTonePcs[3] : -1;

            bool hasSeventh = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                              chordEvent.Recipe.SeventhQuality != SeventhQuality.None;

            // Build priority mapping for each chord tone pitch class
            var pcToPriority = new Dictionary<int, ChordTonePriority>();
            pcToPriority[rootPc] = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Root);
            pcToPriority[thirdPc] = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Third);
            pcToPriority[fifthPc] = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Fifth);
            if (hasSeventh && seventhPc >= 0)
            {
                pcToPriority[seventhPc] = ChordTonePriorityHelper.GetPriorityForTone(chordEvent.Recipe, ChordToneRole.Seventh);
            }

            // Determine required pitch classes based on priorities
            var requiredPcs = new HashSet<int>();
            var preferredPcs = new HashSet<int>();
            var optionalPcs = new HashSet<int>();

            // Categorize pitch classes by priority
            foreach (var kvp in pcToPriority)
            {
                int pc = kvp.Key;
                ChordTonePriority priority = kvp.Value;
                if (priority == ChordTonePriority.Required)
                {
                    requiredPcs.Add(pc);
                }
                else if (priority == ChordTonePriority.Preferred)
                {
                    preferredPcs.Add(pc);
                }
                else
                {
                    optionalPcs.Add(pc);
                }
            }

            // Special case: If we have exactly numVoices distinct required tones, keep all of them without doubling
            // This ensures chords like Gdim7 (4 required tones) or E7#5 (4 required tones) keep all tones
            int requiredToneCount = ChordTonePriorityHelper.CountRequiredTones(chordEvent.Recipe, hasSeventh);
            if (requiredToneCount == numVoices)
            {
                // All required tones must be present, no doubling allowed
                // The existing logic below will ensure all required tones are present
                // We've already built requiredPcs with only Required tones, so the logic will work correctly
                if (enableTendencyDebug)
                {
                    UnityEngine.Debug.Log($"[Coverage Debug] Special case: {requiredToneCount} required tones for {numVoices} voices - keeping all without doubling");
                }
            }

            // Count occurrences of each pitch class in current voicing
            var pcCounts = new Dictionary<int, int>();
            for (int i = 0; i < voices.Length; i++)
            {
                int pc = (voices[i] % 12 + 12) % 12;
                pcCounts[pc] = pcCounts.GetValueOrDefault(pc, 0) + 1;
            }
            
            // PROTECTION: Identify which voices contain the required 7th (if any)
            // These voices should not be replaced unless we're trying to place the 7th itself
            var voicesWithSeventh = new HashSet<int>();
            if (hasSeventh && seventhPc >= 0)
            {
                for (int i = 0; i < voices.Length; i++)
                {
                    int pc = (voices[i] % 12 + 12) % 12;
                    if (pc == seventhPc)
                    {
                        voicesWithSeventh.Add(i);
                    }
                }
            }

            // Debug logging for 7th chord coverage enforcement
            if (enableTendencyDebug && hasSeventh)
            {
                var beforePcs = new List<string>();
                for (int i = 0; i < voices.Length; i++)
                {
                    int midi = voices[i];
                    string name = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                    beforePcs.Add(name);
                }
                UnityEngine.Debug.Log($"[ChordCoverage Debug] Step: Chord has 7th, enforcing presence. Before: {string.Join(", ", beforePcs)}");
            }
            
            // Enforce requested tensions (9, b9, 11, #11) - require their pitch classes to appear in at least one voice
            var req = chordEvent.Recipe.RequestedExtensions;
            
            // Trace: Log requiredPcs BEFORE adding requested tensions (verbose only)
            if (s_debugTensionVerbose && s_debugTensionDetect)
            {
                string requiredPcsBeforeStr = string.Join(",", requiredPcs.OrderBy(x => x));
                var reqFlags = new List<string>();
                if (req.TensionFlat9) reqFlags.Add("TensionFlat9=true");
                if (req.Tension9) reqFlags.Add("Tension9=true");
                if (req.TensionSharp11) reqFlags.Add("TensionSharp11=true");
                string reqFlagsStr = reqFlags.Count > 0 ? string.Join(" ", reqFlags) : "none";
                UnityEngine.Debug.Log(
                    $"[REQ_EXT_ENFORCE_TRACE] step={stepIndex} entering tension enforcement:\n" +
                    $"  rootPc={rootPc}\n" +
                    $"  requested flags: {reqFlagsStr}\n" +
                    $"  requiredPcs BEFORE adding tensions=[{requiredPcsBeforeStr}]");
            }
            
            // Debug: Log requested extensions and computed PCs (verbose - gated)
            if (s_debugTensionVerbose && s_debugTensionDetect && req.HasAny)
            {
                int computedRootPc = rootPc;
                var computedTensionPcs = new Dictionary<string, int>();
                if (req.Tension9) computedTensionPcs["9"] = (computedRootPc + 2) % 12;
                if (req.TensionFlat9) computedTensionPcs["b9"] = (computedRootPc + 1) % 12;
                if (req.TensionSharp11) computedTensionPcs["#11"] = (computedRootPc + 6) % 12;
                if (req.Add9) computedTensionPcs["add9"] = (computedRootPc + 2) % 12;
                if (req.Add11) computedTensionPcs["add11"] = (computedRootPc + 5) % 12;
                
                var requestedList = new List<string>();
                if (req.Tension9) requestedList.Add("9");
                if (req.TensionFlat9) requestedList.Add("b9");
                if (req.TensionSharp11) requestedList.Add("#11");
                if (req.Add9) requestedList.Add("add9");
                if (req.Add11) requestedList.Add("add11");
                if (req.Sus4) requestedList.Add("sus4");
                
                var realizedPcsDebug = new HashSet<int>();
                for (int i = 0; i < voices.Length; i++)
                {
                    int pc = (voices[i] % 12 + 12) % 12;
                    realizedPcsDebug.Add(pc);
                }
                
                var requiredPcsBefore = new HashSet<int>(requiredPcs);
                var satisfiedTensions = new List<string>();
                var unsatisfiedTensions = new List<string>();
                
                if (req.Tension9)
                {
                    int ninePc = (computedRootPc + 2) % 12;
                    if (realizedPcsDebug.Contains(ninePc))
                        satisfiedTensions.Add("9");
                    else
                        unsatisfiedTensions.Add("9");
                }
                if (req.TensionFlat9)
                {
                    int b9Pc = (computedRootPc + 1) % 12;
                    if (realizedPcsDebug.Contains(b9Pc))
                        satisfiedTensions.Add("b9");
                    else
                        unsatisfiedTensions.Add("b9");
                }
                if (req.TensionSharp11)
                {
                    int sharp11Pc = (computedRootPc + 6) % 12;
                    if (realizedPcsDebug.Contains(sharp11Pc))
                        satisfiedTensions.Add("#11");
                    else
                        unsatisfiedTensions.Add("#11");
                }
                
                string computedPcsStr = string.Join(",", computedTensionPcs.Select(kvp => $"{kvp.Key}={kvp.Value}"));
                string requestedStr = string.Join(",", requestedList);
                string realizedStr = string.Join(",", realizedPcsDebug.OrderBy(x => x));
                string requiredBeforeStr = string.Join(",", requiredPcsBefore.OrderBy(x => x));
                string satisfiedStr = satisfiedTensions.Count > 0 ? string.Join(",", satisfiedTensions) : "none";
                string unsatisfiedStr = unsatisfiedTensions.Count > 0 ? string.Join(",", unsatisfiedTensions) : "none";
                
                UnityEngine.Debug.Log(
                    $"[REQ_EXT_DEBUG] rootPC={computedRootPc} computedPCs=[{computedPcsStr}] " +
                    $"requested=[{requestedStr}] realizedPCs=[{realizedStr}] " +
                    $"requiredPCsBefore=[{requiredBeforeStr}] satisfied=[{satisfiedStr}] unsatisfied=[{unsatisfiedStr}]");
            }
            
            // CRITICAL FIX: Check individual tension flags, not just HasAny
            // HasAny might return false if only tensions are requested (no add9/add11/sus4)
            // We need to check tensions separately to ensure they're always enforced
            bool hasRequestedTensions = req.Tension9 || req.TensionFlat9 || req.TensionSharp9 || req.TensionSharp11;
            
            if (req.HasAny || hasRequestedTensions)
            {
                // Get realized pitch classes
                var realizedPcs = new HashSet<int>();
                for (int i = 0; i < voices.Length; i++)
                {
                    int pc = (voices[i] % 12 + 12) % 12;
                    realizedPcs.Add(pc);
                }
                
                // Trace: Log if we're entering the enforcement block
                if (s_debugTensionVerbose && s_debugTensionDetect && hasRequestedTensions)
                {
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_ENFORCE_TRACE] step={stepIndex} entering tension enforcement block:\n" +
                        $"  req.HasAny={req.HasAny}\n" +
                        $"  hasRequestedTensions={hasRequestedTensions}\n" +
                        $"  TensionFlat9={req.TensionFlat9} Tension9={req.Tension9} TensionSharp9={req.TensionSharp9} TensionSharp11={req.TensionSharp11}");
                }
                
                // Check each requested tension and add if missing
                if (req.Tension9)
                {
                    int ninePc = (rootPc + 2) % 12;
                    if (!realizedPcs.Contains(ninePc))
                    {
                        // Add 9th to required list (will be enforced below)
                        requiredPcs.Add(ninePc);
                    }
                }
                
                if (req.TensionFlat9)
                {
                    // b9 is root + 1 semitone (e.g., F→Gb, not F→G)
                    // Ensure we're using the correct PC calculation
                    int b9Pc = (rootPc + 1) % 12;
                    int ninePc = (rootPc + 2) % 12;
                    
                    // Trace: Log b9 enforcement decision
                    if (s_debugTensionVerbose && s_debugTensionDetect)
                    {
                        bool b9AlreadyPresent = realizedPcs.Contains(b9Pc);
                        bool natural9Present = realizedPcs.Contains(ninePc);
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_ENFORCE_TRACE] step={stepIndex} TensionFlat9=true:\n" +
                            $"  computed b9Pc={b9Pc} ninePc={ninePc}\n" +
                            $"  b9Pc in realizedPcs={b9AlreadyPresent}\n" +
                            $"  natural9Pc in realizedPcs={natural9Present}");
                    }
                    
                    // CRITICAL: Verify that natural 9 is NOT present when b9 is requested
                    if (realizedPcs.Contains(ninePc) && !realizedPcs.Contains(b9Pc))
                    {
                        if (s_debugTensionDetect)
                        {
                            string realizedStr = string.Join(",", realizedPcs.OrderBy(x => x));
                            UnityEngine.Debug.LogWarning(
                                $"[REQ_EXT_WRONG_TENSION] requested=b9 but realized natural9 instead " +
                                $"(rootPc={rootPc} b9Pc={b9Pc} ninePc={ninePc} realized=[{realizedStr}])");
                        }
                        // Do NOT accept natural 9 as satisfying b9 - still require b9Pc
                    }
                    
                    if (!realizedPcs.Contains(b9Pc))
                    {
                        requiredPcs.Add(b9Pc);
                        if (s_debugTensionDetect)
                        {
                            if (s_debugTensionVerbose)
                            {
                                string requiredPcsAfterStr = string.Join(",", requiredPcs.OrderBy(x => x));
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_ENFORCE_TRACE] step={stepIndex} ADDED b9Pc={b9Pc} to requiredPcs\n" +
                                    $"  requiredPcs AFTER=[{requiredPcsAfterStr}]");
                            }
                        }
                    }
                    else
                    {
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_ENFORCE_TRACE] step={stepIndex} b9Pc={b9Pc} already in realizedPcs, skipping add");
                        }
                    }
                }
                
                if (req.TensionSharp9)
                {
                    // #9 is root + 3 semitones (e.g., G→Bb for G7#9)
                    int sharp9Pc = (rootPc + 3) % 12;
                    int ninePc = (rootPc + 2) % 12;
                    int b9Pc = (rootPc + 1) % 12;
                    
                    // Trace: Log #9 enforcement decision
                    if (s_debugTensionVerbose && s_debugTensionDetect)
                    {
                        bool sharp9AlreadyPresent = realizedPcs.Contains(sharp9Pc);
                        bool natural9Present = realizedPcs.Contains(ninePc);
                        bool flat9Present = realizedPcs.Contains(b9Pc);
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_ENFORCE_TRACE] step={stepIndex} TensionSharp9=true:\n" +
                            $"  computed sharp9Pc={sharp9Pc} ninePc={ninePc} b9Pc={b9Pc}\n" +
                            $"  sharp9Pc in realizedPcs={sharp9AlreadyPresent}\n" +
                            $"  natural9Pc in realizedPcs={natural9Present}\n" +
                            $"  b9Pc in realizedPcs={flat9Present}");
                    }
                    
                    // CRITICAL: Verify that natural 9 or b9 are NOT present when #9 is requested
                    if ((realizedPcs.Contains(ninePc) || realizedPcs.Contains(b9Pc)) && !realizedPcs.Contains(sharp9Pc))
                    {
                        if (s_debugTensionDetect)
                        {
                            string realizedStr = string.Join(",", realizedPcs.OrderBy(x => x));
                            UnityEngine.Debug.LogWarning(
                                $"[REQ_EXT_WRONG_TENSION] requested=#9 but realized natural9 or b9 instead " +
                                $"(rootPc={rootPc} sharp9Pc={sharp9Pc} ninePc={ninePc} b9Pc={b9Pc} realized=[{realizedStr}])");
                        }
                        // Do NOT accept natural 9 or b9 as satisfying #9 - still require sharp9Pc
                    }
                    
                    if (!realizedPcs.Contains(sharp9Pc))
                    {
                        requiredPcs.Add(sharp9Pc);
                        if (s_debugTensionDetect)
                        {
                            if (s_debugTensionVerbose)
                            {
                                string requiredPcsAfterStr = string.Join(",", requiredPcs.OrderBy(x => x));
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_ENFORCE_TRACE] step={stepIndex} ADDED sharp9Pc={sharp9Pc} to requiredPcs\n" +
                                    $"  requiredPcs AFTER=[{requiredPcsAfterStr}]");
                            }
                        }
                    }
                    else
                    {
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_ENFORCE_TRACE] step={stepIndex} sharp9Pc={sharp9Pc} already in realizedPcs, skipping add");
                        }
                    }
                }
                
                if (req.TensionSharp11)
                {
                    int sharp11Pc = (rootPc + 6) % 12;
                    if (!realizedPcs.Contains(sharp11Pc))
                    {
                        requiredPcs.Add(sharp11Pc);
                    }
                }
                
                // Note: Add9 and Add11 are NOT added to requiredPcs - they are optional color tones
                // They will be rewarded via soft scoring if present, but not enforced
            }
            
            // Trace C: After tension enforcement block
            if (s_debugTensionDetect && stepIndex >= 0)
            {
                var reqTrace = chordEvent.Recipe.RequestedExtensions;
                var reqList = new List<string>();
                if (reqTrace.TensionFlat9) reqList.Add("b9");
                if (reqTrace.Tension9) reqList.Add("9");
                if (reqTrace.TensionSharp11) reqList.Add("#11");
                string reqStr = reqList.Count > 0 ? string.Join(",", reqList) : "none";
                string label = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                
                var voiceInfo = new List<string>();
                var pcs = new List<int>();
                for (int i = 0; i < voices.Length && i < 4; i++)
                {
                    int midi = voices[i];
                    int pc = (midi % 12 + 12) % 12;
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                    voiceInfo.Add($"{voiceName}={midi}({pitchName},pc={pc})");
                    pcs.Add(pc);
                }
                string requiredPcsStr = string.Join(",", requiredPcs.OrderBy(x => x));
                
                if (s_debugTensionVerbose && s_debugTensionDetect)
                {
                    UnityEngine.Debug.Log(
                        $"[PLAY_VOICES_TRACE] C) After tension enforcement block:\n" +
                        $"  step={stepIndex} label='{label}' rootPc={rootPc} requested=[{reqStr}]\n" +
                        $"  requiredPcs=[{requiredPcsStr}]\n" +
                        $"  voices: {string.Join(" ", voiceInfo)}\n" +
                        $"  pcs=[{string.Join(",", pcs.OrderBy(x => x))}]");
                }
            }
            
            // Debug logging for requested extensions contribution to requiredPcs
            if (s_debugTensionDetect && req.HasAny)
            {
                var contributedExtensions = new List<string>();
                var optionalExtensions = new List<string>();
                if (req.Tension9 && requiredPcs.Contains((rootPc + 2) % 12)) contributedExtensions.Add("9");
                if (req.TensionFlat9 && requiredPcs.Contains((rootPc + 1) % 12)) contributedExtensions.Add("b9");
                if (req.TensionSharp9 && requiredPcs.Contains((rootPc + 3) % 12)) contributedExtensions.Add("#9");
                if (req.TensionSharp11 && requiredPcs.Contains((rootPc + 6) % 12)) contributedExtensions.Add("#11");
                if (req.Add11) optionalExtensions.Add("add11");
                if (req.Add9) optionalExtensions.Add("add9");
                
                string requiredPcsStr = string.Join(",", requiredPcs.OrderBy(x => x));
                string contributedStr = contributedExtensions.Count > 0 ? string.Join(",", contributedExtensions) : "none";
                string optionalStr = optionalExtensions.Count > 0 ? string.Join(",", optionalExtensions) : "none";
                if (s_debugTensionVerbose && s_debugTensionDetect)
                {
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_ENFORCE] requiredPcs=[{requiredPcsStr}] " +
                        $"contributedBy=[{contributedStr}] optional=[{optionalStr}]");
                }
            }

            // CRITICAL: Identify which voices contain requested tensions - these must be protected
            // Also protect voices containing the required 7th (if chord requires a 7th)
            // Declare outside the if block so it's available in the enforcement loop
            var protectedVoiceIndices = new HashSet<int>();
            
            // Build requestedTensionPcs set: DIRECT guard for victim selection
            // This is used to NEVER overwrite voices containing requested tensions
            var requestedTensionPcs = new HashSet<int>();
            if (req.TensionFlat9) requestedTensionPcs.Add((rootPc + 1) % 12);
            if (req.Tension9) requestedTensionPcs.Add((rootPc + 2) % 12);
            if (req.TensionSharp9) requestedTensionPcs.Add((rootPc + 3) % 12);
            if (req.TensionSharp11) requestedTensionPcs.Add((rootPc + 6) % 12);
            
            // Build protectedPCs set: required tones + requested tension PCs
            // This is used to prefer overwriting non-protected voices when inserting missing required tones
            var protectedPCs = new HashSet<int>(requiredPcs); // Start with all required tones
            
            // Add requested tension PCs to protected set
            foreach (int tensionPc in requestedTensionPcs)
            {
                protectedPCs.Add(tensionPc);
            }
            
            // PROTECTION: Protect voices containing the required 7th
            if (hasSeventh && seventhPc >= 0)
            {
                for (int i = 0; i < voices.Length; i++)
                {
                    int voicePc = (voices[i] % 12 + 12) % 12;
                    if (voicePc == seventhPc)
                    {
                        protectedVoiceIndices.Add(i);
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            UnityEngine.Debug.Log(
                                $"[7TH_PROTECT] step={stepIndex} protecting voice {i} (contains required 7th, pc={seventhPc})");
                        }
                    }
                }
            }
            
            if (req.HasAny || hasRequestedTensions)
            {
                for (int i = 0; i < voices.Length; i++)
                {
                    int voicePc = (voices[i] % 12 + 12) % 12;
                    // Check if this voice contains a requested tension
                    if (req.TensionFlat9 && voicePc == (rootPc + 1) % 12)
                    {
                        protectedVoiceIndices.Add(i);
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_PROTECT] step={stepIndex} protecting voice {i} (contains b9, pc={voicePc})");
                        }
                    }
                    if (req.Tension9 && voicePc == (rootPc + 2) % 12)
                    {
                        protectedVoiceIndices.Add(i);
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_PROTECT] step={stepIndex} protecting voice {i} (contains 9, pc={voicePc})");
                        }
                    }
                    if (req.TensionSharp9 && voicePc == (rootPc + 3) % 12)
                    {
                        protectedVoiceIndices.Add(i);
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_PROTECT] step={stepIndex} protecting voice {i} (contains #9, pc={voicePc})");
                        }
                    }
                    if (req.TensionSharp11 && voicePc == (rootPc + 6) % 12)
                    {
                        protectedVoiceIndices.Add(i);
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_PROTECT] step={stepIndex} protecting voice {i} (contains #11, pc={voicePc})");
                        }
                    }
                }
            }

            // Entry diagnostics for V9 chords (gated)
            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
            {
                string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                if (token.Contains("V9") || req.Tension9 || req.TensionFlat9 || req.TensionSharp9)
                {
                    string voiceInfo = string.Join(", ", voices.Select((v, idx) => {
                        string voiceName = idx == 0 ? "B" : idx == 1 ? "T" : idx == 2 ? "A" : idx == 3 ? "S" : $"v{idx}";
                        int pc = (v % 12 + 12) % 12;
                        return $"{voiceName}={v}(pc={pc})";
                    }));
                    string requestedTensionPcsStr = string.Join(",", requestedTensionPcs);
                    string protectedIndicesStr = string.Join(", ", protectedVoiceIndices);
                    string protectedReasons = string.Join(", ", protectedVoiceIndices.Select(idx => {
                        int vPc = (voices[idx] % 12 + 12) % 12;
                        if (requiredPcs.Contains(vPc)) return $"v{idx}:required(pc={vPc})";
                        if (req.TensionFlat9 && vPc == (rootPc + 1) % 12) return $"v{idx}:b9(pc={vPc})";
                        if (req.Tension9 && vPc == (rootPc + 2) % 12) return $"v{idx}:9(pc={vPc})";
                        if (req.TensionSharp9 && vPc == (rootPc + 3) % 12) return $"v{idx}:#9(pc={vPc})";
                        if (req.TensionSharp11 && vPc == (rootPc + 6) % 12) return $"v{idx}:#11(pc={vPc})";
                        return $"v{idx}:?(pc={vPc})";
                    }));
                    
                    UnityEngine.Debug.Log(
                        $"[FIX_COVERAGE_ENTRY] step={stepIndex} token={token} rootPc={rootPc}\n" +
                        $"  voices BTAS: {voiceInfo}\n" +
                        $"  requestedTensionPcs=[{requestedTensionPcsStr}]\n" +
                        $"  protectedVoiceIndices=[{protectedIndicesStr}] reasons=[{protectedReasons}]");
                }
            }
            
            // For each required pitch class that is missing, fix it
            // Process in priority order: 
            // CRITICAL: For 7th chords, 7th MUST be placed BEFORE natural 9 to prevent 9 from using the 7th's voice slot
            // 1. Required chord tones (3rd, required 5th for dim/aug, and 7th) - HIGHEST PRIORITY
            // 2. Requested tensions (b9/#9/#11) - HIGH PRIORITY
            // 3. Natural 9 (Tension9) - Process AFTER 7th to ensure 7th voice slot is protected
            // 4. Root
            // 5. Optional 5th (perfect 5th only - can be skipped if it would overwrite tensions)
            var sortedRequiredPcs = new List<int>();
            
            // Determine if 5th is required (for dim/aug triads)
            bool fifthIsRequired = requiredPcs.Contains(fifthPc);
            
            // FIRST: Add 3rd, required 5th (dim/aug), and 7th (if missing) - CRITICAL identity tones
            // This ensures required 5th for dim/aug triads gets placed early, and 7th gets placed before natural 9
            if (requiredPcs.Contains(thirdPc) && (!pcCounts.ContainsKey(thirdPc) || pcCounts[thirdPc] == 0))
            {
                sortedRequiredPcs.Add(thirdPc);
            }
            // CRITICAL FIX: Required 5th (dim/aug) must be enforced early, not as lowest priority
            if (fifthIsRequired && (!pcCounts.ContainsKey(fifthPc) || pcCounts[fifthPc] == 0))
            {
                sortedRequiredPcs.Add(fifthPc);
            }
            if (hasSeventh && seventhPc >= 0 && requiredPcs.Contains(seventhPc) && (!pcCounts.ContainsKey(seventhPc) || pcCounts[seventhPc] == 0))
            {
                sortedRequiredPcs.Add(seventhPc);
            }
            
            // SECOND: Add requested tensions EXCEPT natural 9 (which goes after 7th)
            if (req.TensionFlat9)
            {
                int b9Pc = (rootPc + 1) % 12;
                if (requiredPcs.Contains(b9Pc) && (!pcCounts.ContainsKey(b9Pc) || pcCounts[b9Pc] == 0))
                {
                    if (!sortedRequiredPcs.Contains(b9Pc))
                    {
                        sortedRequiredPcs.Add(b9Pc);
                    }
                }
            }
            if (req.TensionSharp9)
            {
                int sharp9Pc = (rootPc + 3) % 12;
                if (requiredPcs.Contains(sharp9Pc) && (!pcCounts.ContainsKey(sharp9Pc) || pcCounts[sharp9Pc] == 0))
                {
                    if (!sortedRequiredPcs.Contains(sharp9Pc))
                    {
                        sortedRequiredPcs.Add(sharp9Pc);
                    }
                }
            }
            if (req.TensionSharp11)
            {
                int sharp11Pc = (rootPc + 6) % 12;
                if (requiredPcs.Contains(sharp11Pc) && (!pcCounts.ContainsKey(sharp11Pc) || pcCounts[sharp11Pc] == 0))
                {
                    if (!sortedRequiredPcs.Contains(sharp11Pc))
                    {
                        sortedRequiredPcs.Add(sharp11Pc);
                    }
                }
            }
            
            // THIRD: Add natural 9 AFTER 7th (ensures 7th voice slot is already protected)
            if (req.Tension9)
            {
                int ninePc = (rootPc + 2) % 12;
                if (requiredPcs.Contains(ninePc) && (!pcCounts.ContainsKey(ninePc) || pcCounts[ninePc] == 0))
                {
                    if (!sortedRequiredPcs.Contains(ninePc))
                    {
                        sortedRequiredPcs.Add(ninePc);
                    }
                }
            }
            
            // Third: Add root (if missing)
            if (requiredPcs.Contains(rootPc) && (!pcCounts.ContainsKey(rootPc) || pcCounts[rootPc] == 0))
            {
                if (!sortedRequiredPcs.Contains(rootPc))
                {
                    sortedRequiredPcs.Add(rootPc);
                }
            }
            
            // Note: Required 5th (dim/aug) was already added above in FIRST priority group
            // Do NOT add it again here (it would be duplicate)
            
            // Finally: Add any other required PCs that weren't categorized above
            foreach (int pc in requiredPcs)
            {
                if (!sortedRequiredPcs.Contains(pc) && (!pcCounts.ContainsKey(pc) || pcCounts[pc] == 0))
                {
                    sortedRequiredPcs.Add(pc);
                }
            }
            
            // Calculate 3rd MIDI for #9 vs 3rd constraint (find lowest 3rd in current voicing)
            // thirdPc is already calculated above from chordTonePcs[1]
            int thirdMidi = -1;
            for (int i = 0; i < voices.Length; i++)
            {
                int voicePc = (voices[i] % 12 + 12) % 12;
                if (voicePc == thirdPc)
                {
                    if (thirdMidi < 0 || voices[i] < thirdMidi)
                    {
                        thirdMidi = voices[i];
                    }
                }
            }
            
            foreach (int requiredPc in sortedRequiredPcs)
            {
                // Determine if this is tension enforcement (needed for special 5th replacement logic)
                bool isTensionEnforcement = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ||
                                           (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ||
                                           (req.Tension9 && requiredPc == (rootPc + 2) % 12) ||
                                           (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12);
                
                // CRITICAL: #9 must be >= 3rd in MIDI (hard constraint for dominant chords)
                bool isSharp9Enforcement = (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12);
                
                if (pcCounts.ContainsKey(requiredPc) && pcCounts[requiredPc] > 0)
                {
                    // Debug: Log when required PC is already present
                    if (s_debugTensionVerbose && s_debugTensionDetect && req.HasAny && isTensionEnforcement)
                    {
                        string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                             (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ? "#9" :
                                             (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                             (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_DEBUG] requiredPC={requiredPc} (tension={tensionName}) already present - skipping enforcement");
                    }
                    continue; // Already present
                }
                
                // DIAGNOSTIC: Log missing required PC for diminished triads
                bool isDiminishedTriad = chordEvent.Recipe.Quality == ChordQuality.Diminished &&
                                         chordEvent.Recipe.Extension != ChordExtension.Seventh &&
                                         chordEvent.Recipe.SeventhQuality == SeventhQuality.None;
                bool shouldLogDimTriadDiag = Sonoria.MusicTheory.RegressionHarness.ShouldLogDiminishedTriadDiagnostics() && isDiminishedTriad;
                
                // Track rejection reasons for diagnostic logging
                var rejectionLog = new List<string>();
                
                if (shouldLogDimTriadDiag)
                {
                    // Build current voicing string
                    var voiceDetails = new List<string>();
                    for (int v = 0; v < voices.Length && v < 4; v++)
                    {
                        int midi = voices[v];
                        int pc = (midi % 12 + 12) % 12;
                        string voiceName = v == 0 ? "B" : v == 1 ? "T" : v == 2 ? "A" : "S";
                        string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                        voiceDetails.Add($"{voiceName}={pitchName}({midi} pc={pc})");
                    }
                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    string voicesStr = string.Join(",", voiceDetails);
                    
                    UnityEngine.Debug.LogWarning(
                        $"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} missingPc={requiredPc} curr=[{voicesStr}]");
                }
                
                // Debug: Log when enforcing a required PC
                if (s_debugTensionVerbose && s_debugTensionDetect && req.HasAny && isTensionEnforcement)
                {
                    string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                         (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ? "#9" :
                                         (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                         (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_DEBUG] enforcing requiredPC={requiredPc} (tension={tensionName}) - missing from voicing");
                }

                // Compute effective upper bound for new candidates
                int effectiveUpperMax = upperMaxMidi;
                if (protectSoprano && voices.Length > 0)
                {
                    int sopranoMidi = voices[voices.Length - 1];
                    // Inner voices must be strictly below soprano
                    effectiveUpperMax = Math.Min(upperMaxMidi, sopranoMidi - 1);
                }

                // CRITICAL: #9 candidates should be constrained by voice range, NOT by the current 3rd's MIDI
                // We removed the hard "#9 >= 3rd" constraint from candidate generation to allow the solver
                // to discover that placing #9 below 3rd is bad and reassign the 3rd to a lower voice.
                // The "#9 >= 3rd" preference is now a soft rule in candidate evaluation.
                int effectiveLowerMin = upperMinMidi;
                
                // Generate candidate MIDI notes for the required pitch class
                // CRITICAL: Only generate candidates with the exact required pitch class
                // This ensures b9 (root+1), #9 (root+3), and 9 (root+2) are mutually exclusive
                var candidates = GenerateCandidatesInRange(new List<int> { requiredPc }, effectiveLowerMin, effectiveUpperMax);
                
                // DIAGNOSTIC: Log candidate generation for diminished triads
                if (shouldLogDimTriadDiag)
                {
                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    string candidateExamples = candidates.Count > 0 ? string.Join(",", candidates.Take(5)) : "NONE";
                    string candidateLogMsg = $"Generated {candidates.Count} candidates for missingPc={requiredPc} in range [{effectiveLowerMin}, {effectiveUpperMax}], examples: {candidateExamples}";
                    rejectionLog.Add(candidateLogMsg);
                    // ALSO print directly to ensure it appears
                    UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {candidateLogMsg}");
                }
                
                // CHECKPOINT B: Immediately after candidate generation (before any selection/enforcement)
                if (s_debugSharp9OctaveTrace && stepIndex == 0 && isSharp9Enforcement)
                {
                    string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    // Log available candidates for each voice lane
                    string[] voiceNames = { "B", "T", "A", "S" };
                    // Calculate bass range from current voices (bass is typically in octave 3-4 range)
                    int bassMin = voices.Length > 0 ? (voices[0] / 12) * 12 : 35;
                    int bassMax = voices.Length > 0 ? ((voices[0] / 12) + 1) * 12 - 1 : 47;
                    int[] voiceMins = { bassMin, upperMinMidi, upperMinMidi, upperMinMidi };
                    int[] voiceMaxs = { bassMax, upperMaxMidi, upperMaxMidi, upperMaxMidi };
                    for (int v = 0; v < 4; v++)
                    {
                        var voiceCandidates = candidates.Where(c => c >= voiceMins[v] && c <= voiceMaxs[v]).ToList();
                        bool hasPc = voiceCandidates.Count > 0;
                        int closestMidi = hasPc ? voiceCandidates.OrderBy(c => Math.Abs(c - voiceMins[v])).First() : -1;
                        string pitchName = closestMidi >= 0 ? TheoryPitch.GetPitchNameFromMidi(closestMidi, chordEvent.Key) : "none";
                        UnityEngine.Debug.Log(
                            $"[SHARP9_TRACE][CAND] step=0 chord={chordLabel} voice={voiceNames[v]} hasPc{requiredPc}={hasPc} closestMidi={closestMidi}({pitchName})");
                    }
                }
                
                if (candidates.Count == 0)
                {
                    // DIAGNOSTIC: Log when no candidates found (out of register)
                    if (shouldLogDimTriadDiag)
                    {
                        rejectionLog.Add($"No candidates in range [{effectiveLowerMin}, {effectiveUpperMax}] (out of register bounds)");
                        
                        // Print rejection log immediately since we're about to continue
                        string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                        string rejectionStr = rejectionLog.Count > 0 ? string.Join("\n  ", rejectionLog) : "none";
                        UnityEngine.Debug.LogWarning(
                            $"[FIX_COVERAGE_DIAG] step={stepIndex} token={token}\n" +
                            $"  RESULT: FAIL no valid replacement for missingPc={requiredPc} because: no candidates in register bounds\n" +
                            $"  Rejection details:\n  {rejectionStr}");
                    }
                    
                    // Debug: Log when no candidates found for required PC - detailed analysis
                    if (s_debugTensionDetect && req.HasAny)
                    {
                        bool isTension = (req.Tension9 && requiredPc == (rootPc + 2) % 12) ||
                                        (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ||
                                        (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ||
                                        (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12);
                        if (isTension)
                        {
                            string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ? "#9" :
                                                 (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                            
                            // Generate candidates in expanded range to see what's available
                            var expandedCandidates = GenerateCandidatesInRange(new List<int> { requiredPc }, 48, 88);
                            
                            UnityEngine.Debug.LogWarning(
                                $"[REQ_EXT_DEBUG] WARNING: No candidates found for requiredPC={requiredPc} (tension={tensionName})\n" +
                                $"  Range used: [{upperMinMidi}, {effectiveUpperMax}]\n" +
                                $"  protectSoprano={protectSoprano}, sopranoMidi={((voices.Length > 0) ? voices[voices.Length - 1] : -1)}\n" +
                                $"  Expanded range [48-88] has {expandedCandidates.Count} candidates: {(expandedCandidates.Count > 0 ? string.Join(",", expandedCandidates.Take(10)) : "NONE")}\n" +
                                $"  Issue: Range [{upperMinMidi}-{effectiveUpperMax}] may be too restrictive for pc={requiredPc}");
                        }
                    }
                    continue; // No valid candidates in range
                }
                
                // Debug: Verify all candidates have the correct pitch class
                if (s_debugTensionDetect && req.HasAny)
                {
                    bool isTension = (req.Tension9 && requiredPc == (rootPc + 2) % 12) ||
                                    (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ||
                                    (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ||
                                    (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12);
                    if (isTension)
                    {
                        string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                             (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ? "#9" :
                                             (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                             (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                        // Verify all candidates have the correct PC
                        foreach (int candidate in candidates)
                        {
                            int candidatePc = (candidate % 12 + 12) % 12;
                            if (candidatePc != requiredPc)
                            {
                                UnityEngine.Debug.LogError(
                                    $"[REQ_EXT_DEBUG] ERROR: Candidate {candidate} has PC={candidatePc} but requiredPC={requiredPc} (tension={tensionName})");
                            }
                        }
                    }
                }

                // Find a candidate upper voice to repurpose
                // Priority order: 1) Optional tones, 2) Preferred tones, 3) Required tones (only if no other option)
                int bestVoiceIndex = -1;
                int bestCandidateMidi = -1;
                int bestDistance = int.MaxValue;
                ChordTonePriority bestReplacedPriority = ChordTonePriority.Required; // Start with worst case

                // Determine the last voice index we can modify (exclude soprano if melody is locked)
                int maxVoiceIndex = voices.Length - 1;
                if (protectSoprano)
                {
                    maxVoiceIndex = voices.Length - 2; // Exclude soprano (last index)
                }
                
                // DIAGNOSTIC: Log voice selection parameters for diminished triads
                if (shouldLogDimTriadDiag)
                {
                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    string voiceSelectionMsg = $"Voice selection: maxVoiceIndex={maxVoiceIndex}, protectSoprano={protectSoprano}, voices.Length={voices.Length}";
                    rejectionLog.Add(voiceSelectionMsg);
                    // Log current voice state
                    var voiceState = new List<string>();
                    for (int v = 1; v <= maxVoiceIndex && v < voices.Length; v++)
                    {
                        int vPc = (voices[v] % 12 + 12) % 12;
                        int vCount = pcCounts.GetValueOrDefault(vPc, 0);
                        string vName = v == 1 ? "T" : v == 2 ? "A" : v == 3 ? "S" : $"v{v}";
                        voiceState.Add($"{vName}:pc={vPc}(count={vCount})");
                    }
                    string availableVoicesMsg = $"Available voices: {string.Join(", ", voiceState)}";
                    rejectionLog.Add(availableVoicesMsg);
                    // ALSO print directly
                    UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {voiceSelectionMsg}\n  {availableVoicesMsg}");
                }
                
                // Diagnostic logging: Show state before voice selection
                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                {
                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    var requiredPcsList = requiredPcs.ToList();
                    var optionalPcsList = new List<int>();
                    var requestedTensionPcsList = new List<int>();
                    
                    // Build optional PCs (not in required)
                    for (int pc = 0; pc < 12; pc++)
                    {
                        if (!requiredPcs.Contains(pc) && pcToPriority.ContainsKey(pc))
                        {
                            if (pcToPriority[pc] == ChordTonePriority.Optional)
                            {
                                optionalPcsList.Add(pc);
                            }
                        }
                    }
                    
                    // Build requested tension PCs
                    if (req.TensionFlat9) requestedTensionPcsList.Add((rootPc + 1) % 12);
                    if (req.Tension9) requestedTensionPcsList.Add((rootPc + 2) % 12);
                    if (req.TensionSharp9) requestedTensionPcsList.Add((rootPc + 3) % 12);
                    if (req.TensionSharp11) requestedTensionPcsList.Add((rootPc + 6) % 12);
                    
                    string voiceInfo = string.Join(", ", voices.Select((v, idx) => $"v{idx}:pc{(v % 12 + 12) % 12}"));
                    string protectedIndicesStr = string.Join(", ", protectedVoiceIndices);
                    string protectedReasons = string.Join(", ", protectedVoiceIndices.Select(idx => {
                        int vPc = (voices[idx] % 12 + 12) % 12;
                        if (requiredPcs.Contains(vPc)) return $"v{idx}:required";
                        if (req.TensionFlat9 && vPc == (rootPc + 1) % 12) return $"v{idx}:b9";
                        if (req.Tension9 && vPc == (rootPc + 2) % 12) return $"v{idx}:9";
                        if (req.TensionSharp9 && vPc == (rootPc + 3) % 12) return $"v{idx}:#9";
                        if (req.TensionSharp11 && vPc == (rootPc + 6) % 12) return $"v{idx}:#11";
                        return $"v{idx}:?";
                    }));
                    
                    int sopranoIndex = voices.Length - 1;
                    bool sopranoExcluded = protectSoprano;
                    string sopranoInfo = sopranoExcluded ? $"EXCLUDED (protectSoprano=true)" : $"included (protectSoprano=false)";
                    string voiceInfoWithMidi = string.Join(", ", voices.Select((v, idx) => {
                        string voiceName = idx == 0 ? "B" : idx == 1 ? "T" : idx == 2 ? "A" : idx == 3 ? "S" : $"v{idx}";
                        int pc = (v % 12 + 12) % 12;
                        return $"{voiceName}={v}(pc={pc})";
                    }));
                    
                    UnityEngine.Debug.Log(
                        $"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} rootPc={rootPc}\n" +
                        $"  protectSoprano={protectSoprano}, maxVoiceIndex={maxVoiceIndex}, sopranoIndex={sopranoIndex} {sopranoInfo}\n" +
                        $"  requiredPCs=[{string.Join(",", requiredPcsList)}]\n" +
                        $"  optionalPCs=[{string.Join(",", optionalPcsList)}]\n" +
                        $"  requestedTensionPCs=[{string.Join(",", requestedTensionPcsList)}]\n" +
                        $"  currentVoices: {voiceInfoWithMidi}\n" +
                        $"  protectedVoiceIndices=[{protectedIndicesStr}] reasons=[{protectedReasons}]\n" +
                        $"  placing requiredPC={requiredPc}");
                }
                
                // FIRST-CHORD-SPECIFIC: For first chord with tension enforcement, try voices in priority order
                // This broadens the search space since first chords have no voice-leading constraints
                bool isFirstChord = (stepIndex == 0);
                bool useFirstChordHeuristic = isFirstChord && isTensionEnforcement && maxVoiceIndex >= 2;
                
                if (useFirstChordHeuristic)
                {
                    // DIAGNOSTIC: Log voice array mapping and current state
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_FIRST_DIAG] === FIRST-CHORD TENSION PLACEMENT DEBUG ===\n" +
                        $"  Voice array mapping: [0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano (BTAS order)\n" +
                        $"  Current voices BEFORE placement:\n" +
                        $"    voices[0] (Bass) = {voices[0]}\n" +
                        $"    voices[1] (Tenor) = {voices[1]}\n" +
                        $"    voices[2] (Alto) = {(voices.Length > 2 ? voices[2].ToString() : "N/A")}\n" +
                        $"    voices[3] (Soprano) = {(voices.Length > 3 ? voices[3].ToString() : "N/A")}\n" +
                        $"  Required PC: {requiredPc}, Candidates count: {candidates.Count}");
                    
                    // Try voices in priority order: Soprano → Alto → Tenor
                    // Accept the first valid placement (spacing passes, PC correct, not protected/locked, ordering correct)
                    int[] voicePriorityOrder;
                    if (maxVoiceIndex >= 3)
                    {
                        voicePriorityOrder = new int[] { 3, 2, 1 }; // Soprano, Alto, Tenor
                    }
                    else if (maxVoiceIndex >= 2)
                    {
                        voicePriorityOrder = new int[] { 2, 1 }; // Alto, Tenor
                    }
                    else
                    {
                        voicePriorityOrder = new int[] { 1 }; // Tenor only
                    }
                    
                    if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                    {
                        string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                             (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ? "#9" :
                                             (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                             (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_FIRST] step={stepIndex} FIRST-CHORD heuristic: trying voices in priority order for tension={tensionName}, " +
                            $"voiceOrder=[{string.Join(",", voicePriorityOrder.Select(i => (i == 1 ? "Tenor" : (i == 2 ? "Alto" : "Soprano"))))}]");
                    }
                    
                    foreach (int tryVoiceIndex in voicePriorityOrder)
                    {
                        if (tryVoiceIndex > maxVoiceIndex)
                            continue;
                        
                        string voiceName = tryVoiceIndex == 1 ? "Tenor" : tryVoiceIndex == 2 ? "Alto" : "Soprano";
                            
                        // Skip protected voices (including those with 7th)
                        if (protectedVoiceIndices.Contains(tryVoiceIndex))
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                string reason = voicesWithSeventh.Contains(tryVoiceIndex) ? "PROTECTED (contains 7th)" : "PROTECTED (contains requested tension)";
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST] step={stepIndex} skipping {voiceName} (voice {tryVoiceIndex}): {reason}");
                            }
                            continue;
                        }
                        
                        // PROTECTION: Skip voices that contain the required 7th (unless we're trying to place the 7th itself)
                        if (hasSeventh && seventhPc >= 0 && voicesWithSeventh.Contains(tryVoiceIndex) && requiredPc != seventhPc)
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST] step={stepIndex} skipping {voiceName} (voice {tryVoiceIndex}): PROTECTED (contains required 7th, pc={seventhPc})");
                            }
                            continue;
                        }
                        
                        // Skip locked resolution voices
                        if (lockedResolutionVoices != null && tryVoiceIndex < lockedResolutionVoices.Length && lockedResolutionVoices[tryVoiceIndex])
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST] step={stepIndex} skipping {voiceName} (voice {tryVoiceIndex}): LOCKED (7th resolution)");
                            }
                            continue;
                        }
                        
                        // Find best candidate for this voice
                        // Strategy: Try closest candidate first, then ±12 octave variants if closest violates ordering
                        int bestCandidateForVoice = -1;
                        int bestDistanceForVoice = int.MaxValue;
                        
                        // Get current voice MIDI for distance calculation
                        int currentVoiceMidi = voices[tryVoiceIndex];
                        
                        // Build candidate list with octave variants: closest first, then ±12
                        var candidateList = new List<int>();
                        foreach (int candidate in candidates)
                        {
                            // Verify candidate has correct PC (should already be filtered, but double-check)
                            int candidatePc = (candidate % 12 + 12) % 12;
                            if (candidatePc != requiredPc)
                                continue;
                            
                            candidateList.Add(candidate);
                            
                            // Add octave variants if within range
                            int candidateUp = candidate + 12;
                            int candidateDown = candidate - 12;
                            
                            if (candidateUp >= upperMinMidi && candidateUp <= upperMaxMidi)
                                candidateList.Add(candidateUp);
                            
                            if (candidateDown >= upperMinMidi && candidateDown <= upperMaxMidi)
                                candidateList.Add(candidateDown);
                        }
                        
                        // Sort by distance from current voice MIDI
                        candidateList = candidateList.OrderBy(c => Math.Abs(c - currentVoiceMidi)).ToList();
                        
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_FIRST_DIAG] Trying {voiceName} (index {tryVoiceIndex}), current MIDI={currentVoiceMidi}, " +
                            $"candidate variants (with octaves): [{string.Join(", ", candidateList.Take(10))}]");
                        
                        foreach (int candidate in candidateList)
                        {
                            // Verify candidate has correct PC
                            int candidatePc = (candidate % 12 + 12) % 12;
                            if (candidatePc != requiredPc)
                                continue;
                                
                            // Check spacing before selecting
                            if (WouldBreakSpacing(voices, tryVoiceIndex, candidate))
                            {
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST_DIAG] {voiceName} (index {tryVoiceIndex}): candidate {candidate} REJECTED (spacing)");
                                continue;
                            }
                            
                            // SOFT PREFERENCE: Prefer #9 >= 3rd, but allow #9 < 3rd so solver can discover it's bad and reassign 3rd
                            // We'll apply a distance penalty for candidates below 3rd instead of rejecting them
                            int distanceFromThird = 0;
                            if (isSharp9Enforcement && thirdMidi >= 0 && candidate < thirdMidi)
                            {
                                distanceFromThird = thirdMidi - candidate; // Penalty for being below 3rd
                                if (s_debugTensionVerbose && s_debugTensionDetect)
                                {
                                    UnityEngine.Debug.Log(
                                        $"[REQ_EXT_FIRST_DIAG] {voiceName} (index {tryVoiceIndex}): candidate {candidate} below 3rd ({thirdMidi}), " +
                                        $"distance={distanceFromThird} (soft penalty, not rejected)");
                                }
                            }
                            
                            // CRITICAL: Prevent #9–3rd minor 2nd crunch between Soprano and Alto
                            // If #9 is in Soprano and 3rd is in Alto with m2 interval, reject this candidate
                            if (isSharp9Enforcement && WouldCreateSharp9ThirdCrunch(voices, tryVoiceIndex, candidate, thirdPc))
                            {
                                int altoThirdMidi = voices[2];
                                int interval = Math.Abs(candidate - altoThirdMidi);
                                string reason = interval == 1 
                                    ? $"m2 crunch (interval=1)" 
                                    : $"forced high octave (#9={candidate} >= 3rd+12={altoThirdMidi + 12}, should move 3rd down)";
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST_DIAG] {voiceName} (index {tryVoiceIndex}): candidate {candidate} REJECTED (#9–3rd {reason}: #9={candidate} in Soprano, 3rd={altoThirdMidi} in Alto)");
                                continue;
                            }
                            
                            // CRITICAL FIX: Check voice ordering constraints using BTAS mapping
                            // voices[0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano
                            // Ordering: voices[0] <= voices[1] <= voices[2] <= voices[3]
                            int[] tempVoices = (int[])voices.Clone();
                            tempVoices[tryVoiceIndex] = candidate;
                            
                            bool violatesOrdering = false;
                            string violationReason = "";
                            
                            // Check Bass <= Tenor
                            if (tempVoices.Length >= 2 && tempVoices[0] > tempVoices[1])
                            {
                                violatesOrdering = true;
                                violationReason = $"Bass({tempVoices[0]}) > Tenor({tempVoices[1]})";
                            }
                            // Check Tenor <= Alto
                            else if (tempVoices.Length >= 3 && tempVoices[1] > tempVoices[2])
                            {
                                violatesOrdering = true;
                                violationReason = $"Tenor({tempVoices[1]}) > Alto({tempVoices[2]})";
                            }
                            // Check Alto <= Soprano
                            else if (tempVoices.Length >= 4 && tempVoices[2] > tempVoices[3])
                            {
                                violatesOrdering = true;
                                violationReason = $"Alto({tempVoices[2]}) > Soprano({tempVoices[3]})";
                            }
                            
                            if (violatesOrdering)
                            {
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST_DIAG] {voiceName} (index {tryVoiceIndex}): candidate {candidate} REJECTED (voice crossing: {violationReason})\n" +
                                    $"  Temp voices: B={tempVoices[0]} T={tempVoices[1]} A={(tempVoices.Length > 2 ? tempVoices[2].ToString() : "N/A")} S={(tempVoices.Length > 3 ? tempVoices[3].ToString() : "N/A")}");
                                continue;
                            }
                            
                            // Candidate passes all checks - use it
                            // Apply soft penalty if #9 is below 3rd (prefer #9 >= 3rd, but allow it)
                            int baseDistance = Math.Abs(candidate - currentVoiceMidi);
                            int adjustedDistance = baseDistance;
                            if (isSharp9Enforcement && thirdMidi >= 0 && candidate < thirdMidi)
                            {
                                // Add penalty for being below 3rd (encourages solver to prefer #9 >= 3rd)
                                // But don't reject - allow solver to discover and reassign 3rd
                                adjustedDistance = baseDistance + (thirdMidi - candidate) * 2; // 2x penalty for each semitone below
                            }
                            if (adjustedDistance < bestDistanceForVoice)
                            {
                                bestCandidateForVoice = candidate;
                                bestDistanceForVoice = adjustedDistance;
                            }
                        }
                        
                        if (bestCandidateForVoice >= 0)
                        {
                            // Found valid placement for this voice - use it
                            bestVoiceIndex = tryVoiceIndex;
                            bestCandidateMidi = bestCandidateForVoice;
                            bestDistance = bestDistanceForVoice;
                            
                            string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                            int oldMidi = voices[tryVoiceIndex];
                            
                            // DIAGNOSTIC: Log before/after state
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_FIRST_DIAG] FOUND valid placement for {voiceName} (index {tryVoiceIndex}):\n" +
                                $"  BEFORE: voices[{tryVoiceIndex}] = {oldMidi}\n" +
                                $"  AFTER:  voices[{tryVoiceIndex}] = {bestCandidateForVoice} (tension={tensionName}, distance={bestDistanceForVoice})\n" +
                                $"  Voice array AFTER placement:\n" +
                                $"    voices[0] (Bass) = {voices[0]}\n" +
                                $"    voices[1] (Tenor) = {voices[1]}\n" +
                                $"    voices[2] (Alto) = {(voices.Length > 2 ? voices[2].ToString() : "N/A")}\n" +
                                $"    voices[3] (Soprano) = {(voices.Length > 3 ? voices[3].ToString() : "N/A")}");
                            
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST] step={stepIndex} FOUND valid placement: {voiceName} (voice {tryVoiceIndex}) " +
                                    $"old={oldMidi} -> new={bestCandidateForVoice} (tension={tensionName}, distance={bestDistanceForVoice})");
                            }
                            
                            // Break out of voice priority loop - we found a valid placement
                            break;
                        }
                        else
                        {
                            // voiceName is already declared earlier in this scope (line 7653)
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST] step={stepIndex} {voiceName} (voice {tryVoiceIndex}): NO valid candidates (all rejected spacing/PC)");
                            }
                            else
                            {
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_FIRST_DIAG] {voiceName} (index {tryVoiceIndex}): NO valid candidates found (all rejected spacing/ordering/PC)");
                            }
                        }
                    }
                    
                    // If first-chord heuristic found a placement, skip to application
                    if (bestVoiceIndex >= 0 && bestCandidateMidi >= 0)
                    {
                        // DIAGNOSTIC: Log final state after first-chord heuristic selection
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_FIRST_DIAG] === FIRST-CHORD HEURISTIC COMPLETE ===\n" +
                            $"  Selected voice index: {bestVoiceIndex} ([0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano)\n" +
                            $"  Selected candidate MIDI: {bestCandidateMidi}\n" +
                            $"  Current voices BEFORE assignment:\n" +
                            $"    voices[0] (Bass) = {voices[0]}\n" +
                            $"    voices[1] (Tenor) = {voices[1]}\n" +
                            $"    voices[2] (Alto) = {(voices.Length > 2 ? voices[2].ToString() : "N/A")}\n" +
                            $"    voices[3] (Soprano) = {(voices.Length > 3 ? voices[3].ToString() : "N/A")}\n" +
                            $"  Will assign voices[{bestVoiceIndex}] = {bestCandidateMidi}");
                        
                        // Skip the standard single-best logic below, go straight to application
                        // (The application code is shared and will handle the assignment)
                    }
                    else
                    {
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_FIRST_DIAG] === FIRST-CHORD HEURISTIC FAILED ===\n" +
                            $"  No valid placement found in any voice (Soprano→Alto→Tenor)\n" +
                            $"  Falling back to standard single-best logic");
                    }
                }
                
                // Debug logging: Analyze replaceable voices for b9 enforcement (isTensionEnforcement already defined above)
                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement)
                {
                    string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                         (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                         (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                    
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_ENFORCE] === Enforcing requiredPC={requiredPc} (tension={tensionName}) ===\n" +
                        $"  candidates.Count={candidates.Count}, range=[{upperMinMidi}, {effectiveUpperMax}]\n" +
                        $"  protectSoprano={protectSoprano}, maxVoiceIndex={maxVoiceIndex}\n" +
                        $"  protectedVoiceIndices=[{(protectedVoiceIndices.Count > 0 ? string.Join(",", protectedVoiceIndices) : "none")}]\n" +
                        $"  lockedResolutionVoices=[{(lockedResolutionVoices != null && lockedResolutionVoices.Any(l => l) ? "some locked" : "none")}]");
                    
                    // Analyze each voice
                    for (int i = 1; i <= maxVoiceIndex; i++)
                    {
                        string voiceName = i == 1 ? "Tenor" : i == 2 ? "Alto" : "Soprano";
                        int currentMidi = voices[i];
                        int currentPc = (currentMidi % 12 + 12) % 12;
                        ChordTonePriority currentPriority = pcToPriority.GetValueOrDefault(currentPc, ChordTonePriority.Optional);
                        bool isProtected = protectedVoiceIndices.Contains(i);
                        bool isLocked = lockedResolutionVoices != null && i < lockedResolutionVoices.Length && lockedResolutionVoices[i];
                        bool isDuplicated = pcCounts.GetValueOrDefault(currentPc, 0) > 1;
                        bool isSoleProvider = pcCounts.GetValueOrDefault(currentPc, 0) <= 1;
                        
                        // Check replaceability
                        bool isReplaceable = false;
                        string replaceableReason = "";
                        if (isProtected)
                        {
                            replaceableReason = "PROTECTED (contains requested tension)";
                        }
                        else if (isLocked)
                        {
                            replaceableReason = "LOCKED (7th resolution)";
                        }
                        else
                        {
                            bool isOptional = currentPriority == ChordTonePriority.Optional;
                            if (isOptional)
                            {
                                isReplaceable = true;
                                replaceableReason = "OPTIONAL priority";
                            }
                            else if (isDuplicated && currentPriority != ChordTonePriority.Required)
                            {
                                isReplaceable = true;
                                replaceableReason = $"DUPLICATED {currentPriority} (count={pcCounts[currentPc]})";
                            }
                            else if (currentPriority == ChordTonePriority.Required && !isSoleProvider)
                            {
                                isReplaceable = true;
                                replaceableReason = $"REQUIRED but not sole provider (count={pcCounts[currentPc]})";
                            }
                            else
                            {
                                replaceableReason = $"NOT REPLACEABLE: {currentPriority}, soleProvider={isSoleProvider}, duplicated={isDuplicated}";
                            }
                        }
                        
                        // Count candidates for this voice's position
                        var voiceCandidatesForPc8 = candidates.Where(c => 
                        {
                            // Check if candidate is in reasonable range for this voice position
                            // Rough heuristic: tenor ~55-65, alto ~60-70, soprano ~65-80
                            return true; // Use all candidates for now
                        }).ToList();
                        
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_ENFORCE]   {voiceName} (voice {i}): midi={currentMidi} (pc={currentPc}, {TheoryPitch.GetPitchNameFromMidi(currentMidi, chordEvent.Key)})\n" +
                            $"    priority={currentPriority}, pcCount={pcCounts.GetValueOrDefault(currentPc, 0)}\n" +
                            $"    replaceable={isReplaceable}, reason={replaceableReason}\n" +
                            $"    candidates with pc={requiredPc} for this voice: {voiceCandidatesForPc8.Count}\n" +
                            $"    examples: {(voiceCandidatesForPc8.Count > 0 ? string.Join(",", voiceCandidatesForPc8.Take(3)) : "NONE")}");
                    }
                }
                
                // Standard single-best-voice logic (only if first-chord heuristic didn't find a placement)
                if (bestVoiceIndex < 0)
                {
                // DIAGNOSTIC: Log when entering voice selection loop
                if (shouldLogDimTriadDiag)
                {
                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    string loopEntryMsg = $"Entering voice selection loop for missingPc={requiredPc}, will check voices 1 to {maxVoiceIndex}";
                    rejectionLog.Add(loopEntryMsg);
                    // ALSO print directly
                    UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {loopEntryMsg}");
                }
                
                // First pass: look for Optional priority tones (preferred to drop)
                for (int i = 1; i <= maxVoiceIndex; i++)
                {
                    int currentPc = (voices[i] % 12 + 12) % 12;
                    string voiceName = i == 1 ? "T" : i == 2 ? "A" : i == 3 ? "S" : $"v{i}";
                    
                    // DIRECT GUARD (TOP PRIORITY): NEVER select a voice whose PC is a requested tension
                    // This must be checked FIRST, before any other logic
                    if (requestedTensionPcs.Contains(currentPc))
                    {
                        if (shouldLogDimTriadDiag)
                        {
                            string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            string skipMsg = $"try voice={voiceName} oldPc={currentPc} -> newPc={requiredPc} SKIP: contains requested tension";
                            rejectionLog.Add(skipMsg);
                            // ALSO print directly
                            UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {skipMsg}");
                        }
                        if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                        {
                            string tensionName = (req.TensionFlat9 && currentPc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && currentPc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp9 && currentPc == (rootPc + 3) % 12) ? "#9" :
                                                 (req.TensionSharp11 && currentPc == (rootPc + 6) % 12) ? "#11" : "?";
                            UnityEngine.Debug.Log(
                                $"[VICTIM_GUARD] step={stepIndex} PASS1: REJECTING voice {i} (pc={currentPc}={tensionName}) " +
                                $"for requiredPC={requiredPc} - requested tension must never be overwritten (DIRECT GUARD)");
                        }
                        continue; // Skip this voice - it contains a requested tension
                    }
                    
                    // CRITICAL: Skip protected voices that contain requested tensions
                    if (protectedVoiceIndices.Contains(i))
                    {
                        if (shouldLogDimTriadDiag)
                        {
                            string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            string skipMsg = $"try voice={voiceName} oldPc={currentPc} -> newPc={requiredPc} SKIP: protected voice (contains requested tension or 7th)";
                            rejectionLog.Add(skipMsg);
                            // ALSO print directly
                            UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {skipMsg}");
                        }
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            int voicePc = (voices[i] % 12 + 12) % 12;
                            string tensionName = (req.TensionFlat9 && voicePc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && voicePc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && voicePc == (rootPc + 6) % 12) ? "#11" : "?";
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_PROTECT] step={stepIndex} skipping protected voice {i} (contains {tensionName}, pc={voicePc})");
                        }
                        continue;
                    }
                    
                    // Skip locked resolution voices (7th resolutions that must be preserved)
                    if (lockedResolutionVoices != null && i < lockedResolutionVoices.Length && lockedResolutionVoices[i])
                    {
                        if (shouldLogDimTriadDiag)
                        {
                            string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            string skipMsg = $"try voice={voiceName} oldPc={currentPc} -> newPc={requiredPc} SKIP: locked voice (7th resolution)";
                            rejectionLog.Add(skipMsg);
                            // ALSO print directly
                            UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {skipMsg}");
                        }
                        if (enableTendencyDebug)
                        {
                            UnityEngine.Debug.Log($"[Coverage Debug] Skipping locked resolution voice {i} (voice has hard-locked 7th resolution)");
                        }
                        continue;
                    }
                    ChordTonePriority currentPriority = pcToPriority.GetValueOrDefault(currentPc, ChordTonePriority.Optional);
                    
                    // Part B: Helper to check if this voice is the sole provider of its PC
                    bool IsSoleProviderOfPcFirstPass(int voiceIdx, int pc, Dictionary<int, int> pcCountsDict)
                    {
                        return pcCountsDict.GetValueOrDefault(pc, 0) <= 1;
                    }
                    
                    // Prefer Optional tones, but also consider duplicated tones of any priority
                    // Part B: Also allow overwriting Required tones if they are duplicated (not sole provider)
                    bool isOptional = currentPriority == ChordTonePriority.Optional;
                    bool isDuplicated = pcCounts.GetValueOrDefault(currentPc, 0) > 1;
                    bool isSoleProvider = IsSoleProviderOfPcFirstPass(i, currentPc, pcCounts);
                    
                    // Check if this voice's PC is protected (required tone or requested tension)
                    bool isProtectedPc = protectedPCs.Contains(currentPc);
                    bool isPerfectFifth = currentPc == fifthPc && currentPriority == ChordTonePriority.Optional; // Perfect 5th is Optional priority
                    bool isDuplicatedRoot = currentPc == rootPc && isDuplicated;
                    
                    // CRITICAL FIX: For diminished triads (and other cases with missing required tones),
                    // allow replacing duplicated Required tones (e.g., duplicated root) with missing required tones.
                    // Check if this voice is the sole carrier of any OTHER required PC (don't remove the only m3/b5)
                    bool isSoleCarrierOfOtherRequired = false;
                    if (requiredPcs != null)
                    {
                        foreach (int otherRequiredPc in requiredPcs)
                        {
                            if (otherRequiredPc == currentPc) continue; // Skip the PC we're considering replacing
                            int otherRequiredCount = pcCounts.GetValueOrDefault(otherRequiredPc, 0);
                            if (otherRequiredCount <= 1)
                            {
                                // Check if this voice carries this other required PC
                                int voicePc = (voices[i] % 12 + 12) % 12;
                                if (voicePc == otherRequiredPc)
                                {
                                    isSoleCarrierOfOtherRequired = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Allow overwriting if: Optional, OR duplicated (even if Required), OR Required but not sole provider
                    // SPECIAL CASE: For tension enforcement, allow overwriting Required 5th even if sole provider (5th is lowest priority)
                    // CRITICAL FIX: Explicitly allow replacing duplicated Required tones when adding missing required tones
                    // This is essential for diminished triads where duplicated roots must be replaceable with missing b5
                    bool canReplace = isOptional || 
                        (isDuplicated && currentPriority != ChordTonePriority.Required) || 
                        (currentPriority == ChordTonePriority.Required && !isSoleProvider) ||
                        (isTensionEnforcement && currentPc == fifthPc && currentPriority == ChordTonePriority.Required) || // Allow replacing Required 5th for tensions
                        // EXPLICIT: Allow replacing duplicated Required tones (like duplicated root) with missing required tones
                        (isDuplicated && currentPriority == ChordTonePriority.Required && requiredPcs.Contains(requiredPc));
                    
                    // Additional check: Don't replace if this would remove the only instance of another required tone
                    if (canReplace && isSoleCarrierOfOtherRequired)
                    {
                        if (shouldLogDimTriadDiag)
                        {
                            string vName = i == 1 ? "T" : i == 2 ? "A" : i == 3 ? "S" : $"v{i}";
                            rejectionLog.Add($"try voice={vName} oldPc={currentPc} -> newPc={requiredPc} REJECT: would remove sole carrier of another required tone");
                        }
                        canReplace = false;
                    }
                    
                    // PRIORITY: Skip protected PCs unless we have no other choice (will be handled in second/third pass)
                    // EXCEPTION: Allow duplicated required tones (like duplicated root) to be replaced when adding missing required tones
                    // CRITICAL: For diminished triads, we MUST allow replacing duplicated roots with missing b5
                    bool isDuplicatedRequiredTone = isDuplicated && currentPriority == ChordTonePriority.Required && !isSoleProvider && requiredPcs.Contains(currentPc);
                    bool isDuplicatedRootForMissingTone = isDuplicatedRoot && requiredPcs.Contains(requiredPc); // Explicit check for duplicated root when adding missing tone
                    if (canReplace && isProtectedPc && !isPerfectFifth && !isDuplicatedRootForMissingTone && !isDuplicatedRequiredTone)
                    {
                        // This is a protected PC (requested tension) - skip it in first pass, prefer non-protected tones first
                        if (shouldLogDimTriadDiag)
                        {
                            string vName = i == 1 ? "T" : i == 2 ? "A" : i == 3 ? "S" : $"v{i}";
                            rejectionLog.Add($"try voice={vName} oldPc={currentPc} -> newPc={requiredPc} REJECT: protectedPC (not 5th/duplicated root/duplicated required)");
                        }
                        if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                        {
                            string reason = $"protectedPC (not 5th/duplicated root/duplicated required)";
                            UnityEngine.Debug.Log(
                                $"[PASS1_REJECT] step={stepIndex} voice {i}: pc={currentPc} priority={currentPriority} " +
                                $"REJECTED: {reason} (will try in pass 2/3 if needed)");
                        }
                        continue;
                    }
                    
                    if (!canReplace)
                    {
                        if (shouldLogDimTriadDiag)
                        {
                            string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            // Determine the actual reason why canReplace is false
                            string reason = "unknown";
                            if (isSoleProvider && currentPriority == ChordTonePriority.Required)
                                reason = $"sole provider of required tone (priority={currentPriority}, soleProvider={isSoleProvider})";
                            else if (!isOptional && !isDuplicated && currentPriority == ChordTonePriority.Required)
                                reason = $"required tone and sole provider (priority={currentPriority}, duplicated={isDuplicated})";
                            else if (isProtectedPc && !isPerfectFifth && !isDuplicatedRootForMissingTone && !isDuplicatedRequiredTone)
                                reason = $"protected PC (not 5th/duplicated root/duplicated required)";
                            else
                                reason = $"cannot replace (priority={currentPriority}, optional={isOptional}, duplicated={isDuplicated}, soleProvider={isSoleProvider})";
                            
                            string rejectMsg = $"try voice={voiceName} oldPc={currentPc} -> newPc={requiredPc} SKIP: {reason}";
                            rejectionLog.Add(rejectMsg);
                            // ALSO print directly
                            UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {rejectMsg}");
                        }
                        if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                        {
                            string reason = $"not replaceable: priority={currentPriority}, soleProvider={isSoleProvider}, duplicated={isDuplicated}";
                            UnityEngine.Debug.Log(
                                $"[PASS1_REJECT] step={stepIndex} voice {i}: pc={currentPc} " +
                                $"REJECTED: {reason}");
                        }
                    }
                    
                    if (canReplace)
                    {
                        // DIAGNOSTIC: Log when considering a voice for replacement
                        if (shouldLogDimTriadDiag)
                        {
                            string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            int dupCount = pcCounts.GetValueOrDefault(currentPc, 0);
                            string reason = isDuplicated && currentPriority == ChordTonePriority.Required ? $"duplicated Required tone (count={dupCount})" :
                                          isOptional ? "optional tone" :
                                          isDuplicated ? $"duplicated {currentPriority} tone" :
                                          $"Required but not sole provider";
                            string considerMsg = $"try voice={voiceName} oldPc={currentPc} -> newPc={requiredPc} CONSIDERING: {reason}";
                            rejectionLog.Add(considerMsg);
                            // ALSO print directly
                            UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {considerMsg}");
                        }
                        
                        // Find nearest MIDI note with requiredPc near this voice
                        bool foundValidCandidateForVoice = false;
                        bool hasRejectionForThisVoice = false;
                        foreach (int candidate in candidates)
                        {
                            // SOFT PREFERENCE: Prefer #9 >= 3rd, but allow #9 < 3rd so solver can discover it's bad and reassign 3rd
                            
                            // Check spacing constraint
                            if (WouldBreakSpacing(voices, i, candidate))
                            {
                                if (shouldLogDimTriadDiag)
                                {
                                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                                    string vName = i == 1 ? "T" : i == 2 ? "A" : i == 3 ? "S" : $"v{i}";
                                    string rejectMsg = $"try voice={vName} oldPc={currentPc} -> newPc={requiredPc} candidateMidi={candidate} REJECT: violates spacing constraints";
                                    if (!hasRejectionForThisVoice)
                                    {
                                        rejectionLog.Add(rejectMsg);
                                        hasRejectionForThisVoice = true;
                                    }
                                    // ALSO print directly (print all rejections, not just first)
                                    UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {rejectMsg}");
                                }
                                continue; // Skip candidates that violate spacing
                            }
                            
                            // Check ordering constraints
                            int[] tempVoicesOrder = (int[])voices.Clone();
                            tempVoicesOrder[i] = candidate;
                            bool violatesOrdering = false;
                            string orderingReason = "";
                            if (tempVoicesOrder.Length >= 2 && tempVoicesOrder[0] > tempVoicesOrder[1])
                            {
                                violatesOrdering = true;
                                orderingReason = $"Bass({tempVoicesOrder[0]}) > Tenor({tempVoicesOrder[1]})";
                            }
                            else if (tempVoicesOrder.Length >= 3 && tempVoicesOrder[1] > tempVoicesOrder[2])
                            {
                                violatesOrdering = true;
                                orderingReason = $"Tenor({tempVoicesOrder[1]}) > Alto({tempVoicesOrder[2]})";
                            }
                            else if (tempVoicesOrder.Length >= 4 && tempVoicesOrder[2] > tempVoicesOrder[3])
                            {
                                violatesOrdering = true;
                                orderingReason = $"Alto({tempVoicesOrder[2]}) > Soprano({tempVoicesOrder[3]})";
                            }
                            
                            if (violatesOrdering)
                            {
                                if (shouldLogDimTriadDiag)
                                {
                                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                                    string vName = i == 1 ? "T" : i == 2 ? "A" : i == 3 ? "S" : $"v{i}";
                                    string rejectMsg = $"try voice={vName} oldPc={currentPc} -> newPc={requiredPc} candidateMidi={candidate} REJECT: violates ordering ({orderingReason})";
                                    if (!hasRejectionForThisVoice)
                                    {
                                        rejectionLog.Add(rejectMsg);
                                        hasRejectionForThisVoice = true;
                                    }
                                    // ALSO print directly (print all rejections, not just first)
                                    UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {rejectMsg}");
                                }
                                continue;
                            }
                            
                            // CRITICAL: Prevent #9–3rd minor 2nd crunch between Soprano and Alto
                            // If #9 is in Soprano and 3rd is in Alto with m2 interval, reject this candidate
                            if (isSharp9Enforcement && WouldCreateSharp9ThirdCrunch(voices, i, candidate, thirdPc))
                            {
                                if (shouldLogDimTriadDiag)
                                {
                                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                                    string vName = i == 1 ? "T" : i == 2 ? "A" : i == 3 ? "S" : $"v{i}";
                                    string rejectMsg = $"try voice={vName} oldPc={currentPc} -> newPc={requiredPc} candidateMidi={candidate} REJECT: would create #9-3rd m2 crunch";
                                    if (!hasRejectionForThisVoice)
                                    {
                                        rejectionLog.Add(rejectMsg);
                                        hasRejectionForThisVoice = true;
                                    }
                                    // ALSO print directly (print all rejections, not just first)
                                    UnityEngine.Debug.LogWarning($"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} {rejectMsg}");
                                }
                                continue; // Skip candidates that create m2 crunch or force high octave
                            }
                            
                            int baseDistance = Math.Abs(candidate - voices[i]);
                            // Apply soft penalty if #9 is below 3rd (prefer #9 >= 3rd, but allow it)
                            int adjustedDistance = baseDistance;
                            if (isSharp9Enforcement && thirdMidi >= 0 && candidate < thirdMidi)
                            {
                                // Add penalty for being below 3rd (encourages solver to prefer #9 >= 3rd)
                                // But don't reject - allow solver to discover and reassign 3rd
                                adjustedDistance = baseDistance + (thirdMidi - candidate) * 2; // 2x penalty for each semitone below
                            }
                            
                            // PRIORITY ORDER: 1) Perfect 5th, 2) Duplicated root, 3) Other non-protected tones, 4) Protected tones
                            // Prefer non-protected PCs over protected PCs (requested tensions)
                            bool isCurrentProtected = protectedPCs.Contains(currentPc);
                            bool isBestProtected = bestVoiceIndex >= 0 && protectedPCs.Contains((voices[bestVoiceIndex] % 12 + 12) % 12);
                            
                            // Better choice if:
                            // - First valid candidate (bestVoiceIndex < 0) - always select it
                            // - Current is non-protected and best is protected (always prefer non-protected)
                            // - Both are same protection status, use existing priority logic
                            bool betterChoice = false;
                            if (bestVoiceIndex < 0)
                            {
                                // First valid candidate - always select it if we've reached this point
                                // (it already passed all spacing/ordering checks)
                                betterChoice = true;
                            }
                            else if (!isCurrentProtected && isBestProtected)
                            {
                                betterChoice = true; // Always prefer non-protected over protected
                            }
                            else if (isCurrentProtected == isBestProtected)
                            {
                                // Same protection status - use existing priority logic
                                betterChoice = (isOptional && currentPriority < bestReplacedPriority) ||
                                             (isDuplicated && !isOptional && currentPriority <= bestReplacedPriority && adjustedDistance < bestDistance) ||
                                             (adjustedDistance < bestDistance && currentPriority < bestReplacedPriority);
                            }
                            // If current is protected and best is non-protected, don't replace (keep best)
                            
                            // DIAGNOSTIC: Log candidate evaluation result
                            if (shouldLogDimTriadDiag)
                            {
                                string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                                string vName = i == 1 ? "T" : i == 2 ? "A" : i == 3 ? "S" : $"v{i}";
                                string betterChoiceStatus = betterChoice ? "SELECTED" : "NOT SELECTED";
                                string reason = betterChoice ? 
                                    (!isCurrentProtected && isBestProtected ? "non-protected vs protected" :
                                     isOptional && currentPriority < bestReplacedPriority ? "optional with better priority" :
                                     isDuplicated && !isOptional && currentPriority <= bestReplacedPriority && adjustedDistance < bestDistance ? "duplicated with better distance" :
                                     adjustedDistance < bestDistance && currentPriority < bestReplacedPriority ? "better distance and priority" : "better choice") :
                                    (isCurrentProtected && !isBestProtected ? "protected vs non-protected" :
                                     !isOptional && currentPriority >= bestReplacedPriority && adjustedDistance >= bestDistance ? "worse priority/distance" :
                                     bestVoiceIndex >= 0 ? "already have better candidate" : "not better choice");
                                
                                UnityEngine.Debug.LogWarning(
                                    $"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} try voice={vName} oldPc={currentPc} -> newPc={requiredPc} candidateMidi={candidate} " +
                                    $"PASSED checks {betterChoiceStatus} (reason: {reason}, adjustedDistance={adjustedDistance}, bestDistance={bestDistance}, " +
                                    $"currentPriority={currentPriority}, bestReplacedPriority={bestReplacedPriority}, bestVoiceIndex={bestVoiceIndex})");
                            }
                            
                            if (betterChoice)
                            {
                                bestVoiceIndex = i;
                                bestCandidateMidi = candidate;
                                bestDistance = adjustedDistance;
                                bestReplacedPriority = currentPriority;
                                foundValidCandidateForVoice = true;
                                
                                // DIAGNOSTIC: Log when candidate is selected
                                if (shouldLogDimTriadDiag)
                                {
                                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                                    string vName = i == 1 ? "T" : i == 2 ? "A" : i == 3 ? "S" : $"v{i}";
                                    string victimReason = isOptional ? "optional" : isDuplicated ? "duplicated" : 
                                                         isPerfectFifth ? "perfect 5th" : isDuplicatedRoot ? "duplicated root" : "other";
                                    UnityEngine.Debug.LogWarning(
                                        $"[FIX_COVERAGE_DIAG] step={stepIndex} token={token} CANDIDATE SELECTED: voice={vName} (pc={currentPc}, priority={currentPriority}) " +
                                        $"candidateMidi={candidate} for requiredPC={requiredPc}, reason={victimReason}");
                                }
                                
                                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                                {
                                    string victimReason = isOptional ? "optional" : isDuplicated ? "duplicated" : 
                                                         isPerfectFifth ? "perfect 5th" : isDuplicatedRoot ? "duplicated root" : "other";
                                    UnityEngine.Debug.Log(
                                        $"[VICTIM_SELECTED] step={stepIndex} PASS1: Selected voice {i} (pc={currentPc}, priority={currentPriority}) " +
                                        $"for requiredPC={requiredPc}, reason={victimReason}");
                                }
                            }
                        }
                    }
                }

                // Second pass: if no Optional/Preferred tones found, use any upper voice (except Required if possible)
                // LAST RESORT: Only consider protected PCs (requested tensions) if no non-protected alternative exists
                if (bestVoiceIndex < 0)
                {
                    // Debug logging for second pass
                    if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement)
                    {
                        string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                             (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                             (req.TensionSharp9 && requiredPc == (rootPc + 3) % 12) ? "#9" :
                                             (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_ENFORCE] Second pass: no Optional/Preferred found, checking all voices for tension={tensionName}");
                    }
                    
                    for (int i = 1; i <= maxVoiceIndex; i++)
                    {
                        int currentPc = (voices[i] % 12 + 12) % 12;
                        
                        // DIRECT GUARD (TOP PRIORITY): NEVER select a voice whose PC is a requested tension
                        // This must be checked FIRST, before any other logic
                        if (requestedTensionPcs.Contains(currentPc))
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                string tensionName = (req.TensionFlat9 && currentPc == (rootPc + 1) % 12) ? "b9" :
                                                     (req.Tension9 && currentPc == (rootPc + 2) % 12) ? "9" :
                                                     (req.TensionSharp9 && currentPc == (rootPc + 3) % 12) ? "#9" :
                                                     (req.TensionSharp11 && currentPc == (rootPc + 6) % 12) ? "#11" : "?";
                                UnityEngine.Debug.Log(
                                    $"[VICTIM_GUARD] step={stepIndex} PASS2: REJECTING voice {i} (pc={currentPc}={tensionName}) " +
                                    $"for requiredPC={requiredPc} - requested tension must never be overwritten (DIRECT GUARD)");
                            }
                            continue; // Skip this voice - it contains a requested tension
                        }
                        
                        // Skip locked resolution voices
                        if (lockedResolutionVoices != null && i < lockedResolutionVoices.Length && lockedResolutionVoices[i])
                        {
                            continue;
                        }
                        
                        // CRITICAL: Skip protected voices that contain requested tensions (last resort only)
                        if (protectedVoiceIndices.Contains(i))
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                int voicePc = (voices[i] % 12 + 12) % 12;
                                string reason = "protected voice (requested tension)";
                                UnityEngine.Debug.Log(
                                    $"[PASS2_REJECT] step={stepIndex} voice {i}: pc={voicePc} " +
                                    $"REJECTED: {reason} (will try in pass 3 if needed)");
                            }
                            continue; // Will be considered in third pass if absolutely necessary
                        }
                        ChordTonePriority currentPriority = pcToPriority.GetValueOrDefault(currentPc, ChordTonePriority.Optional);
                        
                        // Part B: Helper to check if this voice is the sole provider of its PC
                        bool IsSoleProviderOfPc(int voiceIdx, int pc, Dictionary<int, int> pcCountsDict)
                        {
                            return pcCountsDict.GetValueOrDefault(pc, 0) <= 1;
                        }
                        
                        // CRITICAL: Never replace a voice that contains the required 7th (especially important for natural 9)
                        // Natural 9 is processed after 7th, so 7th should already be placed, but we need to protect it
                        bool isNatural9 = req.Tension9 && requiredPc == (rootPc + 2) % 12;
                        if (hasSeventh && seventhPc >= 0 && isNatural9 && currentPc == seventhPc)
                        {
                            // Skip this voice - it contains the 7th and natural 9 must not overwrite it
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                UnityEngine.Debug.Log(
                                    $"[PASS2_REJECT] step={stepIndex} voice {i}: pc={currentPc} " +
                                    $"REJECTED: contains required 7th (natural 9 must not overwrite 7th)");
                            }
                            continue;
                        }
                        
                        // Check if this voice's PC is protected (requested tension)
                        bool isProtectedPc = protectedPCs.Contains(currentPc);
                        
                        // PRIORITY: Prefer non-protected PCs (5th, duplicated root) over protected PCs
                        if (isProtectedPc)
                        {
                            // Skip protected PCs in second pass - only consider as last resort
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                UnityEngine.Debug.Log(
                                    $"[PASS2_REJECT] step={stepIndex} voice {i}: pc={currentPc} " +
                                    $"REJECTED: protectedPC (requested tension) - will try in pass 3 if needed");
                            }
                            continue;
                        }
                        
                        // Only replace Required tones if absolutely necessary (no other option)
                        // Part B: Allow overwriting Required tones if they are duplicated (not sole provider)
                        // SPECIAL CASE: For tension enforcement, allow overwriting Required 5th even if sole provider
                        bool isDuplicated = pcCounts.GetValueOrDefault(currentPc, 0) > 1;
                        bool isSoleProvider = IsSoleProviderOfPc(i, currentPc, pcCounts);
                        bool isRequiredSoleProvider = currentPriority == ChordTonePriority.Required && isSoleProvider;
                        bool isRequiredFifth = currentPc == fifthPc && currentPriority == ChordTonePriority.Required;
                        
                        if (isRequiredSoleProvider && !(isTensionEnforcement && isRequiredFifth))
                        {
                            // Skip non-duplicated Required tones unless we have no other choice
                            // Exception: allow Required 5th for tension enforcement
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                UnityEngine.Debug.Log(
                                    $"[PASS2_REJECT] step={stepIndex} voice {i}: pc={currentPc} priority={currentPriority} " +
                                    $"REJECTED: required sole provider (not 5th for tension enforcement)");
                            }
                            continue;
                        }
                        
                        foreach (int candidate in candidates)
                        {
                            // SOFT PREFERENCE: Prefer #9 >= 3rd, but allow #9 < 3rd so solver can discover it's bad and reassign 3rd
                            
                            // CRITICAL: Prevent #9–3rd minor 2nd crunch between Soprano and Alto
                            // If #9 is in Soprano and 3rd is in Alto with m2 interval, reject this candidate
                            if (isSharp9Enforcement && WouldCreateSharp9ThirdCrunch(voices, i, candidate, thirdPc))
                            {
                                continue; // Skip candidates that create m2 crunch or force high octave
                            }
                            
                            int baseDistance = Math.Abs(candidate - voices[i]);
                            // Apply soft penalty if #9 is below 3rd (prefer #9 >= 3rd, but allow it)
                            int adjustedDistance = baseDistance;
                            if (isSharp9Enforcement && thirdMidi >= 0 && candidate < thirdMidi)
                            {
                                // Add penalty for being below 3rd (encourages solver to prefer #9 >= 3rd)
                                // But don't reject - allow solver to discover and reassign 3rd
                                adjustedDistance = baseDistance + (thirdMidi - candidate) * 2; // 2x penalty for each semitone below
                            }
                            
                            if (adjustedDistance < bestDistance)
                            {
                                bestVoiceIndex = i;
                                bestCandidateMidi = candidate;
                                bestDistance = adjustedDistance;
                                bestReplacedPriority = currentPriority;
                                
                                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                                {
                                    string victimReason = isDuplicated ? "duplicated" : 
                                                         currentPc == fifthPc ? "5th" : 
                                                         currentPc == rootPc ? "root" : "other";
                                    UnityEngine.Debug.Log(
                                        $"[VICTIM_SELECTED] step={stepIndex} PASS2: Selected voice {i} (pc={currentPc}, priority={currentPriority}) " +
                                        $"for requiredPC={requiredPc}, reason={victimReason}");
                                }
                            }
                        }
                    }
                }
                } // End of standard single-best-voice logic (only if first-chord heuristic didn't find a placement)
                
                // Third pass (LAST RESORT): If still no voice found, consider protected PCs (requested tensions)
                // This should be rare - only happens if no non-protected alternative exists
                if (bestVoiceIndex < 0)
                {
                    if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                    {
                        string requiredPcName = requiredPc == rootPc ? "root" : 
                                               requiredPc == thirdPc ? "3rd" :
                                               requiredPc == fifthPc ? "5th" :
                                               requiredPc == seventhPc ? "7th" : $"pc={requiredPc}";
                        UnityEngine.Debug.LogWarning(
                            $"[REQ_EXT_ENFORCE] Third pass (LAST RESORT): No non-protected voice found for {requiredPcName}, " +
                            $"considering protected PCs (requested tensions) as last resort");
                    }
                    
                    for (int i = 1; i <= maxVoiceIndex; i++)
                    {
                        int currentPc = (voices[i] % 12 + 12) % 12;
                        
                        // DIRECT GUARD (TOP PRIORITY): NEVER select a voice whose PC is a requested tension
                        // This must be checked FIRST, before any other logic - even in pass 3
                        if (requestedTensionPcs.Contains(currentPc))
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                string tensionName = (req.TensionFlat9 && currentPc == (rootPc + 1) % 12) ? "b9" :
                                                     (req.Tension9 && currentPc == (rootPc + 2) % 12) ? "9" :
                                                     (req.TensionSharp9 && currentPc == (rootPc + 3) % 12) ? "#9" :
                                                     (req.TensionSharp11 && currentPc == (rootPc + 6) % 12) ? "#11" : "?";
                                UnityEngine.Debug.Log(
                                    $"[VICTIM_GUARD] step={stepIndex} PASS3: REJECTING voice {i} (pc={currentPc}={tensionName}) " +
                                    $"for requiredPC={requiredPc} - requested tension must never be overwritten (DIRECT GUARD)");
                            }
                            continue; // Skip this voice - it contains a requested tension
                        }
                        
                        // Skip locked resolution voices
                        if (lockedResolutionVoices != null && i < lockedResolutionVoices.Length && lockedResolutionVoices[i])
                        {
                            continue;
                        }
                        
                        // FIXED: Skip protected voices entirely in third pass - they must never be overwritten
                        if (protectedVoiceIndices.Contains(i))
                        {
                            int voicePc = (voices[i] % 12 + 12) % 12;
                            bool isRequestedTension = (req.TensionFlat9 && voicePc == (rootPc + 1) % 12) ||
                                                      (req.Tension9 && voicePc == (rootPc + 2) % 12) ||
                                                      (req.TensionSharp9 && voicePc == (rootPc + 3) % 12) ||
                                                      (req.TensionSharp11 && voicePc == (rootPc + 6) % 12);
                            
                            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                            {
                                string tensionName = (req.TensionFlat9 && voicePc == (rootPc + 1) % 12) ? "b9" :
                                                     (req.Tension9 && voicePc == (rootPc + 2) % 12) ? "9" :
                                                     (req.TensionSharp9 && voicePc == (rootPc + 3) % 12) ? "#9" :
                                                     (req.TensionSharp11 && voicePc == (rootPc + 6) % 12) ? "#11" : "?";
                                string requiredPcName = requiredPc == rootPc ? "root" : 
                                                       requiredPc == thirdPc ? "3rd" :
                                                       requiredPc == fifthPc ? "5th" :
                                                       requiredPc == seventhPc ? "7th" : $"pc={requiredPc}";
                                
                                UnityEngine.Debug.LogWarning(
                                    $"[REQ_EXT_SKIP] step={stepIndex} PASS 3: Skipping protected voice {i} (contains {tensionName}, pc={voicePc}) " +
                                    $"when placing required {requiredPcName} (pc={requiredPc}). Protected voices are never overwritten.");
                            }
                            continue; // SKIP protected voices entirely - they must never be overwritten
                        }
                        ChordTonePriority currentPriority = pcToPriority.GetValueOrDefault(currentPc, ChordTonePriority.Optional);
                        
                        // Part B: Helper to check if this voice is the sole provider of its PC
                        bool IsSoleProviderOfPcThirdPass(int voiceIdx, int pc, Dictionary<int, int> pcCountsDict)
                        {
                            return pcCountsDict.GetValueOrDefault(pc, 0) <= 1;
                        }
                        
                        bool isDuplicated = pcCounts.GetValueOrDefault(currentPc, 0) > 1;
                        bool isSoleProvider = IsSoleProviderOfPcThirdPass(i, currentPc, pcCounts);
                        bool isRequiredSoleProvider = currentPriority == ChordTonePriority.Required && isSoleProvider;
                        bool isRequiredFifth = currentPc == fifthPc && currentPriority == ChordTonePriority.Required;
                        
                        if (isRequiredSoleProvider && !(isTensionEnforcement && isRequiredFifth))
                        {
                            continue;
                        }
                        
                        foreach (int candidate in candidates)
                        {
                            if (isSharp9Enforcement && WouldCreateSharp9ThirdCrunch(voices, i, candidate, thirdPc))
                            {
                                continue;
                            }
                            
                            int baseDistance = Math.Abs(candidate - voices[i]);
                            int adjustedDistance = baseDistance;
                            if (isSharp9Enforcement && thirdMidi >= 0 && candidate < thirdMidi)
                            {
                                adjustedDistance = baseDistance + (thirdMidi - candidate) * 2;
                            }
                            
                            if (adjustedDistance < bestDistance)
                            {
                                bestVoiceIndex = i;
                                bestCandidateMidi = candidate;
                                bestDistance = adjustedDistance;
                                bestReplacedPriority = currentPriority;
                                
                                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                                {
                                    UnityEngine.Debug.Log(
                                        $"[VICTIM_SELECTED] step={stepIndex} PASS3: Selected voice {i} (pc={currentPc}, priority={currentPriority}) " +
                                        $"for requiredPC={requiredPc} - LAST RESORT (no non-protected alternative)");
                                }
                            }
                        }
                    }
                }

                // FINAL CHECK: If no legal victim found, emit loud warning
                if (bestVoiceIndex < 0)
                {
                    string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    string requiredPcName = requiredPc == rootPc ? "root" : 
                                           requiredPc == thirdPc ? "3rd" :
                                           requiredPc == fifthPc ? "5th" :
                                           requiredPc == seventhPc ? "7th" : $"pc={requiredPc}";
                    int sopranoIndex = voices.Length - 1;
                    bool sopranoExcluded = protectSoprano;
                    string sopranoExclusionReason = sopranoExcluded ? "EXCLUDED (protectSoprano=true, melody-locked)" : "included (protectSoprano=false, Play mode)";
                    string voiceInfo = string.Join(", ", voices.Select((v, idx) => {
                        string voiceName = idx == 0 ? "B" : idx == 1 ? "T" : idx == 2 ? "A" : idx == 3 ? "S" : $"v{idx}";
                        int pc = (v % 12 + 12) % 12;
                        bool isRequestedTension = requestedTensionPcs.Contains(pc);
                        bool isRequired = requiredPcs.Contains(pc);
                        string status = isRequestedTension ? "REQUESTED_TENSION" : isRequired ? "required" : "other";
                        bool excludedByMaxVoiceIndex = idx > maxVoiceIndex;
                        string exclusion = excludedByMaxVoiceIndex ? " [EXCLUDED_BY_MAXVOICEINDEX]" : "";
                        return $"{voiceName}={v}(pc={pc},{status}){exclusion}";
                    }));
                    string requestedTensionPcsStr = string.Join(",", requestedTensionPcs);
                    
                    // DIAGNOSTIC: Final summary for diminished triads
                    if (shouldLogDimTriadDiag)
                    {
                        // Determine dominant reason
                        string dominantReason = "unknown";
                        if (candidates.Count == 0)
                        {
                            dominantReason = "no candidates in register bounds";
                        }
                        else if (rejectionLog.Count > 0)
                        {
                            // Count rejection types
                            int spacingRejections = rejectionLog.Count(r => r.Contains("spacing"));
                            int orderingRejections = rejectionLog.Count(r => r.Contains("ordering"));
                            int protectedRejections = rejectionLog.Count(r => r.Contains("protected") || r.Contains("would remove only"));
                            int lockedRejections = rejectionLog.Count(r => r.Contains("locked"));
                            
                            if (protectedRejections > 0)
                                dominantReason = "all voices protected (required tones)";
                            else if (lockedRejections > 0)
                                dominantReason = "all voices locked (7th resolution)";
                            else if (spacingRejections > orderingRejections)
                                dominantReason = "spacing constraints";
                            else if (orderingRejections > 0)
                                dominantReason = "ordering constraints (voice crossing)";
                            else
                                dominantReason = "all candidates rejected";
                        }
                        else
                        {
                            dominantReason = "no valid replacement found";
                        }
                        
                        // Print all rejection reasons
                        string rejectionStr = rejectionLog.Count > 0 ? string.Join("\n  ", rejectionLog) : "none";
                        UnityEngine.Debug.LogWarning(
                            $"[FIX_COVERAGE_DIAG] step={stepIndex} token={token}\n" +
                            $"  RESULT: FAIL no valid replacement for missingPc={requiredPc} because: {dominantReason}\n" +
                            $"  Rejection details:\n  {rejectionStr}");
                    }
                    
                    UnityEngine.Debug.LogError(
                        $"[NO_LEGAL_VICTIM] step={stepIndex} token={token} rootPc={rootPc}\n" +
                        $"  CRITICAL: Cannot place required {requiredPcName} (pc={requiredPc}) - NO LEGAL VICTIM FOUND\n" +
                        $"  protectSoprano={protectSoprano}, maxVoiceIndex={maxVoiceIndex}, sopranoIndex={sopranoIndex} {sopranoExclusionReason}\n" +
                        $"  All voices are protected (required tones or requested tensions) or excluded by maxVoiceIndex\n" +
                        $"  voices: {voiceInfo}\n" +
                        $"  requestedTensionPcs=[{requestedTensionPcsStr}]\n" +
                        $"  This should never happen - all voices contain required tones or requested tensions that cannot be overwritten");
                    
                    // FALLBACK: Explicitly search for perfect 5th including Soprano when not melody-locked
                    // The perfect 5th should be the FIRST choice for replacement
                    if (!protectSoprano && fifthPc >= 0)
                    {
                        for (int i = 1; i < voices.Length; i++) // Check ALL voices including Soprano
                        {
                            int voicePc = (voices[i] % 12 + 12) % 12;
                            
                            // Check if this is the perfect 5th and it's NOT a requested tension or required tone
                            bool isPerfectFifth = voicePc == fifthPc;
                            bool isRequestedTension = requestedTensionPcs.Contains(voicePc);
                            bool isRequired = requiredPcs.Contains(voicePc);
                            
                            if (isPerfectFifth && !isRequestedTension && !isRequired)
                            {
                                // Found the perfect 5th - use it as victim
                                ChordTonePriority voicePriority = pcToPriority.GetValueOrDefault(voicePc, ChordTonePriority.Optional);
                                
                                // Find best candidate for this voice
                                int bestCandidateForFifth = -1;
                                int bestDistanceForFifth = int.MaxValue;
                                
                                foreach (int candidate in candidates)
                                {
                                    int distance = Math.Abs(candidate - voices[i]);
                                    if (distance < bestDistanceForFifth)
                                    {
                                        bestCandidateForFifth = candidate;
                                        bestDistanceForFifth = distance;
                                    }
                                }
                                
                                if (bestCandidateForFifth >= 0)
                                {
                                    bestVoiceIndex = i;
                                    bestCandidateMidi = bestCandidateForFifth;
                                    bestDistance = bestDistanceForFifth;
                                    bestReplacedPriority = voicePriority;
                                    
                                    UnityEngine.Debug.LogWarning(
                                        $"[FALLBACK_5TH] step={stepIndex} Using perfect 5th fallback: voice {i} (pc={voicePc}, " +
                                        $"midi={voices[i]}) for requiredPC={requiredPc}. " +
                                        $"Soprano was NOT excluded (protectSoprano=false), so 5th in Soprano is eligible. " +
                                        $"This should have been selected in normal passes.");
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Debug logging: Show result of voice selection
                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement)
                {
                    string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                         (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                         (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                    if (bestVoiceIndex >= 0 && bestCandidateMidi >= 0)
                    {
                        string voiceName = bestVoiceIndex == 1 ? "Tenor" : bestVoiceIndex == 2 ? "Alto" : "Soprano";
                        int oldMidi = voices[bestVoiceIndex];
                        int oldPc = (oldMidi % 12 + 12) % 12;
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_ENFORCE] Selected replacement: {voiceName} (voice {bestVoiceIndex}) " +
                            $"old={oldMidi} (pc={oldPc}) -> new={bestCandidateMidi} (pc={requiredPc}, {tensionName}), distance={bestDistance}");
                    }
                    else
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[REQ_EXT_ENFORCE] FAILED to find replacement voice for tension={tensionName} (requiredPC={requiredPc})\n" +
                            $"  bestVoiceIndex={bestVoiceIndex}, bestCandidateMidi={bestCandidateMidi}, candidates.Count={candidates.Count}");
                    }
                }
                
                // If we found a candidate, replace it (only if it doesn't break spacing)
                if (bestVoiceIndex >= 0 && bestCandidateMidi >= 0)
                {
                    // CRITICAL: Never overwrite a voice that contains the required 7th (even if not in protectedVoiceIndices yet)
                    // This is especially important for natural 9, which is processed after 7th placement
                    bool isNatural9 = req.Tension9 && requiredPc == (rootPc + 2) % 12;
                    if (hasSeventh && seventhPc >= 0 && isNatural9)
                    {
                        int bestVoicePc = (voices[bestVoiceIndex] % 12 + 12) % 12;
                        if (bestVoicePc == seventhPc)
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect)
                            {
                                UnityEngine.Debug.LogWarning(
                                    $"[7TH_PROTECT_NAT9] step={stepIndex} BLOCKED natural 9 placement: would overwrite voice {bestVoiceIndex} containing 7th (pc={seventhPc}). Skipping this candidate.");
                            }
                            // Skip this candidate - try alternative voices or skip natural 9 placement
                            continue;
                        }
                    }
                    
                    // CRITICAL: Never overwrite a protected voice that contains a requested tension
                    if (protectedVoiceIndices.Contains(bestVoiceIndex))
                    {
                        // Check if this requiredPc is a requested tension itself
                        bool isRequestedTension = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ||
                                                  (req.Tension9 && requiredPc == (rootPc + 2) % 12) ||
                                                  (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12);
                        
                        // Check if this requiredPc is Optional (like 5th) - if so, skip it entirely
                        ChordTonePriority requiredPcPriority = pcToPriority.GetValueOrDefault(requiredPc, ChordTonePriority.Optional);
                        bool isOptional = requiredPcPriority == ChordTonePriority.Optional;
                        
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            int voicePc = (voices[bestVoiceIndex] % 12 + 12) % 12;
                            string tensionName = (req.TensionFlat9 && voicePc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && voicePc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && voicePc == (rootPc + 6) % 12) ? "#11" : "?";
                            string pcName = requiredPc == rootPc ? "root" : 
                                           requiredPc == thirdPc ? "3rd" :
                                           requiredPc == fifthPc ? "5th" :
                                           requiredPc == seventhPc ? "7th" : $"pc={requiredPc}";
                            UnityEngine.Debug.LogWarning(
                                $"[REQ_EXT_PROTECT] step={stepIndex} BLOCKED overwrite of protected voice {bestVoiceIndex} " +
                                $"(contains {tensionName}, pc={voicePc}) to enforce {pcName} (priority={requiredPcPriority}, isRequestedTension={isRequestedTension})");
                        }
                        
                        // If this is a requested tension, we MUST try alternative voices - don't give up
                        if (isRequestedTension)
                        {
                            // Try to find an alternative voice that is NOT protected
                            int altBestVoiceIndex = -1;
                            int altBestCandidateMidi = -1;
                            int altBestDistance = int.MaxValue;
                            ChordTonePriority altBestReplacedPriority = ChordTonePriority.Required;
                            
                            // Search all non-protected voices for a replacement opportunity
                            for (int i = 1; i <= maxVoiceIndex; i++)
                            {
                                if (protectedVoiceIndices.Contains(i)) continue;
                                if (lockedResolutionVoices != null && i < lockedResolutionVoices.Length && lockedResolutionVoices[i]) continue;
                                
                                int currentPc = (voices[i] % 12 + 12) % 12;
                                ChordTonePriority currentPriority = pcToPriority.GetValueOrDefault(currentPc, ChordTonePriority.Optional);
                                
                                // Prefer overwriting Optional or duplicated tones
                                bool isOptionalAlt = currentPriority == ChordTonePriority.Optional;
                                bool isDuplicatedAlt = pcCounts[currentPc] > 1;
                                
                                if (isOptionalAlt || (isDuplicatedAlt && currentPriority != ChordTonePriority.Required))
                                {
                                    foreach (int candidate in candidates)
                                    {
                                        int distance = Math.Abs(candidate - voices[i]);
                                        bool betterChoice = (isOptionalAlt && currentPriority < altBestReplacedPriority) ||
                                                           (isDuplicatedAlt && !isOptionalAlt && currentPriority <= altBestReplacedPriority && distance < altBestDistance) ||
                                                           (distance < altBestDistance && currentPriority < altBestReplacedPriority);
                                        
                                        if (betterChoice)
                                        {
                                            altBestVoiceIndex = i;
                                            altBestCandidateMidi = candidate;
                                            altBestDistance = distance;
                                            altBestReplacedPriority = currentPriority;
                                        }
                                    }
                                }
                            }
                            
                            // If no Optional/Preferred found, try any non-protected voice
                            if (altBestVoiceIndex < 0)
                            {
                                for (int i = 1; i <= maxVoiceIndex; i++)
                                {
                                    if (protectedVoiceIndices.Contains(i)) continue;
                                    if (lockedResolutionVoices != null && i < lockedResolutionVoices.Length && lockedResolutionVoices[i]) continue;
                                    
                                    int currentPc = (voices[i] % 12 + 12) % 12;
                                    ChordTonePriority currentPriority = pcToPriority.GetValueOrDefault(currentPc, ChordTonePriority.Optional);
                                    bool isDuplicatedAlt = pcCounts[currentPc] > 1;
                                    
                                    // Prefer duplicated tones even if Required
                                    if (currentPriority == ChordTonePriority.Required && !isDuplicatedAlt) continue;
                                    
                                    foreach (int candidate in candidates)
                                    {
                                        // SOFT PREFERENCE: Prefer #9 >= 3rd, but allow #9 < 3rd so solver can discover it's bad and reassign 3rd
                                        
                                        int baseDistance = Math.Abs(candidate - voices[i]);
                                        // Apply soft penalty if #9 is below 3rd (prefer #9 >= 3rd, but allow it)
                                        int adjustedDistance = baseDistance;
                                        if (isSharp9Enforcement && thirdMidi >= 0 && candidate < thirdMidi)
                                        {
                                            // Add penalty for being below 3rd (encourages solver to prefer #9 >= 3rd)
                                            adjustedDistance = baseDistance + (thirdMidi - candidate) * 2; // 2x penalty for each semitone below
                                        }
                                        int distance = adjustedDistance;
                                        if (distance < altBestDistance)
                                        {
                                            altBestVoiceIndex = i;
                                            altBestCandidateMidi = candidate;
                                            altBestDistance = distance;
                                            altBestReplacedPriority = currentPriority;
                                        }
                                    }
                                }
                            }
                            
                            // If we found an alternative, use it
                            if (altBestVoiceIndex >= 0 && altBestCandidateMidi >= 0)
                            {
                                bestVoiceIndex = altBestVoiceIndex;
                                bestCandidateMidi = altBestCandidateMidi;
                                bestDistance = altBestDistance;
                                bestReplacedPriority = altBestReplacedPriority;
                                
                                if (s_debugTensionVerbose && s_debugTensionDetect)
                                {
                                    string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                         (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                         (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                                    UnityEngine.Debug.Log(
                                        $"[REQ_EXT_ENFORCE] step={stepIndex} Found alternative voice {bestVoiceIndex} for requested tension {tensionName} " +
                                        $"(avoided protected voice)");
                                }
                            }
                            else
                            {
                                // No alternative found - this is a real failure
                                if (s_debugTensionVerbose && s_debugTensionDetect)
                                {
                                    string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                         (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                         (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                                    UnityEngine.Debug.LogWarning(
                                        $"[REQ_EXT_ENFORCE] step={stepIndex} FAILED to place requested tension {tensionName} " +
                                        $"- all candidate voices are protected or locked");
                                }
                                continue; // Skip this requiredPc - truly cannot place it
                            }
                        }
                        // If this is an Optional tone (like 5th), skip it entirely rather than trying other voices
                        // This implements the priority: tensions > 3rd/7th > root > 5th
                        else if (isOptional)
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect)
                            {
                                string pcName = requiredPc == fifthPc ? "5th" : $"pc={requiredPc}";
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_PROTECT] step={stepIndex} SKIPPING optional {pcName} enforcement - " +
                                    $"would require overwriting protected tension. Priority: tensions > optional tones.");
                            }
                            continue; // Skip optional tone enforcement
                        }
                        else
                        {
                            // For Required/Preferred tones that aren't tensions, try alternative voices
                            // (Similar logic to above, but we'll keep it simpler for now)
                            continue; // Skip for now - could enhance later if needed
                        }
                    }
                    
                    // CRITICAL: Verify the candidate has the exact required pitch class
                    // This ensures b9 (root+1) cannot be satisfied by natural 9 (root+2)
                    int candidatePc = (bestCandidateMidi % 12 + 12) % 12;
                    if (candidatePc != requiredPc)
                    {
                        // This should never happen if GenerateCandidatesInRange works correctly
                        if (s_debugTensionDetect && req.HasAny)
                        {
                            string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                            UnityEngine.Debug.LogError(
                                $"[REQ_EXT_DEBUG] ERROR: Candidate {bestCandidateMidi} has PC={candidatePc} but requiredPC={requiredPc} (tension={tensionName}) - rejecting assignment");
                        }
                        // Skip this candidate - it has the wrong pitch class
                        continue;
                    }
                    
                    // Check if this candidate would break spacing
                    bool spacingCheck = !WouldBreakSpacing(voices, bestVoiceIndex, bestCandidateMidi);
                    if (s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement)
                    {
                        string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                             (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                             (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                        string voiceName = bestVoiceIndex == 0 ? "Bass" : bestVoiceIndex == 1 ? "Tenor" : bestVoiceIndex == 2 ? "Alto" : "Soprano";
                        var voicesBeforeSpacing = string.Join(",", voices);
                        if (s_debugTensionVerbose)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_SPACING] step={stepIndex} BEFORE spacing check: voice {bestVoiceIndex} ({voiceName}), " +
                                $"old={voices[bestVoiceIndex]}, new={bestCandidateMidi}, spacingCheck={spacingCheck}, voices=[{voicesBeforeSpacing}]");
                        }
                    }
                    
                    if (spacingCheck)
                    {
                        int oldMidi = voices[bestVoiceIndex];
                        int oldPc = (oldMidi % 12 + 12) % 12;
                        string voiceName = bestVoiceIndex == 0 ? "Bass" : bestVoiceIndex == 1 ? "Tenor" : bestVoiceIndex == 2 ? "Alto" : "Soprano";

                        // Log BEFORE assignment
                        if (s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement)
                        {
                            string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                            var voicesBeforeAssign = string.Join(",", voices);
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_ASSIGN] step={stepIndex} BEFORE assignment: bestVoiceIndex={bestVoiceIndex} ({voiceName}), " +
                                $"old={oldMidi}, new={bestCandidateMidi}, tension={tensionName}, voices=[{voicesBeforeAssign}]");
                        }

                        // Update the voice
                        // DIAGNOSTIC: Log before assignment
                        int oldMidiBeforeAssign = voices[bestVoiceIndex];
                        
                        // CRITICAL: In SATB+melody mode, prevent Alto < Tenor (hard no-crossing constraint)
                        // protectSoprano == true indicates SATB+melody mode
                        if (protectSoprano && bestVoiceIndex == 2 && voices.Length >= 2)
                        {
                            int tenorMidi = voices[1];
                            if (bestCandidateMidi < tenorMidi)
                            {
                                // This assignment would cause Alto < Tenor - reject it
                                if (stepIndex == 2) // Log for chord IV in repro
                                {
                                    UnityEngine.Debug.LogWarning(
                                        $"[SATB_NO_CROSSING] FixChordToneCoverage BLOCKED: Cannot assign Alto={bestCandidateMidi} " +
                                        $"(PC={requiredPc}) because it would be < Tenor={tenorMidi} in SATB+melody mode. " +
                                        $"Chord: {TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe)}");
                                }
                                continue; // Skip this assignment - try next requiredPc or voice
                            }
                        }
                        
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_ASSIGN_DIAG] === ASSIGNING TENSION TO VOICE ===\n" +
                            $"  Voice index: {bestVoiceIndex} ([0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano)\n" +
                            $"  BEFORE: voices[{bestVoiceIndex}] = {oldMidiBeforeAssign}\n" +
                            $"  AFTER:  voices[{bestVoiceIndex}] = {bestCandidateMidi}\n" +
                            $"  Current voice array state:\n" +
                            $"    voices[0] (Bass) = {voices[0]}\n" +
                            $"    voices[1] (Tenor) = {(voices.Length > 1 ? voices[1].ToString() : "N/A")}\n" +
                            $"    voices[2] (Alto) = {(voices.Length > 2 ? voices[2].ToString() : "N/A")}\n" +
                            $"    voices[3] (Soprano) = {(voices.Length > 3 ? voices[3].ToString() : "N/A")}");
                        
                        voices[bestVoiceIndex] = bestCandidateMidi;
                        
                        // DIAGNOSTIC: Success summary for diminished triads
                        if (shouldLogDimTriadDiag)
                        {
                            string voiceNameSuccess = bestVoiceIndex == 0 ? "B" : bestVoiceIndex == 1 ? "T" : bestVoiceIndex == 2 ? "A" : "S";
                            int oldPcSuccess = (oldMidiBeforeAssign % 12 + 12) % 12;
                            string token = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            UnityEngine.Debug.Log(
                                $"[FIX_COVERAGE_DIAG] step={stepIndex} token={token}\n" +
                                $"  RESULT: SUCCESS replaced voice={voiceNameSuccess} oldPc={oldPcSuccess} -> newPc={requiredPc} candidateMidi={bestCandidateMidi}");
                        }
                        
                        // CHECKPOINT C: Immediately after tension enforcement (right after FixChordToneCoverage assignment)
                        if (s_debugSharp9OctaveTrace && stepIndex == 0 && isSharp9Enforcement)
                        {
                            string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                            int b = voices.Length > 0 ? voices[0] : -1;
                            int t = voices.Length > 1 ? voices[1] : -1;
                            int a = voices.Length > 2 ? voices[2] : -1;
                            int s = voices.Length > 3 ? voices[3] : -1;
                            bool containsPc10 = false;
                            int laneWithSharp9 = -1;
                            int midiWithSharp9 = -1;
                            for (int v = 0; v < voices.Length; v++)
                            {
                                int voicePc = (voices[v] % 12 + 12) % 12;
                                if (voicePc == requiredPc)
                                {
                                    containsPc10 = true;
                                    laneWithSharp9 = v;
                                    midiWithSharp9 = voices[v];
                                    break;
                                }
                            }
                            string laneName = laneWithSharp9 >= 0 ? (laneWithSharp9 == 0 ? "B" : laneWithSharp9 == 1 ? "T" : laneWithSharp9 == 2 ? "A" : "S") : "none";
                            string pitchName = midiWithSharp9 >= 0 ? TheoryPitch.GetPitchNameFromMidi(midiWithSharp9, chordEvent.Key) : "none";
                            UnityEngine.Debug.Log(
                                $"[SHARP9_TRACE][ENFORCE] step=0 chord={chordLabel} B={b} T={t} A={a} S={s} containsPc{requiredPc}={containsPc10} laneWithSharp9={laneName} midi={midiWithSharp9}({pitchName})");
                        }
                        
                        // DIAGNOSTIC: Log after assignment to verify (especially for first chord)
                        int actualMidiAfterAssign = voices[bestVoiceIndex];
                        if (stepIndex == 0)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_ASSIGN_DIAG] === ASSIGNMENT COMPLETE (FIRST CHORD) ===\n" +
                                $"  voices[{bestVoiceIndex}] ({voiceName}) = {actualMidiAfterAssign} (expected {bestCandidateMidi}, match={actualMidiAfterAssign == bestCandidateMidi})\n" +
                                $"  Final voice array:\n" +
                                $"    voices[0] (Bass) = {voices[0]}\n" +
                                $"    voices[1] (Tenor) = {(voices.Length > 1 ? voices[1].ToString() : "N/A")}\n" +
                                $"    voices[2] (Alto) = {(voices.Length > 2 ? voices[2].ToString() : "N/A")}\n" +
                                $"    voices[3] (Soprano) = {(voices.Length > 3 ? voices[3].ToString() : "N/A")}\n" +
                                $"  Ordering check: B<=T={voices[0] <= voices[1]}, T<=A={(voices.Length < 3 || voices[1] <= voices[2])}, A<=S={(voices.Length < 4 || voices[2] <= voices[3])}");
                        }
                        else
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_ASSIGN_DIAG] Assignment complete. Verified: voices[{bestVoiceIndex}] ({voiceName}) = {actualMidiAfterAssign} " +
                                $"(expected {bestCandidateMidi}, match={actualMidiAfterAssign == bestCandidateMidi})");
                        }
                        
                        // Debug: Log immediately after assignment to verify mutation
                        if (s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement)
                        {
                            string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                            int currentValue = voices[bestVoiceIndex]; // Read back to verify mutation
                            var currentVoices = string.Join(",", voices);
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_APPLY] step={stepIndex} IMMEDIATELY AFTER assignment: voice {bestVoiceIndex} ({voiceName}) = {currentValue} " +
                                $"(required={bestCandidateMidi}, tension={tensionName}), voices array=[{currentVoices}]");
                        }
                        
                        // Log AFTER assignment
                        if (s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement)
                        {
                            string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                            int actualValue = voices[bestVoiceIndex]; // Read back to verify mutation
                            var voicesAfterAssign = string.Join(",", voices);
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_ASSIGN] step={stepIndex} AFTER assignment: voices[{bestVoiceIndex}]={actualValue} " +
                                $"(expected={bestCandidateMidi}), voices=[{voicesAfterAssign}]");
                        }
                        
                        // Final verification: verify the assigned MIDI has the correct PC
                        int assignedPc = (bestCandidateMidi % 12 + 12) % 12;
                        if (assignedPc != requiredPc)
                        {
                            if (s_debugTensionDetect && req.HasAny)
                            {
                                string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                     (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                     (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                                var voicesBeforeRevert = string.Join(",", voices);
                                UnityEngine.Debug.LogError(
                                    $"[REQ_EXT_REVERT] step={stepIndex} BEFORE revert (PC mismatch): voice {bestVoiceIndex} has PC={assignedPc} but requiredPC={requiredPc} (tension={tensionName}), voices=[{voicesBeforeRevert}]");
                            }
                            // Revert the assignment
                            voices[bestVoiceIndex] = oldMidi;
                            if (s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement)
                            {
                                var voicesAfterRevert = string.Join(",", voices);
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_REVERT] step={stepIndex} AFTER revert: voices[{bestVoiceIndex}]={oldMidi}, voices=[{voicesAfterRevert}]");
                            }
                            continue;
                        }

                        // Update counts
                        pcCounts[oldPc] = pcCounts[oldPc] - 1;
                        if (pcCounts[oldPc] == 0)
                        {
                            pcCounts.Remove(oldPc);
                        }
                        pcCounts[requiredPc] = pcCounts.GetValueOrDefault(requiredPc, 0) + 1;
                        
                        // Debug: Log successful enforcement
                        if (s_debugTensionDetect && req.HasAny)
                        {
                            bool isTension = (req.Tension9 && requiredPc == (rootPc + 2) % 12) ||
                                            (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ||
                                            (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12);
                            if (isTension)
                            {
                                string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                     (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                     (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                                // Read back voices array to verify mutation persisted
                                int actualValue = voices[bestVoiceIndex];
                                var currentVoicesState = string.Join(",", voices);
                                if (s_debugTensionVerbose && s_debugTensionDetect)
                                {
                                    UnityEngine.Debug.Log(
                                        $"[REQ_EXT_DEBUG] enforced requiredPC={requiredPc} (tension={tensionName}) " +
                                        $"in voice {bestVoiceIndex} ({voiceName}): {oldMidi}(PC={oldPc}) -> {bestCandidateMidi}(PC={assignedPc}) " +
                                        $"[VERIFY: voices[{bestVoiceIndex}]={actualValue}, full array=[{currentVoicesState}]]");
                                }
                            }
                        }
                        
                        // STRUCTURAL REPAIR: Move 3rd out of Alto when #9 is in Soprano
                        // Run immediately after #9 is placed, before continuing to next requiredPc
                        if (isSharp9Enforcement && bestVoiceIndex == 3 && voices.Length >= 4) // #9 just placed in Soprano
                        {
                            int sharp9Pc = (rootPc + 3) % 12;
                            int sopranoPc = (voices[3] % 12 + 12) % 12;
                            int altoPc = (voices[2] % 12 + 12) % 12;
                            
                            // Check trigger condition: #9 in Soprano AND 3rd in Alto
                            if (sopranoPc == sharp9Pc && altoPc == thirdPc)
                            {
                                int altoThirdMidi = voices[2];
                                int thirdDown = altoThirdMidi - 12; // Move 3rd down an octave to Tenor
                                
                                // Validate: only check range and post-repair ordering (not spacing, not old Tenor)
                                bool fitsTenorRange = thirdDown >= upperMinMidi && thirdDown <= upperMaxMidi;
                                
                                if (fitsTenorRange)
                                {
                                    // Find alternative chord tone for Alto (priority: 7th → 5th → root)
                                    int repairSeventhPc = hasSeventh && chordTonePcs.Count > 3 ? chordTonePcs[3] : -1;
                                    
                                    int newAltoMidi = -1;
                                    int newAltoPc = -1;
                                    
                                    // Try 7th first
                                    if (hasSeventh && repairSeventhPc >= 0 && repairSeventhPc != sharp9Pc && repairSeventhPc != thirdPc)
                                    {
                                        var seventhCandidates = GenerateCandidatesInRange(new List<int> { repairSeventhPc }, upperMinMidi, upperMaxMidi);
                                        var altoRangeSevenths = seventhCandidates.Where(c => c >= upperMinMidi && c <= upperMaxMidi && 
                                            c > thirdDown && c < voices[3]).ToList();
                                        if (altoRangeSevenths.Count > 0)
                                        {
                                            newAltoMidi = altoRangeSevenths.OrderBy(c => Math.Abs(c - altoThirdMidi)).First();
                                            newAltoPc = repairSeventhPc;
                                        }
                                    }
                                    
                                    // Try 5th if 7th didn't work
                                    if (newAltoMidi < 0 && fifthPc != sharp9Pc && fifthPc != thirdPc)
                                    {
                                        var fifthCandidates = GenerateCandidatesInRange(new List<int> { fifthPc }, upperMinMidi, upperMaxMidi);
                                        var altoRangeFifths = fifthCandidates.Where(c => c >= upperMinMidi && c <= upperMaxMidi && 
                                            c > thirdDown && c < voices[3]).ToList();
                                        if (altoRangeFifths.Count > 0)
                                        {
                                            newAltoMidi = altoRangeFifths.OrderBy(c => Math.Abs(c - altoThirdMidi)).First();
                                            newAltoPc = fifthPc;
                                        }
                                    }
                                    
                                    // Try root if 5th didn't work
                                    if (newAltoMidi < 0 && rootPc != sharp9Pc && rootPc != thirdPc)
                                    {
                                        var rootCandidates = GenerateCandidatesInRange(new List<int> { rootPc }, upperMinMidi, upperMaxMidi);
                                        var altoRangeRoots = rootCandidates.Where(c => c >= upperMinMidi && c <= upperMaxMidi && 
                                            c > thirdDown && c < voices[3]).ToList();
                                        if (altoRangeRoots.Count > 0)
                                        {
                                            newAltoMidi = altoRangeRoots.OrderBy(c => Math.Abs(c - altoThirdMidi)).First();
                                            newAltoPc = rootPc;
                                        }
                                    }
                                    
                                    // Apply repair if we found a valid alternative for Alto
                                    if (newAltoMidi >= 0)
                                    {
                                        int oldTenorMidi = voices[1];
                                        int oldAltoMidi = voices[2];
                                        int oldSopranoMidi = voices[3];
                                        
                                        // CRITICAL: In SATB+melody mode, prevent Alto < Tenor (hard no-crossing constraint)
                                        // protectSoprano == true indicates SATB+melody mode
                                        if (protectSoprano && newAltoMidi < thirdDown)
                                        {
                                            // This assignment would cause Alto < Tenor - reject it
                                            if (stepIndex == 2) // Log for chord IV in repro
                                            {
                                                UnityEngine.Debug.LogWarning(
                                                    $"[SATB_NO_CROSSING] FixChordToneCoverage #9 repair BLOCKED: Cannot assign Alto={newAltoMidi} " +
                                                    $"because it would be < Tenor={thirdDown} in SATB+melody mode.");
                                            }
                                            // Skip this repair - will fall back to other strategies
                                            continue;
                                        }
                                        
                                        // Apply the repair
                                        voices[1] = thirdDown; // Move 3rd to Tenor
                                        voices[2] = newAltoMidi; // Assign Alto to alternative chord tone
                                        
                                        // Validate only: range (already checked), BTAS ordering, chord tone correctness
                                        // Do NOT check spacing - allow wide gaps temporarily
                                        bool orderingValid = voices[0] <= voices[1] && voices[1] <= voices[2] && voices[2] <= voices[3];
                                        
                                        // Verify chord tone correctness: new Alto must have correct PC
                                        bool altoPcCorrect = ((newAltoMidi % 12 + 12) % 12) == newAltoPc;
                                        
                                        if (orderingValid && altoPcCorrect)
                                        {
                                            // After moving 3rd down, check if #9 can be lowered from high octave (A#5 → A#4)
                                            if (oldSopranoMidi >= 82) // A#5 or higher
                                            {
                                                int lowerSharp9Midi = oldSopranoMidi - 12; // A#4 = 70
                                                // Check if lower #9 is now legal (>= new Tenor and within range)
                                                if (lowerSharp9Midi >= upperMinMidi && lowerSharp9Midi >= thirdDown && 
                                                    lowerSharp9Midi < newAltoMidi)
                                                {
                                                    // Test if lowering #9 maintains ordering (spacing deferred)
                                                    int[] testVoices = (int[])voices.Clone();
                                                    testVoices[3] = lowerSharp9Midi;
                                                    if (testVoices[0] <= testVoices[1] && testVoices[1] <= testVoices[2] && testVoices[2] <= testVoices[3])
                                                    {
                                                        voices[3] = lowerSharp9Midi; // Lower #9 from A#5 to A#4
                                                    }
                                                }
                                            }
                                            
                                            string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                                            string newAltoName = TheoryPitch.GetPitchNameFromMidi(newAltoMidi, chordEvent.Key);
                                            string thirdName = TheoryPitch.GetPitchNameFromMidi(thirdDown, chordEvent.Key);
                                            string sharp9Name = TheoryPitch.GetPitchNameFromMidi(voices[3], chordEvent.Key);
                                            
                                            UnityEngine.Debug.Log(
                                                $"[#9_REPAIR] step={stepIndex} chord={chordLabel}: Moved 3rd out of Alto to prevent #9 high-octave forcing\n" +
                                                $"  BEFORE: T={oldTenorMidi} A={oldAltoMidi}(3rd) S={oldSopranoMidi}(#9)\n" +
                                                $"  AFTER:  T={thirdDown}(3rd) A={newAltoMidi}({newAltoPc}) S={voices[3]}(#9)\n" +
                                                $"  Repair: Alto 3rd→Tenor {thirdName}, Alto→{newAltoName} (pc={newAltoPc}), Soprano→{sharp9Name}");
                                        }
                                        else
                                        {
                                            // Repair invalid - revert
                                            voices[1] = oldTenorMidi;
                                            voices[2] = oldAltoMidi;
                                            string failureReason = !orderingValid ? "ordering" : "missingCandidate";
                                            UnityEngine.Debug.LogWarning(
                                                $"[#9_REPAIR] step={stepIndex}: Repair failed - {failureReason} invalid. " +
                                                $"BEFORE: B={voices[0]} T={oldTenorMidi} A={oldAltoMidi} S={oldSopranoMidi} " +
                                                $"AFTER: B={voices[0]} T={thirdDown} A={newAltoMidi} S={voices[3]}");
                                        }
                                    }
                                    else
                                    {
                                        // Could not find alternative for Alto
                                        UnityEngine.Debug.LogWarning(
                                            $"[#9_REPAIR] step={stepIndex}: Repair failed - missingCandidate. " +
                                            $"BEFORE: B={voices[0]} T={voices[1]} A={altoThirdMidi} S={voices[3]} " +
                                            $"Could not find 7th/5th/root for Alto");
                                    }
                                }
                                else
                                {
                                    // Range check failed
                                    UnityEngine.Debug.LogWarning(
                                        $"[#9_REPAIR] step={stepIndex}: Repair failed - range invalid. " +
                                        $"BEFORE: B={voices[0]} T={voices[1]} A={altoThirdMidi} S={voices[3]} " +
                                        $"thirdDown={thirdDown} not in range [{upperMinMidi}, {upperMaxMidi}]");
                                }
                            }
                        }
                        
                        // CRITICAL: Continue to next requiredPC after successful replacement
                        // This ensures we only replace one voice per requiredPC and don't overwrite our own changes
                        // Use continue to skip to next iteration of foreach (int requiredPc in sortedRequiredPcs)
                        continue;
                    }
                    else
                    {
                        if (GetTendencyDebug() || (s_debugTensionDetect && stepIndex >= 0 && isTensionEnforcement))
                        {
                            string voiceLabel = (bestVoiceIndex == 1) ? "Tenor" : (bestVoiceIndex == 2) ? "Alto" : $"Voice{bestVoiceIndex}";
                            string tensionName = (req.TensionFlat9 && requiredPc == (rootPc + 1) % 12) ? "b9" :
                                                 (req.Tension9 && requiredPc == (rootPc + 2) % 12) ? "9" :
                                                 (req.TensionSharp11 && requiredPc == (rootPc + 6) % 12) ? "#11" : "?";
                            var voicesAtSpacingSkip = string.Join(",", voices);
                            if (s_debugTensionVerbose)
                            {
                                UnityEngine.Debug.LogWarning(
                                    $"[REQ_EXT_SPACING] step={stepIndex} SKIPPED assignment: {voiceLabel} candidate {bestCandidateMidi} (tension={tensionName}) " +
                                    $"would break spacing, voices=[{voicesAtSpacingSkip}]");
                            }
                        }
                    }
                }
            }
            
            // Note: Structural repair for #9 is now handled immediately after #9 placement (see above)
            // This ensures it runs before any protect-tension or strict spacing enforcement
            
            // Debug logging after coverage fixes
            if (enableTendencyDebug && hasSeventh)
            {
                var afterPcs = new List<string>();
                for (int i = 0; i < voices.Length; i++)
                {
                    int midi = voices[i];
                    string name = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                    afterPcs.Add(name);
                }
                UnityEngine.Debug.Log($"[ChordCoverage Debug] Step: Chord has 7th, enforcing presence. After: {string.Join(", ", afterPcs)}");
            }

            // Final invariant check: Compute final realized PCs and verify requested tensions
            var finalRealizedPcs = new HashSet<int>();
            for (int i = 0; i < voices.Length; i++)
            {
                int pc = (voices[i] % 12 + 12) % 12;
                finalRealizedPcs.Add(pc);
            }
            
            // Check each requested tension and log detailed warnings if missing
            var missingTensions = new List<string>();
            var missingTensionPcs = new List<int>();
            var missingTensionReasons = new List<string>();
            
            if (req.TensionFlat9)
            {
                int b9Pc = (rootPc + 1) % 12;
                int ninePc = (rootPc + 2) % 12; // Natural 9 for guard check
                
                // Part C: Guard - check if natural 9 is present but b9 is missing
                if (!finalRealizedPcs.Contains(b9Pc) && finalRealizedPcs.Contains(ninePc))
                {
                    if (s_debugTensionDetect)
                    {
                        string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                        UnityEngine.Debug.LogWarning(
                            $"[B9_GUARD] step={stepIndex} token='{chordLabel}': natural9 (pc={ninePc}) present but does NOT satisfy b9 (pc={b9Pc})");
                    }
                }
                
                if (!finalRealizedPcs.Contains(b9Pc))
                {
                    missingTensions.Add("b9");
                    missingTensionPcs.Add(b9Pc);
                    
                    // Part A: Comprehensive trace for missing b9
                    if (s_debugTensionDetect && stepIndex >= 0)
                    {
                        string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                        string token = chordLabel; // Use label as token identifier
                        
                        // Check if token contains 7b9 or requested contains b9 (already checked by req.TensionFlat9)
                        var traceBuilder = new System.Text.StringBuilder();
                        traceBuilder.AppendLine($"[B9_FAILURE_TRACE] step={stepIndex} token='{token}' rootPc={rootPc} computed b9Pc={b9Pc}");
                        
                        // Parsing / requested
                        var reqList = new List<string>();
                        if (req.Sus4) reqList.Add("sus4");
                        if (req.Add9) reqList.Add("add9");
                        if (req.Add11) reqList.Add("add11");
                        if (req.Tension9) reqList.Add("9");
                        if (req.TensionFlat9) reqList.Add("b9");
                        if (req.TensionSharp11) reqList.Add("#11");
                        traceBuilder.AppendLine($"  Requested extensions: [{string.Join(",", reqList)}]");
                        
                        // Voice constraints
                        traceBuilder.AppendLine("  Voice constraints:");
                        string[] voiceNames = { "Bass", "Tenor", "Alto", "Soprano" };
                        for (int v = 0; v < voices.Length && v < 4; v++)
                        {
                            int voiceMin = (v == 0) ? 0 : upperMinMidi; // Bass has no upperMin constraint
                            int voiceMax = (v == voices.Length - 1 && protectSoprano) ? voices[v] : upperMaxMidi;
                            if (v == voices.Length - 1 && protectSoprano)
                            {
                                traceBuilder.AppendLine($"    {voiceNames[v]} (v={v}): range=[{voiceMin}, {voiceMax}] (protected, max=soprano-1 for inner voices)");
                            }
                            else
                            {
                                traceBuilder.AppendLine($"    {voiceNames[v]} (v={v}): range=[{voiceMin}, {voiceMax}]");
                            }
                        }
                        
                        // Candidate availability for b9Pc
                        traceBuilder.AppendLine("  Candidate availability for b9Pc:");
                        for (int v = 0; v < voices.Length && v < 4; v++)
                        {
                            if (v == 0) continue; // Skip bass
                            
                            int voiceMin = upperMinMidi;
                            int voiceMax = (v == voices.Length - 1 && protectSoprano) ? voices[voices.Length - 1] - 1 : upperMaxMidi;
                            
                            // Generate all candidates for b9Pc in this voice's range
                            var allCandidates = GenerateCandidatesInRange(new List<int> { b9Pc }, voiceMin, voiceMax);
                            int beforeFilter = allCandidates.Count;
                            
                            // Filter by spacing/crossing constraints
                            var validCandidates = new List<int>();
                            foreach (int candidate in allCandidates)
                            {
                                // Test if this candidate would break spacing if placed in voice v
                                bool wouldBreak = WouldBreakSpacing(voices, v, candidate);
                                if (!wouldBreak)
                                {
                                    validCandidates.Add(candidate);
                                }
                            }
                            int afterFilter = validCandidates.Count;
                            
                            string skipReason = "";
                            if (protectedVoiceIndices.Contains(v))
                            {
                                skipReason = " (protected - contains requested tension)";
                            }
                            else if (lockedResolutionVoices != null && v < lockedResolutionVoices.Length && lockedResolutionVoices[v])
                            {
                                skipReason = " (locked - 7th resolution)";
                            }
                            
                            traceBuilder.AppendLine($"    {voiceNames[v]} (v={v}): beforeFilter={beforeFilter} afterFilter={afterFilter}{skipReason}");
                            if (afterFilter == 0 && beforeFilter > 0)
                            {
                                traceBuilder.AppendLine($"      -> All candidates rejected by spacing/voice crossing constraints");
                            }
                        }
                        
                        // Enforcement decision
                        traceBuilder.AppendLine("  Enforcement decision:");
                        var currentVoicePcs = new List<int>();
                        for (int i = 0; i < voices.Length; i++)
                        {
                            int pc = (voices[i] % 12 + 12) % 12;
                            currentVoicePcs.Add(pc);
                        }
                        
                        int effectiveUpperMax = upperMaxMidi;
                        if (protectSoprano && voices.Length > 0)
                        {
                            effectiveUpperMax = Math.Min(upperMaxMidi, voices[voices.Length - 1] - 1);
                        }
                        var testCandidates = GenerateCandidatesInRange(new List<int> { b9Pc }, upperMinMidi, effectiveUpperMax);
                        
                        traceBuilder.AppendLine($"    b9Pc in requiredPcs: {requiredPcs.Contains(b9Pc)}");
                        traceBuilder.AppendLine($"    Total candidates for b9Pc in range [{upperMinMidi}, {effectiveUpperMax}]: {testCandidates.Count}");
                        
                        // List overwrite candidates
                        traceBuilder.AppendLine("    Overwrite candidates considered:");
                        for (int v = 1; v < voices.Length; v++)
                        {
                            if (protectedVoiceIndices.Contains(v))
                            {
                                int voicePcTrace = (voices[v] % 12 + 12) % 12;
                                traceBuilder.AppendLine($"      {voiceNames[v]} (v={v}): pc={voicePcTrace} SKIPPED (protected)");
                                continue;
                            }
                            if (lockedResolutionVoices != null && v < lockedResolutionVoices.Length && lockedResolutionVoices[v])
                            {
                                traceBuilder.AppendLine($"      {voiceNames[v]} (v={v}): SKIPPED (locked resolution)");
                                continue;
                            }
                            
                            int voicePc = (voices[v] % 12 + 12) % 12;
                            ChordTonePriority voicePriority = pcToPriority.GetValueOrDefault(voicePc, ChordTonePriority.Optional);
                            bool isDuplicated = pcCounts[voicePc] > 1;
                            bool isSoleProvider = !isDuplicated;
                            
                            // Check if any candidate could be placed here
                            bool hasValidCandidate = false;
                            foreach (int candidate in testCandidates)
                            {
                                if (!WouldBreakSpacing(voices, v, candidate))
                                {
                                    hasValidCandidate = true;
                                    break;
                                }
                            }
                            
                            traceBuilder.AppendLine($"      {voiceNames[v]} (v={v}): pc={voicePc} priority={voicePriority} duplicated={isDuplicated} soleProvider={isSoleProvider} hasValidCandidate={hasValidCandidate}");
                        }
                        
                        UnityEngine.Debug.LogWarning(traceBuilder.ToString());
                    }
                    
                    // Try to determine why it couldn't be inserted
                    string reason = "unknown";
                    // Check if b9Pc was in requiredPcs
                    if (!requiredPcs.Contains(b9Pc))
                    {
                        reason = "b9Pc not added to requiredPcs (parsing/initialization issue)";
                    }
                    else
                    {
                        // Check if there were candidates
                        int effectiveUpperMax = upperMaxMidi;
                        if (protectSoprano && voices.Length > 0)
                        {
                            int sopranoMidi = voices[voices.Length - 1];
                            effectiveUpperMax = Math.Min(upperMaxMidi, sopranoMidi - 1);
                        }
                        var testCandidates = GenerateCandidatesInRange(new List<int> { b9Pc }, upperMinMidi, effectiveUpperMax);
                        if (testCandidates.Count == 0)
                        {
                            reason = $"no candidate in register [{upperMinMidi}, {effectiveUpperMax}]";
                        }
                        else
                        {
                            // Check if all candidates would overwrite protected tensions
                            bool allProtected = true;
                            foreach (int candidate in testCandidates)
                            {
                                // Find which voice this candidate would target
                                int targetVoice = -1;
                                int minDist = int.MaxValue;
                                for (int v = 1; v < voices.Length; v++)
                                {
                                    if (protectedVoiceIndices.Contains(v)) continue;
                                    int dist = Math.Abs(candidate - voices[v]);
                                    if (dist < minDist)
                                    {
                                        minDist = dist;
                                        targetVoice = v;
                                    }
                                }
                                if (targetVoice >= 0 && !protectedVoiceIndices.Contains(targetVoice))
                                {
                                    allProtected = false;
                                    break;
                                }
                            }
                            if (allProtected)
                            {
                                reason = "only overwrite candidate would remove protected tension";
                            }
                            else
                            {
                                reason = "candidate generation succeeded but assignment failed (spacing/voice crossing constraint?)";
                            }
                        }
                    }
                    missingTensionReasons.Add(reason);
                }
            }
            
            if (req.TensionSharp9)
            {
                int sharp9Pc = (rootPc + 3) % 12;
                int ninePc = (rootPc + 2) % 12; // Natural 9 for guard check
                int b9Pc = (rootPc + 1) % 12; // b9 for guard check
                
                // Guard - check if natural 9 or b9 are present but #9 is missing
                if (!finalRealizedPcs.Contains(sharp9Pc) && (finalRealizedPcs.Contains(ninePc) || finalRealizedPcs.Contains(b9Pc)))
                {
                    if (s_debugTensionDetect)
                    {
                        string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                        UnityEngine.Debug.LogWarning(
                            $"[#9_GUARD] step={stepIndex} token='{chordLabel}': natural9 (pc={ninePc}) or b9 (pc={b9Pc}) present but does NOT satisfy #9 (pc={sharp9Pc})");
                    }
                }
                
                // SOFT PREFERENCE: #9 should be >= 3rd in MIDI (preferred, not required)
                // Find the #9 MIDI and 3rd MIDI in the final voicing
                int sharp9Midi = -1;
                int finalThirdMidi = -1;
                for (int i = 0; i < voices.Length; i++)
                {
                    int voicePc = (voices[i] % 12 + 12) % 12;
                    if (voicePc == sharp9Pc)
                    {
                        if (sharp9Midi < 0 || voices[i] < sharp9Midi)
                        {
                            sharp9Midi = voices[i];
                        }
                    }
                    // thirdPc is already defined above (from chordTonePcs[1])
                    if (voicePc == thirdPc)
                    {
                        if (finalThirdMidi < 0 || voices[i] < finalThirdMidi)
                        {
                            finalThirdMidi = voices[i];
                        }
                    }
                }
                
                if (sharp9Midi >= 0 && finalThirdMidi >= 0 && sharp9Midi < finalThirdMidi)
                {
                    string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    // This is now a soft preference violation, not a hard constraint
                    // The solver should prefer to reassign the 3rd to a lower voice, but we allow this temporarily
                    if (s_debugTensionVerbose && s_debugTensionDetect)
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[#9_VS_3RD_PREFERENCE] step={stepIndex} token='{chordLabel}': #9 MIDI ({sharp9Midi}) < 3rd MIDI ({finalThirdMidi}) - " +
                            $"Soft preference violated (solver should prefer reassigning 3rd to lower voice)");
                    }
                }
                
                if (!finalRealizedPcs.Contains(sharp9Pc))
                {
                    missingTensions.Add("#9");
                    missingTensionPcs.Add(sharp9Pc);
                    missingTensionReasons.Add("similar analysis as b9 (check candidates/register/protection)");
                }
            }
            
            if (req.Tension9)
            {
                int ninePc = (rootPc + 2) % 12;
                if (!finalRealizedPcs.Contains(ninePc))
                {
                    missingTensions.Add("9");
                    missingTensionPcs.Add(ninePc);
                    missingTensionReasons.Add("similar analysis as b9 (check candidates/register/protection)");
                }
            }
            
            if (req.TensionSharp11)
            {
                int sharp11Pc = (rootPc + 6) % 12;
                if (!finalRealizedPcs.Contains(sharp11Pc))
                {
                    missingTensions.Add("#11");
                    missingTensionPcs.Add(sharp11Pc);
                    missingTensionReasons.Add("similar analysis as b9 (check candidates/register/protection)");
                }
            }
            
            // Log detailed warning if any tensions are missing
            if (missingTensions.Count > 0)
            {
                string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                var voiceInfo = new List<string>();
                for (int i = 0; i < voices.Length && i < 4; i++)
                {
                    int midi = voices[i];
                    int pc = (midi % 12 + 12) % 12;
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                    voiceInfo.Add($"{voiceName}={midi}({pitchName},pc={pc})");
                }
                
                var computedTensionPcs = new List<string>();
                if (req.TensionFlat9) computedTensionPcs.Add($"b9={(rootPc + 1) % 12}");
                if (req.TensionSharp9) computedTensionPcs.Add($"#9={(rootPc + 3) % 12}");
                if (req.Tension9) computedTensionPcs.Add($"9={(rootPc + 2) % 12}");
                if (req.TensionSharp11) computedTensionPcs.Add($"#11={(rootPc + 6) % 12}");
                
                // Log missing tensions - keep as warning but reduce verbosity
                if (s_debugTensionVerbose)
                {
                    UnityEngine.Debug.LogWarning(
                        $"[REQ_EXT_INVARIANT] step={stepIndex} MISSING requested tension(s) for '{chordLabel}':\n" +
                        $"  rootPc={rootPc}\n" +
                        $"  requested tensions=[{string.Join(",", missingTensions)}]\n" +
                        $"  computed tension PCs=[{string.Join(",", computedTensionPcs)}]\n" +
                        $"  missing tension PCs=[{string.Join(",", missingTensionPcs)}]\n" +
                        $"  final voice MIDI/PCs: {string.Join(" ", voiceInfo)}\n" +
                        $"  final realized PCs=[{string.Join(",", finalRealizedPcs.OrderBy(x => x))}]\n" +
                        $"  reasons: {string.Join("; ", missingTensionReasons)}");
                }
                else
                {
                    // High-level summary only
                    UnityEngine.Debug.LogWarning(
                        $"WARNING: {chordLabel} missing requested tension(s): [{string.Join(",", missingTensions)}]");
                }
            }
            
            // Also call the existing validation (for backward compatibility)
            // CRITICAL: Only warn if tensions are actually missing from finalRealizedPcs
            // The missingTensions list is computed from finalRealizedPcs, so use that as the source of truth
            bool validationPassed = ValidateRequestedTensions(chordEvent, voices, chordEvent.Key);
            if (!validationPassed)
            {
                // Double-check against finalRealizedPcs to ensure consistency
                bool actuallyMissing = false;
                if (req.TensionFlat9)
                {
                    int b9Pc = (rootPc + 1) % 12;
                    if (!finalRealizedPcs.Contains(b9Pc)) actuallyMissing = true;
                }
                if (req.TensionSharp9)
                {
                    int sharp9Pc = (rootPc + 3) % 12;
                    if (!finalRealizedPcs.Contains(sharp9Pc)) actuallyMissing = true;
                }
                if (req.Tension9)
                {
                    int ninePc = (rootPc + 2) % 12;
                    if (!finalRealizedPcs.Contains(ninePc)) actuallyMissing = true;
                }
                if (req.TensionSharp11)
                {
                    int sharp11Pc = (rootPc + 6) % 12;
                    if (!finalRealizedPcs.Contains(sharp11Pc)) actuallyMissing = true;
                }
                
                // Only log if tensions are actually missing AND we haven't already logged above
                if (actuallyMissing && missingTensions.Count == 0)
                {
                    string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    UnityEngine.Debug.LogWarning(
                        $"[TENSION_ENFORCE] WARN: Could not realize requested tension(s) for {chordLabel} in this register/constraints. " +
                        $"Requested: {GetRequestedTensionsString(chordEvent.Recipe.RequestedExtensions)} " +
                        $"Final realized PCs: [{string.Join(",", finalRealizedPcs.OrderBy(x => x))}]");
                }
                else if (!actuallyMissing && s_debugTensionDetect)
                {
                    // Validation failed but tensions are actually present - this is a bug in ValidateRequestedTensions
                    string chordLabel = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                    UnityEngine.Debug.LogWarning(
                        $"[TENSION_ENFORCE] INCONSISTENCY: ValidateRequestedTensions returned false but tensions are present in finalRealizedPcs. " +
                        $"Chord: {chordLabel}, Final PCs: [{string.Join(",", finalRealizedPcs.OrderBy(x => x))}]");
                }
            }

            // Re-sort upper voices (indices 1..N-1) to maintain low→high order
            // If protectSoprano is true, exclude the soprano (last voice) from sorting
            // CRITICAL: For first chord (stepIndex==0) with requested tensions, verify b9 is preserved after sort
            if (voices.Length > 2)
            {
                // Log BEFORE re-sort
                if (s_debugTensionDetect && stepIndex >= 0)
                {
                    var voicesBeforeSort = string.Join(",", voices);
                    var reqExt = chordEvent.Recipe.RequestedExtensions;
                    if (reqExt.HasAny)
                    {
                        int rootPcForSort = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
                        if (rootPcForSort < 0) rootPcForSort = 0;
                        rootPcForSort = (rootPcForSort + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
                        if (rootPcForSort < 0) rootPcForSort += 12;
                        int b9PcForSort = reqExt.TensionFlat9 ? (rootPcForSort + 1) % 12 : -1;
                        bool hasB9BeforeSort = b9PcForSort >= 0 && voices.Any(v => (v % 12 + 12) % 12 == b9PcForSort);
                        if (s_debugTensionVerbose)
                        {
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_RESORT] step={stepIndex} BEFORE re-sort: voices=[{voicesBeforeSort}], protectSoprano={protectSoprano}, b9Pc={b9PcForSort}, b9Present={hasB9BeforeSort}");
                        }
                    }
                }
                
                var upperVoices = new List<int>();
                int lastIndex = voices.Length - 1;
                int endIndex = protectSoprano ? lastIndex : voices.Length;
                
                // Only include voices up to (but not including) soprano if protecting it
                for (int i = 1; i < endIndex; i++)
                {
                    upperVoices.Add(voices[i]);
                }
                var upperVoicesBeforeSort = string.Join(",", upperVoices);
                upperVoices.Sort();
                var upperVoicesAfterSort = string.Join(",", upperVoices);
                
                // Log the sort operation (verbose only)
                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0 && !upperVoicesBeforeSort.Equals(upperVoicesAfterSort))
                {
                    UnityEngine.Debug.Log(
                        $"[REQ_EXT_RESORT] step={stepIndex} SORT changed order: before=[{upperVoicesBeforeSort}], after=[{upperVoicesAfterSort}]");
                }
                
                // Write sorted inner voices back
                for (int i = 0; i < upperVoices.Count; i++)
                {
                    voices[i + 1] = upperVoices[i];
                }
                
                // DIAGNOSTIC: Verify b9 is still present after re-sort (stepIndex==0)
                if (stepIndex == 0 && chordEvent.Recipe.RequestedExtensions.HasAny)
                {
                    var reqExtForSort = chordEvent.Recipe.RequestedExtensions;
                    int rootPcForSortCheck = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
                    if (rootPcForSortCheck < 0) rootPcForSortCheck = 0;
                    rootPcForSortCheck = (rootPcForSortCheck + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
                    if (rootPcForSortCheck < 0) rootPcForSortCheck += 12;
                    int requiredB9PcAfterSort = reqExtForSort.TensionFlat9 ? (rootPcForSortCheck + 1) % 12 : -1;
                    
                    var pcsAfterSort = new List<int>();
                    for (int i = 0; i < voices.Length; i++)
                    {
                        pcsAfterSort.Add((voices[i] % 12 + 12) % 12);
                    }
                    bool b9PresentAfterSort = requiredB9PcAfterSort >= 0 && pcsAfterSort.Contains(requiredB9PcAfterSort);
                    string b9StatusAfterSort = requiredB9PcAfterSort >= 0 ? (b9PresentAfterSort ? "PRESENT" : "MISSING") : "N/A";
                    
                    UnityEngine.Debug.Log(
                        $"[EXIT_TRACE_AfterReSort] === AFTER RE-SORT in FixChordToneCoverage (stepIndex=0) ===\n" +
                        $"  voices MIDI array (BTAS): [{string.Join(", ", voices)}]\n" +
                        $"  pitch classes: [{string.Join(", ", pcsAfterSort)}]\n" +
                        $"  requiredB9Pc={requiredB9PcAfterSort}, b9Status={b9StatusAfterSort}\n" +
                        $"  rootPc={rootPcForSortCheck}, RequestedExtensions.b9={reqExtForSort.TensionFlat9}");
                }
                
                // Log AFTER re-sort (verbose only)
                if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
                {
                    var voicesAfterSort = string.Join(",", voices);
                    var reqExt = chordEvent.Recipe.RequestedExtensions;
                    if (reqExt.HasAny)
                    {
                        int rootPcForSort = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
                        if (rootPcForSort < 0) rootPcForSort = 0;
                        rootPcForSort = (rootPcForSort + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
                        if (rootPcForSort < 0) rootPcForSort += 12;
                        int b9PcForSort = reqExt.TensionFlat9 ? (rootPcForSort + 1) % 12 : -1;
                        bool hasB9AfterSort = b9PcForSort >= 0 && voices.Any(v => (v % 12 + 12) % 12 == b9PcForSort);
                        UnityEngine.Debug.Log(
                            $"[REQ_EXT_RESORT] step={stepIndex} AFTER re-sort: voices=[{voicesAfterSort}], b9Pc={b9PcForSort}, b9Present={hasB9AfterSort}");
                    }
                }
            }
            
            // Debug assertion: verify soprano is above inner voices when protectSoprano is true
            if (protectSoprano && voices.Length > 2 && GetTendencyDebug())
            {
                int lastIndex = voices.Length - 1;
                int sopranoMidi = voices[lastIndex];
                int highestInner = voices[lastIndex - 1];
                
                if (highestInner >= sopranoMidi)
                {
                    UnityEngine.Debug.LogWarning(
                        $"[Coverage Debug] After FixChordToneCoverage sort: " +
                        $"highest inner voice ({highestInner}) >= soprano ({sopranoMidi}). " +
                        "This should not happen if candidate generation respected protectSoprano.");
                }
            }
            
            // Trace D: Compact summary log per step (end-to-end b9 flow)
            if (s_debugTensionDetect && stepIndex >= 0)
            {
                var finalReq = chordEvent.Recipe.RequestedExtensions;
                var reqList = new List<string>();
                if (finalReq.TensionFlat9) reqList.Add("b9");
                if (finalReq.Tension9) reqList.Add("9");
                if (finalReq.TensionSharp11) reqList.Add("#11");
                string reqStr = reqList.Count > 0 ? string.Join(",", reqList) : "none";
                string label = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                
                // Compute b9 PC if requested
                int b9Pc = -1;
                if (finalReq.TensionFlat9)
                {
                    b9Pc = (rootPc + 1) % 12;
                }
                
                var voiceInfo = new List<string>();
                var pcs = new List<int>();
                // Reuse finalRealizedPcs computed above (in invariant check)
                for (int i = 0; i < voices.Length && i < 4; i++)
                {
                    int midi = voices[i];
                    int pc = (midi % 12 + 12) % 12;
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    string pitchName = TheoryPitch.GetPitchNameFromMidi(midi, chordEvent.Key);
                    voiceInfo.Add($"{voiceName}={midi}({pitchName},pc={pc})");
                    pcs.Add(pc);
                }
                
                var finalSatisfied = new List<string>();
                var finalUnsatisfied = new List<string>();
                if (finalReq.TensionFlat9)
                {
                    int b9PcCheck = (rootPc + 1) % 12;
                    if (finalRealizedPcs.Contains(b9PcCheck))
                        finalSatisfied.Add("b9");
                    else
                        finalUnsatisfied.Add("b9");
                }
                if (finalReq.Tension9)
                {
                    int ninePc = (rootPc + 2) % 12;
                    if (finalRealizedPcs.Contains(ninePc))
                        finalSatisfied.Add("9");
                    else
                        finalUnsatisfied.Add("9");
                }
                if (finalReq.TensionSharp11)
                {
                    int sharp11Pc = (rootPc + 6) % 12;
                    if (finalRealizedPcs.Contains(sharp11Pc))
                        finalSatisfied.Add("#11");
                    else
                        finalUnsatisfied.Add("#11");
                }
                
                // Compact summary log
                string postVoices = string.Join(" ", voiceInfo);
                string postPcs = string.Join(",", pcs.OrderBy(x => x));
                string b9PcStr = b9Pc >= 0 ? b9Pc.ToString() : "N/A";
                string satisfiedStr = finalSatisfied.Count > 0 ? string.Join(",", finalSatisfied) : "none";
                string unsatisfiedStr = finalUnsatisfied.Count > 0 ? string.Join(",", finalUnsatisfied) : "none";
                
                // Verbose flow tracing (gated)
                if (s_debugTensionVerbose && s_debugTensionDetect)
                {
                    UnityEngine.Debug.Log(
                        $"[B9_FLOW] step={stepIndex} token={label} rootPc={rootPc} req=[{reqStr}] b9Pc={b9PcStr} " +
                        $"postVoices=[{postVoices}] postPcs=[{postPcs}] satisfied=[{satisfiedStr}] unsatisfied=[{unsatisfiedStr}]");
                    
                    // Also log detailed trace
                    UnityEngine.Debug.Log(
                        $"[PLAY_VOICES_TRACE] D) Before returning from FixChordToneCoverage:\n" +
                        $"  step={stepIndex} label='{label}' rootPc={rootPc} requested=[{reqStr}]\n" +
                        $"  voices: {string.Join(" ", voiceInfo)}\n" +
                        $"  pcs=[{string.Join(",", pcs.OrderBy(x => x))}]\n" +
                        $"  satisfied=[{satisfiedStr}]\n" +
                        $"  unsatisfied=[{unsatisfiedStr}]");
                }
            }
            
            // CRITICAL: Log final voices array state to verify mutations persisted
            if (s_debugTensionVerbose && s_debugTensionDetect && stepIndex >= 0)
            {
                var finalVoicesArray = string.Join(",", voices);
                var finalPcsArray = new List<int>();
                for (int i = 0; i < voices.Length; i++)
                {
                    finalPcsArray.Add((voices[i] % 12 + 12) % 12);
                }
                var finalPcsStr = string.Join(",", finalPcsArray.OrderBy(x => x));
                UnityEngine.Debug.Log(
                    $"[REQ_EXT_FINAL] step={stepIndex} AT END of FixChordToneCoverage: " +
                    $"voices array=[{finalVoicesArray}], pcs=[{finalPcsStr}] " +
                    $"(should match postVoices in caller)");
            }
            
            // DIAGNOSTIC: Exit trace at end of FixChordToneCoverage (stepIndex==0 && tension enforcement)
            if (stepIndex == 0 && chordEvent.Recipe.RequestedExtensions.HasAny)
            {
                int rootPcForExit = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
                if (rootPcForExit < 0) rootPcForExit = 0;
                rootPcForExit = (rootPcForExit + chordEvent.Recipe.RootSemitoneOffset + 12) % 12;
                if (rootPcForExit < 0) rootPcForExit += 12;
                
                var reqExt = chordEvent.Recipe.RequestedExtensions;
                int requiredB9Pc = reqExt.TensionFlat9 ? (rootPcForExit + 1) % 12 : -1;
                
                var exitVoices = new List<string>();
                var exitPcs = new List<int>();
                for (int i = 0; i < voices.Length && i < 4; i++)
                {
                    int midi = voices[i];
                    int pc = (midi % 12 + 12) % 12;
                    string voiceName = i == 0 ? "B" : i == 1 ? "T" : i == 2 ? "A" : "S";
                    exitVoices.Add($"{voiceName}={midi}(pc={pc})");
                    exitPcs.Add(pc);
                }
                
                bool b9Present = requiredB9Pc >= 0 && exitPcs.Contains(requiredB9Pc);
                string b9Status = requiredB9Pc >= 0 ? (b9Present ? "PRESENT" : "MISSING") : "N/A";
                
                UnityEngine.Debug.Log(
                    $"[EXIT_TRACE_FixChordToneCoverage] === END OF FixChordToneCoverage (stepIndex=0) ===\n" +
                    $"  voices MIDI array (BTAS): [{string.Join(", ", voices)}]\n" +
                    $"  pitch classes: [{string.Join(", ", exitPcs)}]\n" +
                    $"  voice details: {string.Join(" ", exitVoices)}\n" +
                    $"  requiredB9Pc={requiredB9Pc}, b9Status={b9Status}\n" +
                    $"  rootPc={rootPcForExit}, RequestedExtensions.b9={reqExt.TensionFlat9}");
            }
            
            // CRITICAL FIX: Post-enforcement invariant guard for first chord (stepIndex == 0)
            // Ensure B <= T <= A <= S after all enforcement passes
            if (stepIndex == 0 && voices.Length >= 2)
            {
                bool hasViolation = ViolatesVoiceOrdering(voices);
                
                if (hasViolation)
                {
                    // Diagnostic warning
                    int bassMidi = voices.Length > 0 ? voices[0] : -1;
                    int tenorMidi = voices.Length > 1 ? voices[1] : -1;
                    int altoMidi = voices.Length > 2 ? voices[2] : -1;
                    int sopranoMidi = voices.Length > 3 ? voices[3] : -1;
                    
                    UnityEngine.Debug.LogWarning(
                        $"[VOICE_ORDERING] First chord (stepIndex=0) has voice crossing after FixChordToneCoverage:\n" +
                        $"  B={bassMidi} T={tenorMidi} A={altoMidi} S={sopranoMidi}\n" +
                        $"  Attempting correction...");
                    
                    // Attempt deterministic correction
                    bool corrected = CorrectVoiceOrdering(voices, upperMinMidi, upperMaxMidi);
                    
                    if (corrected)
                    {
                        int bassMidiAfter = voices.Length > 0 ? voices[0] : -1;
                        int tenorMidiAfter = voices.Length > 1 ? voices[1] : -1;
                        int altoMidiAfter = voices.Length > 2 ? voices[2] : -1;
                        int sopranoMidiAfter = voices.Length > 3 ? voices[3] : -1;
                        UnityEngine.Debug.Log(
                            $"[VOICE_ORDERING] Correction applied:\n" +
                            $"  B={bassMidiAfter} T={tenorMidiAfter} A={altoMidiAfter} S={sopranoMidiAfter}");
                    }
                    else
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[VOICE_ORDERING] Could not correct voice crossing - no legal octave shift available");
                    }
                    
                    // Hard assert in dev builds
                    #if UNITY_EDITOR
                    if (ViolatesVoiceOrdering(voices))
                    {
                        UnityEngine.Debug.LogError(
                            $"[VOICE_ORDERING] CRITICAL: First chord still has voice crossing after correction attempt!\n" +
                            $"  B={bassMidi} T={tenorMidi} A={altoMidi} S={sopranoMidi}");
                    }
                    #endif
                }
                
                // REGRESSION CHECK: Assert that first chord always has B <= T <= A <= S
                #if UNITY_EDITOR
                if (ViolatesVoiceOrdering(voices))
                {
                    UnityEngine.Debug.LogError(
                        $"[REGRESSION] First chord (stepIndex=0) violates voice ordering invariant after FixChordToneCoverage!\n" +
                        $"  This should never happen after ordering checks and correction.");
                }
                #endif
            }
            
            // Global invariant: Ensure every chord has a 3rd (if the chord type normally has one)
            // Reconstruct chord tone pitch classes (same logic as VoiceFirstChord)
            int rootPcForThird = TheoryScale.GetDegreePitchClass(chordEvent.Key, chordEvent.Recipe.Degree);
            if (rootPcForThird < 0) rootPcForThird = 0;
            rootPcForThird = (rootPcForThird + chordEvent.Recipe.RootSemitoneOffset) % 12;
            if (rootPcForThird < 0) rootPcForThird += 12;
            
            // Determine if this is a 7th chord
            bool hasSeventhForThird = chordEvent.Recipe.Extension == ChordExtension.Seventh &&
                                      chordEvent.Recipe.SeventhQuality != SeventhQuality.None;
            
            // Calculate intervals from root based on chord quality
            int thirdIntervalForThird, fifthIntervalForThird, seventhIntervalForThird = 0;
            
            switch (chordEvent.Recipe.Quality)
            {
                case ChordQuality.Major:
                    thirdIntervalForThird = 4;  // major third
                    fifthIntervalForThird = 7; // perfect fifth
                    break;
                case ChordQuality.Minor:
                    thirdIntervalForThird = 3;  // minor third
                    fifthIntervalForThird = 7;  // perfect fifth
                    break;
                case ChordQuality.Diminished:
                    thirdIntervalForThird = 3;  // minor third
                    fifthIntervalForThird = 6;  // diminished fifth
                    break;
                case ChordQuality.Augmented:
                    thirdIntervalForThird = 4;  // major third
                    fifthIntervalForThird = 8;  // augmented fifth
                    break;
                default:
                    thirdIntervalForThird = 4;
                    fifthIntervalForThird = 7;
                    break;
            }
            
            // Calculate 7th interval if present
            if (hasSeventhForThird)
            {
                switch (chordEvent.Recipe.SeventhQuality)
                {
                    case SeventhQuality.Major7:
                        seventhIntervalForThird = 11; // major 7th
                        break;
                    case SeventhQuality.Minor7:
                    case SeventhQuality.Dominant7:
                    case SeventhQuality.HalfDiminished7:
                        seventhIntervalForThird = 10; // minor 7th
                        break;
                    case SeventhQuality.Diminished7:
                        seventhIntervalForThird = 9; // diminished 7th
                        break;
                    default:
                        seventhIntervalForThird = 10;
                        break;
                }
            }
            
            // Calculate pitch classes
            int thirdPcForThird = (rootPcForThird + thirdIntervalForThird) % 12;
            int fifthPcForThird = (rootPcForThird + fifthIntervalForThird) % 12;
            int seventhPcForThird = hasSeventhForThird ? (rootPcForThird + seventhIntervalForThird) % 12 : -1;
            
            // Determine if chord has a third (treat all current Ionian diatonic chords as having a third)
            // In the future, this could check for sus chords, but for now assume all chords have a third
            bool chordHasThird = true; // All current chord types have a third
            
            // Check current coverage
            bool hasThird = false;
            
            for (int i = 0; i < voices.Length; i++)
            {
                int pc = (voices[i] % 12 + 12) % 12;
                if (pc == thirdPcForThird)
                {
                    hasThird = true;
                    break;
                }
            }
            
            // If chord doesn't have a third conceptually, or third is already present, skip
            if (!chordHasThird || hasThird)
            {
                // Third is present or not required - nothing to do
            }
            else
            {
                // Attempt to convert one of the inner voices into a 3rd
                int sopranoIndex = voices.Length - 1;
                
                // Build candidate indices (inner voices that are root or fifth duplicates)
                var candidateIndices = new List<int>();
                for (int i = 1; i < voices.Length; i++)
                {
                    // Skip soprano if it's protected
                    if (protectSoprano && i == sopranoIndex)
                        continue;
                    
                    // CRITICAL: Skip protected voices that contain requested tensions
                    if (protectedVoiceIndices.Contains(i))
                    {
                            if (s_debugTensionVerbose && s_debugTensionDetect)
                            {
                                int voicePc = (voices[i] % 12 + 12) % 12;
                                string tensionName = (req.TensionFlat9 && voicePc == (rootPc + 1) % 12) ? "b9" :
                                                     (req.Tension9 && voicePc == (rootPc + 2) % 12) ? "9" :
                                                     (req.TensionSharp11 && voicePc == (rootPc + 6) % 12) ? "#11" : "?";
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_PROTECT] step={stepIndex} skipping protected voice {i} in 3rd enforcement (contains {tensionName}, pc={voicePc})");
                            }
                        continue;
                    }
                    
                    // Skip locked resolution voices (if provided)
                    if (lockedResolutionVoices != null && i < lockedResolutionVoices.Length && lockedResolutionVoices[i])
                        continue;
                    
                    int pc = (voices[i] % 12 + 12) % 12;
                    
                    // Only consider root or fifth duplicates
                    if (pc == rootPcForThird || pc == fifthPcForThird)
                    {
                        candidateIndices.Add(i);
                    }
                }
                
                // Prefer root duplicates over fifth duplicates
                candidateIndices.Sort((i1, i2) =>
                {
                    int pc1 = (voices[i1] % 12 + 12) % 12;
                    int pc2 = (voices[i2] % 12 + 12) % 12;
                    bool isRoot1 = (pc1 == rootPcForThird);
                    bool isRoot2 = (pc2 == rootPcForThird);
                    if (isRoot1 && !isRoot2) return -1; // root comes first
                    if (!isRoot1 && isRoot2) return 1;
                    return 0; // same priority
                });
                
                if (candidateIndices.Count == 0)
                {
                    // Can't fix coverage without removing some "unique" chord tone
                    if (GetTendencyDebug())
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[Coverage Debug] Could not add chord 3rd for {chordEvent.Recipe} - no duplicate root/fifth voices available to convert.");
                    }
                }
                else
                {
                    // Try each candidate
                    bool thirdAdded = false;
                    foreach (int candidateIndex in candidateIndices)
                    {
                        int oldMidi = voices[candidateIndex];
                        
                        // Calculate permissive range for inner voices (similar to 7th resolution)
                        // Allow going below upperMinMidi to find a valid 3rd, but ensure it's above bass
                        int permissiveMinMidi = upperMinMidi;
                        if (candidateIndex > 0 && candidateIndex < voices.Length - 1) // Inner voice (not bass, not soprano)
                        {
                            int minFromBass = voices[0] + 1;
                            int minFromUpper = upperMinMidi - 12;
                            permissiveMinMidi = Math.Min(minFromBass, minFromUpper);
                            permissiveMinMidi = Math.Max(permissiveMinMidi, 48); // Absolute minimum
                        }
                        
                        // Constrain upper bound when protecting soprano
                        int effectiveMaxMidi = upperMaxMidi;
                        if (protectSoprano && voices.Length > 0)
                        {
                            int sopranoMidi = voices[voices.Length - 1];
                            effectiveMaxMidi = Math.Min(upperMaxMidi, sopranoMidi - 1);
                        }
                        
                        // Find nearest 3rd within permissive range
                        int newMidi = SnapToNearestPitchClassWithinRange(thirdPcForThird, oldMidi, permissiveMinMidi, effectiveMaxMidi);
                        
                        if (newMidi < 0)
                        {
                            continue; // No valid 3rd in range
                        }
                        
                        // Temporarily set the voice to the 3rd
                        voices[candidateIndex] = newMidi;
                        
                        // Re-sort inner voices (same logic as above)
                        if (voices.Length > 2)
                        {
                            var upperVoicesForThird = new List<int>();
                            int lastIndexForThird = voices.Length - 1;
                            int endIndexForThird = protectSoprano ? lastIndexForThird : voices.Length;
                            
                            for (int i = 1; i < endIndexForThird; i++)
                            {
                                upperVoicesForThird.Add(voices[i]);
                            }
                            upperVoicesForThird.Sort();
                            
                            for (int i = 0; i < upperVoicesForThird.Count; i++)
                            {
                                voices[i + 1] = upperVoicesForThird[i];
                            }
                        }
                        
                        // Validate order and spacing
                        bool orderValid = ValidateVoiceOrder(voices, out string orderError);
                        bool spacingValid = true;
                        if (voices.Length >= 4)
                        {
                            spacingValid = !ViolatesHardSpacing(voices[0], voices[1], voices[2], voices[3]);
                        }
                        
                        if (orderValid && spacingValid)
                        {
                            // Success - third is now present
                            thirdAdded = true;
                            if (GetTendencyDebug())
                            {
                                string voiceLabel = (candidateIndex == 1) ? "Tenor" : (candidateIndex == 2) ? "Alto" : $"Voice{candidateIndex}";
                                UnityEngine.Debug.Log(
                                    $"[Coverage Debug] Added chord 3rd by converting {voiceLabel} from {oldMidi} to {newMidi} for {chordEvent.Recipe}");
                            }
                            break;
                        }
                        else
                        {
                            // Revert the change
                            voices[candidateIndex] = oldMidi;
                            
                            // Re-sort again to restore original order
                            if (voices.Length > 2)
                            {
                                var upperVoicesRevert = new List<int>();
                                int lastIndexRevert = voices.Length - 1;
                                int endIndexRevert = protectSoprano ? lastIndexRevert : voices.Length;
                                
                                for (int i = 1; i < endIndexRevert; i++)
                                {
                                    upperVoicesRevert.Add(voices[i]);
                                }
                                upperVoicesRevert.Sort();
                                
                                for (int i = 0; i < upperVoicesRevert.Count; i++)
                                {
                                    voices[i + 1] = upperVoicesRevert[i];
                                }
                            }
                        }
                    }
                    
                    if (!thirdAdded && GetTendencyDebug())
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[Coverage Debug] Could not add chord 3rd for {chordEvent.Recipe} without breaking hard spacing/order.");
                    }
                }
            }
            
            // Fallback: If 7th is still missing for a 7th chord, try harder to add it
            if (hasSeventh && seventhPc >= 0)
            {
                var pcCountsAfterMainLoop = new Dictionary<int, int>();
                for (int i = 0; i < voices.Length; i++)
                {
                    int pc = (voices[i] % 12 + 12) % 12;
                    pcCountsAfterMainLoop[pc] = pcCountsAfterMainLoop.GetValueOrDefault(pc, 0) + 1;
                }
                
                bool seventhStillMissing = !pcCountsAfterMainLoop.ContainsKey(seventhPc) || pcCountsAfterMainLoop[seventhPc] == 0;
                
                if (seventhStillMissing)
                {
                    // Try to add 7th by converting a duplicated voice or any upper voice
                    // Use a more permissive range to find candidates
                    int permissiveMinMidi = upperMinMidi - 12; // Allow going an octave below
                    permissiveMinMidi = Math.Max(permissiveMinMidi, 48); // But not below absolute minimum
                    
                    int effectiveMaxMidi = upperMaxMidi;
                    if (protectSoprano && voices.Length > 0)
                    {
                        int sopranoMidi = voices[voices.Length - 1];
                        effectiveMaxMidi = Math.Min(upperMaxMidi, sopranoMidi - 1);
                    }
                    
                    // Try each upper voice (except soprano if protected)
                    int maxVoiceIndex = protectSoprano ? voices.Length - 2 : voices.Length - 1;
                    bool seventhAdded = false;
                    
                    // First pass: try replacing duplicated pitch classes
                    for (int candidateIndex = 1; candidateIndex <= maxVoiceIndex && !seventhAdded; candidateIndex++)
                    {
                        // CRITICAL: Skip protected voices that contain requested tensions
                        if (protectedVoiceIndices.Contains(candidateIndex))
                        {
                            if (s_debugTensionVerbose && s_debugTensionDetect)
                            {
                                int voicePc = (voices[candidateIndex] % 12 + 12) % 12;
                                string tensionName = (req.TensionFlat9 && voicePc == (rootPc + 1) % 12) ? "b9" :
                                                     (req.Tension9 && voicePc == (rootPc + 2) % 12) ? "9" :
                                                     (req.TensionSharp11 && voicePc == (rootPc + 6) % 12) ? "#11" : "?";
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_PROTECT] step={stepIndex} skipping protected voice {candidateIndex} in 7th fallback (contains {tensionName}, pc={voicePc})");
                            }
                            continue;
                        }
                        
                        // Skip locked resolution voices
                        if (lockedResolutionVoices != null && candidateIndex < lockedResolutionVoices.Length && lockedResolutionVoices[candidateIndex])
                        {
                            continue;
                        }
                        
                        int oldMidi = voices[candidateIndex];
                        int oldPc = (oldMidi % 12 + 12) % 12;
                        
                        // Prefer replacing duplicated pitch classes
                        if (pcCountsAfterMainLoop.GetValueOrDefault(oldPc, 0) <= 1)
                        {
                            continue; // Not duplicated, skip for now
                        }
                        
                        // Find nearest 7th within permissive range
                        int newMidi = SnapToNearestPitchClassWithinRange(seventhPc, oldMidi, permissiveMinMidi, effectiveMaxMidi);
                        
                        if (newMidi < 0)
                        {
                            continue; // No valid 7th in range
                        }
                        
                        // Temporarily set the voice to the 7th
                        voices[candidateIndex] = newMidi;
                        
                        // Re-sort inner voices
                        if (voices.Length > 2)
                        {
                            var upperVoicesForSeventh = new List<int>();
                            int lastIndexForSeventh = voices.Length - 1;
                            int endIndexForSeventh = protectSoprano ? lastIndexForSeventh : voices.Length;
                            
                            for (int i = 1; i < endIndexForSeventh; i++)
                            {
                                upperVoicesForSeventh.Add(voices[i]);
                            }
                            upperVoicesForSeventh.Sort();
                            
                            for (int i = 0; i < upperVoicesForSeventh.Count; i++)
                            {
                                voices[i + 1] = upperVoicesForSeventh[i];
                            }
                        }
                        
                        // Validate order and spacing
                        bool orderValid = ValidateVoiceOrder(voices, out string orderError);
                        bool spacingValid = true;
                        if (voices.Length >= 4)
                        {
                            spacingValid = !ViolatesHardSpacing(voices[0], voices[1], voices[2], voices[3]);
                        }
                        
                        if (orderValid && spacingValid)
                        {
                            // Success - 7th is now present
                            seventhAdded = true;
                            if (GetTendencyDebug())
                            {
                                string voiceLabel = (candidateIndex == 1) ? "Tenor" : (candidateIndex == 2) ? "Alto" : $"Voice{candidateIndex}";
                                UnityEngine.Debug.Log(
                                    $"[Coverage Debug] Added chord 7th by converting {voiceLabel} from {oldMidi} to {newMidi} for {chordEvent.Recipe}");
                            }
                            break;
                        }
                        else
                        {
                            // Revert the change
                            voices[candidateIndex] = oldMidi;
                            
                            // Re-sort again to restore original order
                            if (voices.Length > 2)
                            {
                                var upperVoicesRevert = new List<int>();
                                int lastIndexRevert = voices.Length - 1;
                                int endIndexRevert = protectSoprano ? lastIndexRevert : voices.Length;
                                
                                for (int i = 1; i < endIndexRevert; i++)
                                {
                                    upperVoicesRevert.Add(voices[i]);
                                }
                                upperVoicesRevert.Sort();
                                
                                for (int i = 0; i < upperVoicesRevert.Count; i++)
                                {
                                    voices[i + 1] = upperVoicesRevert[i];
                                }
                            }
                        }
                    }
                    
                    // Second pass: if still not added, try any upper voice (not just duplicated)
                    if (!seventhAdded)
                    {
                        for (int candidateIndex = 1; candidateIndex <= maxVoiceIndex && !seventhAdded; candidateIndex++)
                        {
                            // Skip locked resolution voices
                            if (lockedResolutionVoices != null && candidateIndex < lockedResolutionVoices.Length && lockedResolutionVoices[candidateIndex])
                            {
                                continue;
                            }
                            
                            int oldMidi = voices[candidateIndex];
                            
                            // Find nearest 7th within permissive range
                            int newMidi = SnapToNearestPitchClassWithinRange(seventhPc, oldMidi, permissiveMinMidi, effectiveMaxMidi);
                            
                            if (newMidi < 0)
                            {
                                continue; // No valid 7th in range
                            }
                            
                            // Temporarily set the voice to the 7th
                            voices[candidateIndex] = newMidi;
                            
                            // Re-sort inner voices
                            if (voices.Length > 2)
                            {
                                var upperVoicesForSeventh = new List<int>();
                                int lastIndexForSeventh = voices.Length - 1;
                                int endIndexForSeventh = protectSoprano ? lastIndexForSeventh : voices.Length;
                                
                                for (int i = 1; i < endIndexForSeventh; i++)
                                {
                                    upperVoicesForSeventh.Add(voices[i]);
                                }
                                upperVoicesForSeventh.Sort();
                                
                                for (int i = 0; i < upperVoicesForSeventh.Count; i++)
                                {
                                    voices[i + 1] = upperVoicesForSeventh[i];
                                }
                            }
                            
                            // Validate order and spacing
                            bool orderValid = ValidateVoiceOrder(voices, out string orderError);
                            bool spacingValid = true;
                            if (voices.Length >= 4)
                            {
                                spacingValid = !ViolatesHardSpacing(voices[0], voices[1], voices[2], voices[3]);
                            }
                            
                            if (orderValid && spacingValid)
                            {
                                // Success - 7th is now present
                                seventhAdded = true;
                                if (GetTendencyDebug())
                                {
                                    string voiceLabel = (candidateIndex == 1) ? "Tenor" : (candidateIndex == 2) ? "Alto" : $"Voice{candidateIndex}";
                                    UnityEngine.Debug.Log(
                                        $"[Coverage Debug] Added chord 7th by converting {voiceLabel} from {oldMidi} to {newMidi} for {chordEvent.Recipe}");
                                }
                                break;
                            }
                            else
                            {
                                // Revert the change
                                voices[candidateIndex] = oldMidi;
                                
                                // Re-sort again to restore original order
                                if (voices.Length > 2)
                                {
                                    var upperVoicesRevert = new List<int>();
                                    int lastIndexRevert = voices.Length - 1;
                                    int endIndexRevert = protectSoprano ? lastIndexRevert : voices.Length;
                                    
                                    for (int i = 1; i < endIndexRevert; i++)
                                    {
                                        upperVoicesRevert.Add(voices[i]);
                                    }
                                    upperVoicesRevert.Sort();
                                    
                                    for (int i = 0; i < upperVoicesRevert.Count; i++)
                                    {
                                        voices[i + 1] = upperVoicesRevert[i];
                                    }
                                }
                            }
                        }
                    }
                    
                    if (!seventhAdded && GetTendencyDebug())
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[Coverage Debug] Could not add chord 7th for {chordEvent.Recipe} without breaking hard spacing/order.");
                    }
                }
            }
            
            // Debug instrumentation: log state after FixChordToneCoverage and check for non-chord tones
            if (GetTendencyDebug())
            {
                var pcsAfter = new List<int>();
                foreach (int m in voices)
                    pcsAfter.Add((m % 12 + 12) % 12);

                string chordName = $"{chordEvent.Key} {chordEvent.Recipe}";
                UnityEngine.Debug.Log(
                    $"[Coverage Debug] AFTER FixChordToneCoverage for {chordName}: " +
                    $"voices=[{string.Join(",", voices)}], pcs=[{string.Join(",", pcsAfter)}]");

                // Get chord tone pitch classes for validation
                var chordTonePcsForCheck = GetChordTonePitchClasses(chordEvent);
                
                // Check for non-chord tones (excluding bass)
                for (int i = 1; i < voices.Length; i++)
                {
                    int m = voices[i];
                    int pc = (m % 12 + 12) % 12;
                    if (!chordTonePcsForCheck.Contains(pc))
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[Coverage Debug] Non-chord tone detected after coverage fix: midi={m}, pc={pc} " +
                            $"for {chordName}. chordTonePcs=[{string.Join(",", chordTonePcsForCheck)}]");
                    }
                }
            }
        }

        /// <summary>
        /// Hard spacing rules for SATB voicing.
        /// Returns true if the spacing is *invalid* and the candidate should be vetoed.
        /// </summary>
        /// <param name="bass">MIDI note of bass voice</param>
        /// <param name="tenor">MIDI note of tenor voice</param>
        /// <param name="alto">MIDI note of alto voice</param>
        /// <param name="soprano">MIDI note of soprano voice</param>
        /// <returns>True if spacing violates hard rules, false if spacing is acceptable</returns>
        private static bool ViolatesHardSpacing(int bass, int tenor, int alto, int soprano)
        {
            // Soprano–Alto must not exceed an octave
            if (soprano - alto > MaxSopranoAltoInterval)
                return true;
            
            // Alto–Tenor must not exceed an octave
            if (alto - tenor > MaxAltoTenorInterval)
                return true;
            
            // Tenor–Bass may be wider, but > 24 semitones (two octaves) is considered invalid
            if (tenor - bass > MaxTenorBassInterval)
                return true;
            
            return false;
        }
        
        /// <summary>
        /// Checks if voice ordering is violated (Bass <= Tenor <= Alto <= Soprano).
        /// Voice array mapping: [0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano (BTAS order).
        /// Returns true if ordering is violated.
        /// </summary>
        private static bool ViolatesVoiceOrdering(int[] voices)
        {
            if (voices == null || voices.Length < 2)
                return false;
            
            // voices[0] = Bass, [1] = Tenor, [2] = Alto, [3] = Soprano
            // Ordering: Bass <= Tenor <= Alto <= Soprano
            
            // Bass <= Tenor
            if (voices.Length >= 2 && voices[0] > voices[1])
                return true;
            
            // Tenor <= Alto
            if (voices.Length >= 3 && voices[1] > voices[2])
                return true;
            
            // Alto <= Soprano
            if (voices.Length >= 4 && voices[2] > voices[3])
                return true;
            
            return false;
        }
        
        /// <summary>
        /// Corrects voice ordering violations by octave-shifting voices deterministically.
        /// Voice array mapping: [0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano (BTAS order).
        /// Does not reorder voices, only shifts by octaves to fix crossing.
        /// Returns true if correction was applied.
        /// </summary>
        private static bool CorrectVoiceOrdering(int[] voices, int upperMinMidi, int upperMaxMidi)
        {
            if (voices == null || voices.Length < 2)
                return false;
            
            bool corrected = false;
            
            // voices[0] = Bass, [1] = Tenor, [2] = Alto, [3] = Soprano
            // Ordering: voices[0] <= voices[1] <= voices[2] <= voices[3]
            
            // Fix Bass > Tenor: shift Tenor up an octave if within range
            if (voices.Length >= 2 && voices[0] > voices[1])
            {
                int newTenor = voices[1] + 12;
                if (newTenor <= upperMaxMidi && newTenor >= upperMinMidi)
                {
                    voices[1] = newTenor;
                    corrected = true;
                }
            }
            
            // Fix Tenor > Alto: prefer shifting Alto up, but if that would violate Soprano, shift Tenor down
            if (voices.Length >= 3 && voices[1] > voices[2])
            {
                int newAlto = voices[2] + 12;
                bool altoShiftUpValid = newAlto <= upperMaxMidi && 
                                       newAlto >= upperMinMidi &&
                                       (voices.Length < 4 || newAlto <= voices[3]);
                
                if (altoShiftUpValid)
                {
                    voices[2] = newAlto;
                    corrected = true;
                }
                else
                {
                    // Try shifting Tenor down
                    int newTenor = voices[1] - 12;
                    if (newTenor >= upperMinMidi && newTenor >= voices[0])
                    {
                        voices[1] = newTenor;
                        corrected = true;
                    }
                }
            }
            
            // Fix Alto > Soprano: shift Soprano up an octave if within range
            if (voices.Length >= 4 && voices[2] > voices[3])
            {
                int newSoprano = voices[3] + 12;
                if (newSoprano <= upperMaxMidi && newSoprano >= upperMinMidi)
                {
                    voices[3] = newSoprano;
                    corrected = true;
                }
            }
            
            return corrected;
        }
        
        /// <summary>
        /// Checks and logs BTAS ordering invariant (B ≤ T ≤ A ≤ S).
        /// Voice array mapping: [0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano (BTAS order).
        /// Returns true if ordering is valid, false if violated.
        /// </summary>
        /// <param name="voices">Voice MIDI array in BTAS order</param>
        /// <param name="stepIndex">Step index for logging</param>
        /// <param name="chordLabel">Chord label for logging</param>
        /// <returns>True if ordering is valid, false if violated</returns>
        private static bool CheckAndLogBTASInvariant(int[] voices, int stepIndex, string chordLabel)
        {
            if (voices == null || voices.Length < 2)
                return true; // Not enough voices to check
            
            int b = voices.Length > 0 ? voices[0] : -1;
            int t = voices.Length > 1 ? voices[1] : -1;
            int a = voices.Length > 2 ? voices[2] : -1;
            int s = voices.Length > 3 ? voices[3] : -1;
            
            bool valid = true;
            string violations = "";
            
            if (voices.Length >= 2 && b > t)
            {
                valid = false;
                violations += $"B({b})>T({t}) ";
            }
            if (voices.Length >= 3 && t > a)
            {
                valid = false;
                violations += $"T({t})>A({a}) ";
            }
            if (voices.Length >= 4 && a > s)
            {
                valid = false;
                violations += $"A({a})>S({s}) ";
            }
            
            if (!valid)
            {
                UnityEngine.Debug.LogError(
                    $"[BTAS_VIOLATION] step={stepIndex} chord={chordLabel} B={b} T={t} A={a} S={s} violations=[{violations.Trim()}]");
            }
            
            return valid;
        }
        
        /// <summary>
        /// Enforces strict SATB ordering (Bass ≤ Tenor ≤ Alto ≤ Soprano) via octave-only correction.
        /// Voice array mapping: [0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano (BTAS order).
        /// Does not reorder voices or change pitch classes — only octave-shifts voices when ordering is violated.
        /// Strategy: Prefer lowering upper voices before raising lower voices to avoid "octave pumping".
        /// This is a hard invariant that must never be violated after any voicing pass.
        /// </summary>
        /// <param name="voices">Voice MIDI array in BTAS order (modified in-place)</param>
        private static void EnforceVoiceOrderingBTAS(int[] voices)
        {
            EnforceVoiceOrderingBTAS(voices, null, null, null, false);
        }
        
        /// <summary>
        /// Enforces strict SATB ordering with optional range and spacing constraints.
        /// When ranges are provided, prefers lowering inner voices to preserve continuity adjustments.
        /// CRITICAL: Protects required chord tones - will not modify a voice if it's the only voice carrying a required PC.
        /// </summary>
        /// <param name="voices">Voice MIDI array in BTAS order (modified in-place)</param>
        /// <param name="minMidiByVoice">Optional minimum MIDI for each voice [Bass, Tenor, Alto, Soprano], or null</param>
        /// <param name="maxMidiByVoice">Optional maximum MIDI for each voice [Bass, Tenor, Alto, Soprano], or null</param>
        /// <param name="requiredPcs">Optional set of required chord tone pitch classes to protect</param>
        /// <param name="strictMode">If true, does not accept ordering violations - must repair or fail</param>
        private static void EnforceVoiceOrderingBTAS(int[] voices, int[] minMidiByVoice, int[] maxMidiByVoice, HashSet<int> requiredPcs = null, bool strictMode = false)
        {
            if (voices == null || voices.Length < 2)
                return;
            
            // CRITICAL: Capture pre-ordering state for safeguard
            int[] preOrderVoices = (int[])voices.Clone();
            
            // voices[0] = Bass, [1] = Tenor, [2] = Alto, [3] = Soprano
            // Ordering: voices[0] <= voices[1] <= voices[2] <= voices[3]
            
            // Helper to check if a voice shift would violate spacing
            bool WouldViolateSpacing(int[] testVoices)
            {
                if (testVoices.Length < 4) return false;
                return ViolatesHardSpacing(testVoices[0], testVoices[1], testVoices[2], testVoices[3]);
            }
            
            // Helper to check if a voice is within its allowed range
            bool IsWithinRange(int voiceIndex, int midi)
            {
                if (minMidiByVoice == null || maxMidiByVoice == null) return true; // No range constraints
                if (voiceIndex < 0 || voiceIndex >= minMidiByVoice.Length || voiceIndex >= maxMidiByVoice.Length) return true;
                return midi >= minMidiByVoice[voiceIndex] && midi <= maxMidiByVoice[voiceIndex];
            }

            // CRITICAL: Helper to check if we can modify a voice (protects OLD PC being removed, not new PC)
            // If the voice currently carries a required tone and it's the ONLY voice with that PC, we cannot modify it
            bool CanModifyVoiceForOrdering(int voiceIdx, int oldMidi)
            {
                if (requiredPcs == null) return true; // No required tones to protect
                int oldPc = (oldMidi % 12 + 12) % 12;
                if (!requiredPcs.Contains(oldPc)) return true; // Not a required tone, can modify
                
                // Check if another voice currently has this required PC
                for (int otherIdx = 0; otherIdx < voices.Length; otherIdx++)
                {
                    if (otherIdx != voiceIdx)
                    {
                        int otherPc = (voices[otherIdx] % 12 + 12) % 12;
                        if (otherPc == oldPc) return true; // Another voice has it, can modify
                    }
                }
                return false; // Unique required tone, cannot modify (would remove it)
            }

            // Helper to check if swapping two voices would fix ordering without changing PCs
            bool CanSwapVoices(int idx1, int idx2)
            {
                if (idx1 < 0 || idx1 >= voices.Length || idx2 < 0 || idx2 >= voices.Length) return false;
                if (idx1 == idx2) return false;
                
                // Check if swap would fix ordering
                int temp = voices[idx1];
                voices[idx1] = voices[idx2];
                voices[idx2] = temp;
                
                bool wouldFix = true;
                if (voices.Length >= 2 && voices[0] > voices[1]) wouldFix = false;
                if (voices.Length >= 3 && voices[1] > voices[2]) wouldFix = false;
                if (voices.Length >= 4 && voices[2] > voices[3]) wouldFix = false;
                
                // Restore
                temp = voices[idx1];
                voices[idx1] = voices[idx2];
                voices[idx2] = temp;
                
                return wouldFix;
            }
            
            // PHASE 1: Try voice swaps first (PC-conservative - no pitch changes)
            // CRITICAL: DISABLED for SATB identity mode - lane swaps break voice identity invariants
            // The solver should never produce crossings in the first place (hard veto during candidate selection)
            // If a crossing exists, it's a bug in candidate generation, not something to "fix" by swapping lanes
            bool triedSwaps = false;
            // DISABLED: Voice swaps break SATB lane identity
            // if (voices.Length >= 2 && voices[0] > voices[1]) { ... }
            // if (!triedSwaps && voices.Length >= 3 && voices[1] > voices[2]) { ... }
            // if (!triedSwaps && voices.Length >= 4 && voices[2] > voices[3]) { ... }
            
            // If swaps fixed everything, skip octave shifts
            if (!ViolatesVoiceOrdering(voices))
            {
                // Swaps fixed ordering - verify required PCs are still present
                if (requiredPcs != null && requiredPcs.Count > 0)
                {
                    var realizedPcsAfterSwap = new HashSet<int>();
                    for (int i = 0; i < voices.Length; i++)
                    {
                        int pc = (voices[i] % 12 + 12) % 12;
                        realizedPcsAfterSwap.Add(pc);
                    }

                    bool allRequiredPresent = true;
                    foreach (int requiredPc in requiredPcs)
                    {
                        if (!realizedPcsAfterSwap.Contains(requiredPc))
                        {
                            allRequiredPresent = false;
                            break;
                        }
                    }

                    if (allRequiredPresent)
                    {
                        // Swaps fixed ordering and preserved required tones - done!
                        return;
                    }
                    else
                    {
                        // Swaps broke required tones - revert and continue to octave shifts
                        for (int i = 0; i < voices.Length && i < preOrderVoices.Length; i++)
                        {
                            voices[i] = preOrderVoices[i];
                        }
                    }
                }
                else
                {
                    // No required tones to check - swaps fixed ordering - done!
                    return;
                }
            }
            
            // Iterate up to 4 times to fix all violations (bounded to prevent infinite loops)
            const int maxIterations = 4;
            bool corrected = false;
            
            for (int iteration = 0; iteration < maxIterations; iteration++)
            {
                bool anyChange = false;
                
                // Fix Bass > Tenor: prefer lowering Tenor, but if that would go below 0, raise Tenor
                if (voices.Length >= 2 && voices[0] > voices[1])
                {
                    int oldTenorMidi = voices[1];
                    int oldBassMidi = voices[0];
                    int newTenorDown = voices[1] - 12;
                    if (newTenorDown >= 0 && newTenorDown >= voices[0] && IsWithinRange(1, newTenorDown))
                    {
                        int[] testVoices = (int[])voices.Clone();
                        testVoices[1] = newTenorDown;
                        if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(1, oldTenorMidi))
                        {
                            voices[1] = newTenorDown;
                            anyChange = true;
                        }
                    }
                    if (!anyChange)
                    {
                        // Can't lower Tenor: raise Tenor
                        int newTenorUp = voices[1] + 12;
                        if (IsWithinRange(1, newTenorUp))
                        {
                            int[] testVoices = (int[])voices.Clone();
                            testVoices[1] = newTenorUp;
                            if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(1, oldTenorMidi))
                            {
                                voices[1] = newTenorUp;
                                anyChange = true;
                            }
                        }
                    }
                    if (!anyChange)
                    {
                        // Try lowering Bass as last resort
                        int newBassDown = voices[0] - 12;
                        // Add hard minimum check (B1 = MIDI 35) in addition to IsWithinRange check
                        const int absoluteBassMinMidi = 35; // B1 - hard minimum for bass voice
                        if (newBassDown >= absoluteBassMinMidi && IsWithinRange(0, newBassDown))
                        {
                            int[] testVoices = (int[])voices.Clone();
                            testVoices[0] = newBassDown;
                            if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(0, oldBassMidi))
                            {
                                voices[0] = newBassDown;
                                anyChange = true;
                            }
                        }
                    }
                }
                
                // Fix Tenor > Alto: prefer lowering Alto, but if that would violate Bass/Tenor, try lowering Tenor or raising Alto
                if (voices.Length >= 3 && voices[1] > voices[2])
                {
                    int oldAltoMidi = voices[2];
                    int oldTenorMidi = voices[1];
                    int newAltoDown = voices[2] - 12;
                    bool altoDownValid = newAltoDown >= voices[1] && newAltoDown >= 0 && IsWithinRange(2, newAltoDown);
                    
                    if (altoDownValid)
                    {
                        int[] testVoices = (int[])voices.Clone();
                        testVoices[2] = newAltoDown;
                        if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(2, oldAltoMidi))
                        {
                            voices[2] = newAltoDown;
                            anyChange = true;
                        }
                    }
                    
                    if (!anyChange)
                    {
                        // Try lowering Tenor
                        int newTenorDown = voices[1] - 12;
                        bool tenorDownValid = newTenorDown >= voices[0] && newTenorDown >= 0 && IsWithinRange(1, newTenorDown);
                        
                        if (tenorDownValid)
                        {
                            int[] testVoices = (int[])voices.Clone();
                            testVoices[1] = newTenorDown;
                            if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(1, oldTenorMidi))
                            {
                                voices[1] = newTenorDown;
                                anyChange = true;
                            }
                        }
                    }
                    
                    if (!anyChange)
                    {
                        // Last resort: raise Alto
                        int newAltoUp = voices[2] + 12;
                        if (IsWithinRange(2, newAltoUp))
                        {
                            int[] testVoices = (int[])voices.Clone();
                            testVoices[2] = newAltoUp;
                            if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(2, oldAltoMidi))
                            {
                                voices[2] = newAltoUp;
                                anyChange = true;
                            }
                        }
                    }
                }
                
                // Fix Alto > Soprano: prefer lowering Alto, then Tenor, before raising Soprano
                // CRITICAL: This is where continuity adjustments get undone - we must prefer lowering inner voices
                if (voices.Length >= 4 && voices[2] > voices[3])
                {
                    // First attempt: Lower Alto by 12
                    int newAltoDown = voices[2] - 12;
                    bool altoDownValid = newAltoDown >= voices[1] && newAltoDown >= 0 && IsWithinRange(2, newAltoDown);
                    
                    int oldAltoMidi = voices[2];
                    int oldTenorMidi = voices[1];
                    int oldSopranoMidi = voices[3];
                    
                    if (altoDownValid)
                    {
                        int[] testVoices = (int[])voices.Clone();
                        testVoices[2] = newAltoDown;
                        if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(2, oldAltoMidi))
                        {
                            voices[2] = newAltoDown;
                            anyChange = true;
                        }
                    }
                    
                    // Second attempt: Lower Tenor (which may allow Alto to be lowered)
                    if (!anyChange)
                    {
                        int newTenorDown = voices[1] - 12;
                        bool tenorDownValid = newTenorDown >= voices[0] && newTenorDown >= 0 && IsWithinRange(1, newTenorDown);
                        
                        if (tenorDownValid)
                        {
                            int[] testVoices = (int[])voices.Clone();
                            testVoices[1] = newTenorDown;
                            if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(1, oldTenorMidi))
                            {
                                voices[1] = newTenorDown;
                                // Re-check Alto after Tenor shift
                                if (voices[2] > voices[3])
                                {
                                    int newAltoAfterTenor = voices[2] - 12;
                                    if (newAltoAfterTenor >= voices[1] && newAltoAfterTenor >= 0 && IsWithinRange(2, newAltoAfterTenor))
                                    {
                                        testVoices[2] = newAltoAfterTenor;
                                        if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(2, oldAltoMidi))
                                        {
                                            voices[2] = newAltoAfterTenor;
                                        }
                                        else
                                        {
                                            // Spacing would be violated or required tone protected, try raising Soprano
                                            testVoices[2] = voices[2]; // Restore Alto
                                            testVoices[3] = voices[3] + 12;
                                            if (IsWithinRange(3, testVoices[3]) && !WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(3, oldSopranoMidi))
                                            {
                                                voices[3] = testVoices[3];
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // Can't lower Alto after Tenor shift, try raising Soprano
                                        testVoices[2] = voices[2]; // Restore Alto
                                        testVoices[3] = voices[3] + 12;
                                        if (IsWithinRange(3, testVoices[3]) && !WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(3, oldSopranoMidi))
                                        {
                                            voices[3] = testVoices[3];
                                        }
                                    }
                                }
                                anyChange = true;
                            }
                        }
                    }
                    
                    // Last resort: raise Soprano (only if lowering inner voices failed)
                    // CRITICAL: We MUST fix A > S violations - if lowering failed, raise Soprano even if it's not ideal
                    // BUT: Only if it doesn't remove a unique required tone
                    if (!anyChange)
                    {
                        int newSopranoUp = voices[3] + 12;
                        // Even if not within range, we must fix the violation - try anyway
                        int[] testVoices = (int[])voices.Clone();
                        testVoices[3] = newSopranoUp;
                        if (!WouldViolateSpacing(testVoices) && CanModifyVoiceForOrdering(3, oldSopranoMidi))
                        {
                            voices[3] = newSopranoUp;
                            anyChange = true;
                            // Log when Soprano is raised (should be rare after continuity adjustments)
                            if (s_debugSharp9OctaveTrace)
                            {
                                UnityEngine.Debug.LogWarning(
                                    $"[SHARP9_TRACE][ORDERING] Alto > Soprano violation: raised Soprano {oldSopranoMidi}→{newSopranoUp} " +
                                    $"(lowering Alto/Tenor failed - range or spacing constraint)");
                            }
                        }
                        else
                        {
                            // Cannot fix ordering without removing required tone or violating spacing
                            // Accept minor ordering violation to preserve identity tones
                            // Log warning (gated by regression flag if available)
                            if (Sonoria.MusicTheory.RegressionHarness.EnableRegressionHarness)
                            {
                                UnityEngine.Debug.LogWarning(
                                    $"[ORDERING_VIOLATION_ACCEPTED] Cannot fix Alto > Soprano without removing required tone. " +
                                    $"Accepting minor ordering violation to preserve identity tones. " +
                                    $"B={voices[0]} T={voices[1]} A={voices[2]} S={voices[3]}");
                            }
                        }
                    }
                    else
                    {
                        // Log when we successfully lowered inner voices instead of raising Soprano
                        if (s_debugSharp9OctaveTrace && voices.Length >= 4)
                        {
                            UnityEngine.Debug.Log(
                                $"[SHARP9_TRACE][ORDERING] Alto > Soprano violation: lowered inner voice(s) " +
                                $"(B={voices[0]} T={voices[1]} A={voices[2]} S={voices[3]}) - preserved continuity");
                        }
                    }
                }
                
                if (!anyChange)
                {
                    // No more violations to fix
                    break;
                }
                
                corrected = true;
                
                // Check if ordering is now valid
                if (!ViolatesVoiceOrdering(voices))
                {
                    break; // All violations fixed
                }
            }
            
            // CRITICAL SAFEGUARD: After all ordering attempts, verify required PCs are still present
            // If any are missing, revert to pre-ordering state and log warning
            if (requiredPcs != null && requiredPcs.Count > 0)
            {
                var realizedPcsAfterOrdering = new HashSet<int>();
                for (int i = 0; i < voices.Length; i++)
                {
                    int pc = (voices[i] % 12 + 12) % 12;
                    realizedPcsAfterOrdering.Add(pc);
                }

                var missingRequiredPcs = new List<int>();
                foreach (int requiredPc in requiredPcs)
                {
                    if (!realizedPcsAfterOrdering.Contains(requiredPc))
                    {
                        missingRequiredPcs.Add(requiredPc);
                    }
                }

                if (missingRequiredPcs.Count > 0)
                {
                    // REVERT: Required tones were lost - restore pre-ordering state
                    for (int i = 0; i < voices.Length && i < preOrderVoices.Length; i++)
                    {
                        voices[i] = preOrderVoices[i];
                    }
                    
                    // Log warning (gated by regression flag)
                    if (Sonoria.MusicTheory.RegressionHarness.EnableRegressionHarness)
                    {
                        string missingPcsStr = string.Join(", ", missingRequiredPcs);
                        string voicesStr = $"B={voices[0]}, T={voices[1]}, A={voices[2]}, S={voices[3]}";
                        string realizedPcsStr = string.Join(", ", realizedPcsAfterOrdering.OrderBy(pc => pc));
                        
                        UnityEngine.Debug.LogWarning(
                            $"[ORDERING_VIOLATION_ACCEPTED] Required chord tone(s) would be lost by ordering fix. " +
                            $"Reverted to pre-ordering state to preserve identity tones. " +
                            $"Missing required PCs: [{missingPcsStr}]. " +
                            $"Required PCs: [{string.Join(", ", requiredPcs.OrderBy(pc => pc))}]. " +
                            $"Realized PCs after ordering attempt: [{realizedPcsStr}]. " +
                            $"Final voices (with minor ordering violation): {voicesStr}");
                    }
                }
            }
            
            // CRITICAL: Final check - if ordering is still violated
            // In strict mode: must repair or fail (no accepting violations)
            // In non-strict mode: accept it to preserve required tones
            if (ViolatesVoiceOrdering(voices))
            {
                if (strictMode)
                {
                    // STRICT MODE: Attempt pitch adjustment repair (preserves lanes, adjusts pitch)
                    // This is for SATB-with-melody where lane identity must be preserved
                    // Note: chordEvent and chordIndex not available here - repair should be called from VoiceNextChord instead
                    // For now, log error if violation persists
                    UnityEngine.Debug.LogError(
                        $"[ORDERING_STRICT_FAIL] Voice ordering violation in strict mode. " +
                        $"Repair should be called from VoiceNextChord with chordEvent context. " +
                        $"B={voices[0]} T={voices[1]} A={voices[2]} S={voices[3]}");
                }
                else
                {
                    // Non-strict mode: accept violation to preserve required tones
                    if (Sonoria.MusicTheory.RegressionHarness.EnableRegressionHarness)
                    {
                        UnityEngine.Debug.LogWarning(
                            $"[ORDERING_VIOLATION_ACCEPTED] Voice ordering still violated after all attempts, " +
                            $"but required tones preserved. Accepting minor ordering violation. " +
                            $"B={voices[0]} T={voices[1]} A={voices[2]} S={voices[3]}");
                    }
                }
            }
            
            // Debug assert: verify ordering (may be violated if required tones are preserved)
            #if UNITY_EDITOR
            if (ViolatesVoiceOrdering(voices))
            {
                // This is acceptable if required tones are preserved (identity tones > ordering)
                if (requiredPcs != null && requiredPcs.Count > 0)
                {
                    // Check if all required PCs are present
                    var realizedPcs = new HashSet<int>();
                    for (int i = 0; i < voices.Length; i++)
                    {
                        int pc = (voices[i] % 12 + 12) % 12;
                        realizedPcs.Add(pc);
                    }
                    bool allRequiredPresent = true;
                    foreach (int requiredPc in requiredPcs)
                    {
                        if (!realizedPcs.Contains(requiredPc))
                        {
                            allRequiredPresent = false;
                            break;
                        }
                    }
                    
                    if (allRequiredPresent)
                    {
                        // Ordering violation is acceptable - required tones preserved
                        UnityEngine.Debug.LogWarning(
                            $"[VOICE_ORDERING_ASSERT] Voice ordering violation persists, but required tones preserved (acceptable).\n" +
                            $"  Voices (BTAS): [{string.Join(", ", voices)}]\n" +
                            $"  Bass={voices[0]}, Tenor={voices[1]}, Alto={voices[2]}, Soprano={voices[3]}\n" +
                            $"  Violations: B>T={voices[0] > voices[1]}, T>A={voices[1] > voices[2]}, A>S={voices[2] > voices[3]}");
                    }
                    else
                    {
                        // This should not happen - required tones should be preserved
                        UnityEngine.Debug.LogError(
                            $"[VOICE_ORDERING_ASSERT] CRITICAL: Voice ordering violation AND required tones missing!\n" +
                            $"  Voices (BTAS): [{string.Join(", ", voices)}]\n" +
                            $"  Bass={voices[0]}, Tenor={voices[1]}, Alto={voices[2]}, Soprano={voices[3]}\n" +
                            $"  Violations: B>T={voices[0] > voices[1]}, T>A={voices[1] > voices[2]}, A>S={voices[2] > voices[3]}");
                    }
                }
                else
                {
                    // No required tones - ordering violation should not persist
                    UnityEngine.Debug.LogError(
                        $"[VOICE_ORDERING_ASSERT] CRITICAL: Voice ordering violation persists after EnforceVoiceOrderingBTAS (no required tones)!\n" +
                        $"  Voices (BTAS): [{string.Join(", ", voices)}]\n" +
                        $"  Bass={voices[0]}, Tenor={voices[1]}, Alto={voices[2]}, Soprano={voices[3]}\n" +
                        $"  Violations: B>T={voices[0] > voices[1]}, T>A={voices[1] > voices[2]}, A>S={voices[2] > voices[3]}");
                }
            }
            #endif
            
            if (corrected)
            {
                UnityEngine.Debug.Log(
                    $"[VOICE_ORDERING] Applied octave correction to enforce BTAS ordering: " +
                    $"[{string.Join(", ", voices)}]");
            }
        }
        
        /// <summary>
        /// Computes spacing penalty for a complete SATB voicing.
        /// Returns a penalty value (higher = worse spacing).
        /// No mutation, no sorting — just a number.
        /// </summary>
        private static float GetSpacingPenalty(int bass, int tenor, int alto, int soprano)
        {
            float penalty = 0f;

            int sa = soprano - alto;
            int at = alto - tenor;
            int tb = tenor - bass;

            // Hard-ish caps: >12 between S-A or A-T is strongly discouraged.
            if (sa > 12) penalty += SpacingLargePenalty;
            if (at > 12) penalty += SpacingLargePenalty;

            // Very wide tenor-bass gets a large penalty too.
            if (tb > 24) penalty += SpacingLargePenalty;

            // Preferred range: we *prefer* ≤7 between S-A and A-T.
            if (sa > 7) penalty += spacingPreferredPenalty;
            if (at > 7) penalty += spacingPreferredPenalty;

            // Prefer tenor not drifting more than an octave above bass.
            if (tb > 12) penalty += spacingBassTenorPenalty;

            return penalty;
        }

        /// <summary>
        /// Validates that voices are in correct SATB order: Bass ≤ Tenor ≤ Alto ≤ Soprano.
        /// Returns true if valid, false if crossing detected.
        /// </summary>
        /// <param name="midi">Array of MIDI notes for voices [Bass, Tenor, Alto, Soprano]</param>
        /// <param name="error">Output error message if crossing detected</param>
        /// <returns>True if voices are in correct order, false if crossing detected</returns>
        private static bool ValidateVoiceOrder(int[] midi, out string error)
        {
            error = null;
            if (midi == null || midi.Length < 4) return true;
            
            for (int i = 0; i < 3; i++)
            {
                if (midi[i] > midi[i + 1])
                {
                    string v1 = (i == 0) ? "Bass" : (i == 1) ? "Tenor" : "Alto";
                    string v2 = (i + 1 == 1) ? "Tenor" : (i + 1 == 2) ? "Alto" : "Soprano";
                    error = $"{v1} ({midi[i]}) > {v2} ({midi[i + 1]})";
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Checks if a candidate upper voice would cause voice crossing with already-selected voices.
        /// Returns true if crossing would occur, false if safe.
        /// </summary>
        /// <param name="candidateMidi">MIDI note of the candidate upper voice</param>
        /// <param name="bassMidi">MIDI note of the bass voice</param>
        /// <param name="selectedUpperVoices">List of already-selected upper voices (in ascending order)</param>
        /// <param name="error">Output error message if crossing detected</param>
        /// <returns>True if crossing would occur, false if safe</returns>
        private static bool WouldCauseVoiceCrossing(int candidateMidi, int bassMidi, List<int> selectedUpperVoices, out string error)
        {
            error = null;
            
            // Check: candidate must be > bass (Bass ≤ Tenor)
            if (candidateMidi <= bassMidi)
            {
                error = $"Bass ({bassMidi}) >= candidate ({candidateMidi})";
                return true;
            }
            
            // Check: candidate must be >= all previously selected upper voices (allow unison for inner voices)
            // CRITICAL: Allow Alto == Tenor (unison doubling) for SATB identity mode
            // This is needed for correct solutions like F chord: Tenor=A3, Alto=A3
            for (int i = 0; i < selectedUpperVoices.Count; i++)
            {
                // Allow equality (unison) for inner voices (Tenor/Alto), but not for outer voices
                bool allowUnison = (i == 0); // Allow unison with Tenor when selecting Alto
                if (allowUnison)
                {
                    // Alto can equal Tenor (unison), but must not be below
                    if (candidateMidi < selectedUpperVoices[i])
                    {
                        string voiceName = (i == 0) ? "Tenor" : (i == 1) ? "Alto" : $"Voice{i+1}";
                        error = $"{voiceName} ({selectedUpperVoices[i]}) > candidate ({candidateMidi})";
                        return true;
                    }
                }
                else
                {
                    // Soprano must be strictly above Alto
                    if (candidateMidi <= selectedUpperVoices[i])
                    {
                        string voiceName = (i == 0) ? "Tenor" : (i == 1) ? "Alto" : $"Voice{i+1}";
                        error = $"{voiceName} ({selectedUpperVoices[i]}) >= candidate ({candidateMidi})";
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        /// <summary>
        /// Repairs voice ordering violations by adjusting pitch (not swapping lanes).
        /// For common case Alto < Tenor: moves Alto to nearest candidate >= Tenor (allows unison).
        /// Preserves lane identity and required chord tones.
        /// </summary>
        /// <param name="voices">Voice MIDI array in BTAS order (modified in-place)</param>
        /// <param name="minMidiByVoice">Optional minimum MIDI for each voice, or null</param>
        /// <param name="maxMidiByVoice">Optional maximum MIDI for each voice, or null</param>
        /// <param name="requiredPcs">Optional set of required chord tone pitch classes to preserve</param>
        /// <param name="chordEvent">Chord event for getting chord tone PCs and key</param>
        /// <param name="chordIndex">Chord index for logging</param>
        /// <returns>True if repair was successful, false otherwise</returns>
        private static bool RepairOrderingByPitchAdjustment(int[] voices, int[] minMidiByVoice, int[] maxMidiByVoice, HashSet<int> requiredPcs, ChordEvent chordEvent, int chordIndex)
        {
            if (voices == null || voices.Length < 4)
                return false;
            
            bool repaired = false;
            
            // Log ordering before repair (for chord IV only)
            bool shouldLog = (chordIndex == 2);
            if (shouldLog)
            {
                string bassName = TheoryPitch.GetPitchNameFromMidi(voices[0], chordEvent.Key);
                string tenorName = TheoryPitch.GetPitchNameFromMidi(voices[1], chordEvent.Key);
                string altoName = TheoryPitch.GetPitchNameFromMidi(voices[2], chordEvent.Key);
                string sopranoName = TheoryPitch.GetPitchNameFromMidi(voices[3], chordEvent.Key);
                UnityEngine.Debug.Log(
                    $"[ORDERING_REPAIR] Before repair chordIndex={chordIndex}: " +
                    $"B={voices[0]}({bassName}) T={voices[1]}({tenorName}) A={voices[2]}({altoName}) S={voices[3]}({sopranoName})");
            }
            
            // Common case: Alto < Tenor (Alto=53 F3, Tenor=57 A3)
            if (voices.Length >= 3 && voices[2] < voices[1])
            {
                int currentAlto = voices[2];
                int currentTenor = voices[1];
                int currentAltoPc = (currentAlto % 12 + 12) % 12;
                
                // Get chord tone pitch classes for current chord
                var chordTonePcs = GetChordTonePitchClasses(chordEvent);
                var candidatePcs = chordTonePcs != null && chordTonePcs.Count > 0 
                    ? chordTonePcs.ToList() 
                    : (requiredPcs != null && requiredPcs.Count > 0 ? requiredPcs.ToList() : Enumerable.Range(0, 12).ToList());
                
                int altoMin = minMidiByVoice != null && minMidiByVoice.Length > 2 ? minMidiByVoice[2] : 48;
                int altoMax = maxMidiByVoice != null && maxMidiByVoice.Length > 2 ? maxMidiByVoice[2] : 88;
                
                // Find nearest candidate >= Tenor that preserves required tones
                int bestAlto = -1;
                int bestDistance = int.MaxValue;
                
                foreach (int pc in candidatePcs)
                {
                    // Generate candidate MIDIs for this pitch class >= Tenor
                    int baseOctave = currentTenor / 12;
                    for (int octaveOffset = 0; octaveOffset <= 2; octaveOffset++) // Try current octave and up to 2 octaves above
                    {
                        int candidateMidi = (baseOctave + octaveOffset) * 12 + pc;
                        
                        // Must be >= Tenor (allow unison)
                        if (candidateMidi < currentTenor)
                            continue;
                        
                        // Must be within range
                        if (candidateMidi < altoMin || candidateMidi > altoMax)
                            continue;
                        
                        // Must be <= Soprano
                        if (voices.Length >= 4 && candidateMidi > voices[3])
                            continue;
                        
                        // Check if this preserves required tones (if Alto currently has a required PC, we need to ensure it's still present)
                        if (requiredPcs != null && requiredPcs.Contains(currentAltoPc))
                        {
                            // Check if another voice has this PC
                            bool otherVoiceHasPc = false;
                            for (int v = 0; v < voices.Length; v++)
                            {
                                if (v != 2) // Not Alto
                                {
                                    int vPc = (voices[v] % 12 + 12) % 12;
                                    if (vPc == currentAltoPc)
                                    {
                                        otherVoiceHasPc = true;
                                        break;
                                    }
                                }
                            }
                            if (!otherVoiceHasPc && pc != currentAltoPc)
                                continue; // Would lose required PC
                        }
                        
                        // Prefer minimal movement
                        int distance = Math.Abs(candidateMidi - currentAlto);
                        if (distance < bestDistance)
                        {
                            bestAlto = candidateMidi;
                            bestDistance = distance;
                        }
                    }
                }
                
                if (bestAlto >= 0)
                {
                    int oldAlto = voices[2];
                    voices[2] = bestAlto;
                    repaired = true;
                    
                    if (shouldLog)
                    {
                        string oldAltoName = TheoryPitch.GetPitchNameFromMidi(oldAlto, chordEvent.Key);
                        string newAltoName = TheoryPitch.GetPitchNameFromMidi(bestAlto, chordEvent.Key);
                        UnityEngine.Debug.Log(
                            $"[ORDERING_REPAIR] Repaired Alto < Tenor: Alto {oldAlto}({oldAltoName}) -> {bestAlto}({newAltoName}) " +
                            $"(Tenor={voices[1]}, distance={bestDistance})");
                    }
                }
            }
            
            // Log ordering after repair
            if (shouldLog)
            {
                string bassName = TheoryPitch.GetPitchNameFromMidi(voices[0], chordEvent.Key);
                string tenorName = TheoryPitch.GetPitchNameFromMidi(voices[1], chordEvent.Key);
                string altoName = TheoryPitch.GetPitchNameFromMidi(voices[2], chordEvent.Key);
                string sopranoName = TheoryPitch.GetPitchNameFromMidi(voices[3], chordEvent.Key);
                bool stillViolated = ViolatesVoiceOrdering(voices);
                UnityEngine.Debug.Log(
                    $"[ORDERING_REPAIR] After repair chordIndex={chordIndex}: " +
                    $"B={voices[0]}({bassName}) T={voices[1]}({tenorName}) A={voices[2]}({altoName}) S={voices[3]}({sopranoName}) " +
                    $"violated={stillViolated}");
            }
            
            return repaired && !ViolatesVoiceOrdering(voices);
        }

        /// <summary>
        /// Helper method to place a pitch class in the mid register (around MIDI 60/C4)
        /// while ensuring it fits within the specified range.
        /// </summary>
        /// <param name="pitchClass">Pitch class (0-11)</param>
        /// <param name="minMidi">Minimum allowed MIDI note</param>
        /// <param name="maxMidi">Maximum allowed MIDI note</param>
        /// <returns>MIDI note number in the appropriate octave</returns>
        private static int PlaceInMidRegister(int pitchClass, int minMidi, int maxMidi)
        {
            // Start with octave 4 (MIDI 60 = C4)
            int octave = 4;
            int midi = (octave + 1) * 12 + pitchClass;

            // Adjust octave if needed to fit in range
            while (midi < minMidi)
            {
                midi += 12;
            }
            while (midi > maxMidi)
            {
                midi -= 12;
            }

            // Final clamp to ensure we're in range (shouldn't be needed, but be safe)
            if (midi < minMidi)
            {
                midi = minMidi;
            }
            if (midi > maxMidi)
            {
                midi = maxMidi;
            }

            return midi;
        }

        // ============================================================================
        // TONAL TENDENCY RULES (Soft Preferences for Voice-Leading)
        // ============================================================================
        // These rules add gentle biases toward classical voice-leading patterns:
        // 1. Chord 7ths prefer to resolve down by step
        // 2. Global leading tone (degree 7) prefers to resolve up to tonic (softly)
        // 3. Local leading tone (3rd of secondary dominants) prefers to resolve up to target root
        // These are SOFT preferences that bias but don't override existing logic.
        // ============================================================================

        /// <summary>
        /// Information about a voice's tendency characteristics for applying soft voice-leading rules.
        /// </summary>
        private struct VoiceTendencyInfo
        {
            public int midiNote;
            public bool isChordSeventh;
            public bool isChordThird;
            public bool isAugmentedFifth;   // True if this note is the augmented 5th (#5) of the chord
            public bool isGlobalLeadingTone;
            public bool isLocalLeadingTone; // e.g., 3rd of secondary dominant
            public int scaleDegree;         // 1-7 in current key, or 0 if unknown/non-diatonic
            public int localTargetRootPc;   // Pitch class of the target root for local leading tone (-1 if not applicable)
        }

        /// <summary>
        /// Analyzes voice tendencies for a given MIDI note in the context of a chord and key.
        /// </summary>
        private static VoiceTendencyInfo AnalyzeVoiceTendencies(
            int midiNote,
            TheoryKey key,
            ChordRecipe chord,
            ChordFunctionProfile analysis)
        {
            var info = new VoiceTendencyInfo
            {
                midiNote = midiNote,
                isChordSeventh = false,
                isChordThird = false,
                isAugmentedFifth = false,
                isGlobalLeadingTone = false,
                isLocalLeadingTone = false,
                scaleDegree = 0,
                localTargetRootPc = -1
            };

            int notePc = (midiNote % 12 + 12) % 12;

            // Calculate chord root and intervals
            int rootPc = TheoryScale.GetDegreePitchClass(key, chord.Degree);
            if (rootPc < 0) rootPc = 0;
            rootPc = (rootPc + chord.RootSemitoneOffset) % 12;
            if (rootPc < 0) rootPc += 12;

            // Calculate third and seventh intervals based on chord quality
            int thirdInterval = 0;
            int seventhInterval = 0;
            bool hasSeventh = chord.Extension == ChordExtension.Seventh && 
                             chord.SeventhQuality != SeventhQuality.None;

            switch (chord.Quality)
            {
                case ChordQuality.Major:
                    thirdInterval = 4;
                    break;
                case ChordQuality.Minor:
                    thirdInterval = 3;
                    break;
                case ChordQuality.Diminished:
                    thirdInterval = 3;
                    break;
                case ChordQuality.Augmented:
                    thirdInterval = 4;
                    break;
            }

            if (hasSeventh)
            {
                switch (chord.SeventhQuality)
                {
                    case SeventhQuality.Major7:
                        seventhInterval = 11;
                        break;
                    case SeventhQuality.Minor7:
                    case SeventhQuality.Dominant7:
                    case SeventhQuality.HalfDiminished7:
                        seventhInterval = 10;
                        break;
                    case SeventhQuality.Diminished7:
                        seventhInterval = 9;
                        break;
                }
            }

            int thirdPc = (rootPc + thirdInterval) % 12;
            int seventhPc = hasSeventh ? (rootPc + seventhInterval) % 12 : -1;
            
            // Calculate fifth interval based on chord quality
            int fifthInterval = 0;
            switch (chord.Quality)
            {
                case ChordQuality.Major:
                case ChordQuality.Minor:
                    fifthInterval = 7; // Perfect 5th
                    break;
                case ChordQuality.Diminished:
                    fifthInterval = 6; // Diminished 5th
                    break;
                case ChordQuality.Augmented:
                    fifthInterval = 8; // Augmented 5th
                    break;
            }
            int fifthPc = (rootPc + fifthInterval) % 12;

            // Check if this note is the chord's 7th
            if (seventhPc >= 0 && notePc == seventhPc)
            {
                info.isChordSeventh = true;
            }

            // Check if this note is the chord's 3rd
            if (notePc == thirdPc)
            {
                info.isChordThird = true;
            }
            
            // Check if this note is the chord's augmented 5th
            if (notePc == fifthPc && ChordTensionHelper.IsAugmentedFifth(chord, ChordToneRole.Fifth))
            {
                info.isAugmentedFifth = true;
            }

            // Check if this is a global leading tone (degree 7 of the key)
            var scalePcs = TheoryScale.GetDiatonicPitchClasses(key);
            if (scalePcs != null && scalePcs.Length >= 7)
            {
                int leadingTonePc = scalePcs[6]; // Degree 7 (0-indexed is 6)
                if (notePc == leadingTonePc)
                {
                    info.isGlobalLeadingTone = true;
                    info.scaleDegree = 7;
                }
                else
                {
                    // Try to find scale degree
                    for (int i = 0; i < 7; i++)
                    {
                        if (scalePcs[i] == notePc)
                        {
                            info.scaleDegree = i + 1;
                            break;
                        }
                    }
                }
            }

            // Check if this is a local leading tone (3rd of a secondary dominant)
            if (info.isChordThird && 
                analysis.FunctionTag == ChordFunctionTag.SecondaryDominant &&
                analysis.SecondaryTargetDegree.HasValue)
            {
                int targetDegree = analysis.SecondaryTargetDegree.Value;
                
                // Calculate target root pitch class
                int targetRootPc = TheoryScale.GetDegreePitchClass(key, targetDegree);
                if (targetRootPc >= 0)
                {
                    // Normalize pitch class
                    targetRootPc = (targetRootPc + 12) % 12;
                    info.localTargetRootPc = targetRootPc;
                    info.isLocalLeadingTone = true;
                }
            }

            return info;
        }

        /// <summary>
        /// Computes a soft cost adjustment based on tonal tendency rules.
        /// Returns a float adjustment (negative = bonus, positive = penalty).
        /// Magnitudes are kept small (-2 to +2 range) to bias but not override base distances.
        /// </summary>
        /// <param name="from">Tendency info for the voice we're moving from (in previous chord)</param>
        /// <param name="toMidiNote">Candidate MIDI note we're evaluating (in next chord)</param>
        /// <param name="key">The key context</param>
        /// <param name="currentChord">The chord the voice is coming from (previous chord in progression)</param>
        /// <param name="nextChord">The chord the voice is going to (current/next chord in progression)</param>
        /// <param name="currentAnalysis">Analysis of the previous chord</param>
        /// <param name="nextAnalysis">Analysis of the current/next chord</param>
        /// <param name="isSoprano">True if this is the soprano voice (melody-locked)</param>
        /// <param name="nextMelodyMidi">Optional melody MIDI for the next chord (for soprano rule)</param>
        /// <param name="voiceMinMidi">Optional minimum MIDI for this voice's range (for hard 7th resolution constraint)</param>
        /// <param name="voiceMaxMidi">Optional maximum MIDI for this voice's range (for hard 7th resolution constraint)</param>
        private static float ComputeTendencyCostAdjustment(
            VoiceTendencyInfo from,
            int toMidiNote,
            TheoryKey key,
            ChordRecipe currentChord,
            ChordRecipe nextChord,
            ChordFunctionProfile currentAnalysis,
            ChordFunctionProfile nextAnalysis,
            bool isSoprano,
            int? nextMelodyMidi,
            int voiceMinMidi = -1,
            int voiceMaxMidi = -1)
        {
            // Unconditional debug log when tendency debug is enabled (to confirm function is being called)
            if (enableTendencyDebug)
            {
                string melodyStr = nextMelodyMidi.HasValue ? nextMelodyMidi.Value.ToString() : "null";
                UnityEngine.Debug.Log($"[Tendency Debug] Check voice tendency: prev={from.midiNote}, cand={toMidiNote}, " +
                    $"is7th={from.isChordSeventh}, isGlobalLT={from.isGlobalLeadingTone}, isLocalLT={from.isLocalLeadingTone}, " +
                    $"isSoprano={isSoprano}, melodyNext={melodyStr}");
            }
            
            float adjustment = 0f;
            int semitoneDistance = Math.Abs(toMidiNote - from.midiNote);
            int direction = Math.Sign(toMidiNote - from.midiNote);

            // Get next chord tone pitch classes
            var nextChordTonePcs = GetChordTonePitchClasses(new ChordEvent
            {
                Key = key,
                Recipe = nextChord
            });
            int toPc = (toMidiNote % 12 + 12) % 12;
            bool toIsChordTone = nextChordTonePcs.Contains(toPc);

            // ========================================================================
            // RULE A: Chord 7ths prefer to resolve down by step
            // ========================================================================
            if (from.isChordSeventh && toIsChordTone)
            {
                int prev = from.midiNote;
                int cand = toMidiNote;
                int seventhSemitoneDelta = cand - prev;  // >0 up, <0 down
                int seventhAbsDelta = Math.Abs(seventhSemitoneDelta);
                
                int seventhPrevPc = (prev % 12 + 12) % 12;
                int candPc = (cand % 12 + 12) % 12;
                
                // Case A2: Melody already has the resolution tone
                bool melodyOnResolution = false;
                if (!isSoprano && nextMelodyMidi.HasValue && nextMelodyMidi.Value >= 0)
                {
                    int melodyMidi = nextMelodyMidi.Value;
                    int melodyPc = (melodyMidi % 12 + 12) % 12;
                    
                    // A simple "step down" test in pitch-class space:
                    // previous 7th -> resolution should be 1 or 2 semitones below
                    int pcDown1 = (seventhPrevPc + 11) % 12;   // -1 semitone
                    int pcDown2 = (seventhPrevPc + 10) % 12;   // -2 semitones
                    
                    if (melodyPc == pcDown1 || melodyPc == pcDown2)
                    {
                        melodyOnResolution = true;
                    }
                }
                
                // Apply special-case bonuses/penalties when melodyOnResolution is true
                if (melodyOnResolution)
                {
                    int melodyMidi = nextMelodyMidi.Value;
                    int melodyPc = (melodyMidi % 12 + 12) % 12;
                    
                    bool resolvesDownToMelody = (cand < prev) &&
                                                (candPc == melodyPc) &&
                                                (seventhAbsDelta >= 1 && seventhAbsDelta <= 3);
                    
                    if (resolvesDownToMelody)
                    {
                        adjustment += SeventhResolutionWithMelodyDoubleBonus;
                        
                        if (enableTendencyDebug)
                        {
                            UnityEngine.Debug.Log($"[Tendency Debug] RuleA-MelodyDouble GOOD: prev={prev} ({seventhPrevPc}), cand={cand} ({candPc}), " +
                                $"melodyNext={melodyMidi} ({melodyPc}) → bonus {SeventhResolutionWithMelodyDoubleBonus}");
                        }
                    }
                    else
                    {
                        adjustment += SeventhResolutionWithMelodyDoublePenalty;
                        
                        if (enableTendencyDebug)
                        {
                            UnityEngine.Debug.Log($"[Tendency Debug] RuleA-MelodyDouble BAD: prev={prev} ({seventhPrevPc}), cand={cand} ({candPc}), " +
                                $"melodyNext={melodyMidi} ({melodyPc}) → penalty {SeventhResolutionWithMelodyDoublePenalty}");
                        }
                    }
                    // Special case takes precedence - skip normal Rule A logic
                }
                else
                {
                    // Case A1: Normal "7th resolves down" (no melody special case)
                    // Check for stepwise downward resolution for chord 7ths
                    // When there's no melody, soprano 7ths should also follow the hard rule
                    bool noMelody = nextMelodyMidi == null;
                    bool shouldApplyHardRule = noMelody || !isSoprano;
                    
                    if (shouldApplyHardRule)
                    {
                        // Determine valid resolution pitch classes (1-2 semitones down)
                        int resolutionPc1 = (seventhPrevPc + 11) % 12;   // -1 semitone
                        int resolutionPc2 = (seventhPrevPc + 10) % 12;   // -2 semitones
                        
                        // Check if the next chord contains either resolution pitch class
                        bool hasResolutionTone = nextChordTonePcs.Contains(resolutionPc1) || nextChordTonePcs.Contains(resolutionPc2);
                        
                        // Helper to check if a pitch class is a valid 7th resolution
                        bool isValidSeventhResolution(int fromPc, int toPc)
                        {
                            int pcDown1 = (fromPc + 11) % 12;
                            int pcDown2 = (fromPc + 10) % 12;
                            return (toPc == pcDown1 || toPc == pcDown2);
                        }
                        
                        // HARD CONSTRAINT: If voice range is provided and a valid downward resolution exists in range,
                        // enforce it as a hard constraint (only allow the resolution, veto everything else)
                        bool hasValidDownwardResolution = false;
                        int resolutionMidi = -1;
                        
                        if (hasResolutionTone && voiceMinMidi >= 0 && voiceMaxMidi >= 0)
                        {
                            // Try to find a valid downward resolution within the voice's range
                            // Try resolutionPc1 first (more common -1 semitone resolution)
                            if (nextChordTonePcs.Contains(resolutionPc1))
                            {
                                resolutionMidi = FindDownwardSeventhResolution(prev, resolutionPc1, voiceMinMidi, voiceMaxMidi);
                            }
                            
                            // Try resolutionPc2 if resolutionPc1 didn't yield a result
                            if (resolutionMidi < 0 && nextChordTonePcs.Contains(resolutionPc2))
                            {
                                resolutionMidi = FindDownwardSeventhResolution(prev, resolutionPc2, voiceMinMidi, voiceMaxMidi);
                            }
                            
                            hasValidDownwardResolution = (resolutionMidi >= 0);
                        }
                        
                        if (hasValidDownwardResolution)
                        {
                            // HARD CONSTRAINT: Only allow the exact resolution MIDI, veto everything else
                            if (cand == resolutionMidi)
                            {
                                // Good: apply strong bonus
                                adjustment += SeventhResolutionDownStepBonusHard;
                                
                                if (enableTendencyDebug)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(prev, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(cand, key);
                                    string resolutionName = TheoryPitch.GetPitchNameFromMidi(resolutionMidi, key);
                                    string voiceLabel = isSoprano ? "Soprano" : "Inner";
                                    UnityEngine.Debug.Log($"[Tendency Debug] RuleA-HARD GOOD (7th) [{voiceLabel}]: prev={prevName}({prev}) -> {candName}({cand}), resolution={resolutionName}({resolutionMidi}), bonus={SeventhResolutionDownStepBonusHard}");
                                }
                            }
                            else
                            {
                                // BAD: hard veto unless this candidate is the only allowed one due to range
                                adjustment += SeventhResolutionHardPenalty;
                                
                                if (enableTendencyDebug)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(prev, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(cand, key);
                                    string resolutionName = TheoryPitch.GetPitchNameFromMidi(resolutionMidi, key);
                                    string voiceLabel = isSoprano ? "Soprano" : "Inner";
                                    UnityEngine.Debug.Log($"[Tendency Debug] RuleA-HARD VETO (7th) [{voiceLabel}]: prev={prevName}({prev}) -> {candName}({cand}), resolution={resolutionName}({resolutionMidi}), penalty={SeventhResolutionHardPenalty}");
                                }
                            }
                            
                            // When hard rule triggers, SKIP the rest of Rule A's normal logic
                            // Return immediately to avoid applying additional "Normal" bonuses/penalties
                            return adjustment;
                        }
                        else if (hasResolutionTone)
                        {
                            // Soft constraint: valid resolution exists but range not provided or resolution out of range
                            // Use existing "Normal" Rule A logic
                            // Check if this candidate is a stepwise downward resolution (1-2 semitones down)
                            bool isStepwiseDownwardResolution = (cand < prev) && 
                                                               (seventhAbsDelta >= 1 && seventhAbsDelta <= 2) && 
                                                               isValidSeventhResolution(seventhPrevPc, candPc);
                            
                            if (isStepwiseDownwardResolution)
                            {
                                // Strong bonus for correct stepwise downward resolution
                                adjustment += seventhResolutionDownStepBonusNormal;
                                
                                if (enableTendencyDebug)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(prev, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(cand, key);
                                    UnityEngine.Debug.Log($"[Tendency Debug] RuleA-Normal GOOD: prev={prevName}({prev}) -> {candName}({cand}), delta={seventhSemitoneDelta}, bonus={seventhResolutionDownStepBonusNormal}");
                                }
                            }
                            else if (cand >= prev)
                            {
                                // Strong penalty for upward or hold motion when a valid down step resolution exists
                                adjustment += seventhResolutionAvoidPenaltyNormal;
                                
                                if (enableTendencyDebug)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(prev, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(cand, key);
                                    UnityEngine.Debug.Log($"[Tendency Debug] RuleA-Normal AVOID: prev={prevName}({prev}) -> {candName}({cand}), delta={seventhSemitoneDelta}, penalty={seventhResolutionAvoidPenaltyNormal}");
                                }
                            }
                            // Large downward leaps (absDelta > 2) are left neutral or mild penalty
                            // so the injected step-down resolution will always win when available
                        }
                        else
                        {
                            // No step-down resolution available - use milder adjustments
                            if (seventhSemitoneDelta < 0 && seventhAbsDelta >= 1 && seventhAbsDelta <= 3)
                            {
                                adjustment += SeventhResolutionDownStepBonus;
                            }
                            // Check if holding the 7th while a good resolution exists
                            else if (cand == prev)
                            {
                                // Check if a good step-down resolution exists in the next chord
                                bool hasGoodResolution = false;
                                
                                foreach (int candidatePc in nextChordTonePcs)
                                {
                                    int pcDiff = (candidatePc - seventhPrevPc + 12) % 12;
                                    // 9-11 semitones up in pitch class = 1-3 semitones down
                                    if (pcDiff >= 9 && pcDiff <= 11)
                                    {
                                        hasGoodResolution = true;
                                        break;
                                    }
                                }
                                
                                if (hasGoodResolution)
                                {
                                    adjustment += SeventhResolutionHoldPenalty;
                                }
                            }
                            // Small penalty for large upward leaps
                            else if (seventhSemitoneDelta > 0 && seventhAbsDelta >= 5)
                            {
                                adjustment += SeventhResolutionLargeLeapPenalty;
                            }
                            
                            if (enableTendencyDebug && adjustment != 0f)
                            {
                                UnityEngine.Debug.Log($"[Tendency Debug] RuleA-Normal: prev={prev}, cand={cand}, delta={seventhSemitoneDelta}, adjust={adjustment}");
                            }
                        }
                    }
                    else
                    {
                        // Soprano voice - use milder adjustments (soprano is melody-locked, so 7th resolution is less critical)
                        if (seventhSemitoneDelta < 0 && seventhAbsDelta >= 1 && seventhAbsDelta <= 3)
                        {
                            adjustment += SeventhResolutionDownStepBonus;
                        }
                        // Check if holding the 7th while a good resolution exists
                        else if (cand == prev)
                        {
                            // Check if a good step-down resolution exists in the next chord
                            bool hasGoodResolution = false;
                            
                            foreach (int candidatePc in nextChordTonePcs)
                            {
                                int pcDiff = (candidatePc - seventhPrevPc + 12) % 12;
                                // 9-11 semitones up in pitch class = 1-3 semitones down
                                if (pcDiff >= 9 && pcDiff <= 11)
                                {
                                    hasGoodResolution = true;
                                    break;
                                }
                            }
                            
                            if (hasGoodResolution)
                            {
                                adjustment += SeventhResolutionHoldPenalty;
                            }
                        }
                        // Small penalty for large upward leaps
                        else if (seventhSemitoneDelta > 0 && seventhAbsDelta >= 5)
                        {
                            adjustment += SeventhResolutionLargeLeapPenalty;
                        }
                        
                        if (enableTendencyDebug && adjustment != 0f)
                        {
                            UnityEngine.Debug.Log($"[Tendency Debug] RuleA-Normal: prev={prev}, cand={cand}, delta={seventhSemitoneDelta}, adjust={adjustment}");
                        }
                    }
                }
            }

            // ========================================================================
            // RULE A2: #11 resolution tendency (soprano only)
            // Strong on dominant chords, weak/optional on maj/maj7 (Lydian color)
            // ========================================================================
            if (isSoprano && nextMelodyMidi.HasValue && nextMelodyMidi.Value >= 0)
            {
                // Check if current note is #11 of the current chord
                int currentNotePc = (from.midiNote % 12 + 12) % 12;
                var currentChordTonePcs = GetChordTonePitchClasses(new ChordEvent
                {
                    Key = key,
                    Recipe = currentChord
                });
                
                // Calculate root PC of current chord
                int sharp11CurrentRootPc = TheoryScale.GetDegreePitchClass(key, currentChord.Degree);
                if (sharp11CurrentRootPc < 0) sharp11CurrentRootPc = 0;
                sharp11CurrentRootPc = (sharp11CurrentRootPc + currentChord.RootSemitoneOffset + 12) % 12;
                if (sharp11CurrentRootPc < 0) sharp11CurrentRootPc += 12;
                
                // #11 is interval class +6 (tritone) from root
                int sharp11Pc = (sharp11CurrentRootPc + 6) % 12;
                
                // Check if current note is #11 and not a core chord tone
                bool isSharp11 = (currentNotePc == sharp11Pc) && !currentChordTonePcs.Contains(currentNotePc);
                
                if (isSharp11)
                {
                    int nextMelodyMidiValue = nextMelodyMidi.Value;
                    int nextMelodyPc = (nextMelodyMidiValue % 12 + 12) % 12;
                    int sharp11SemitoneDelta = nextMelodyMidiValue - from.midiNote;
                    
                    // Check if melody moves up by step (1-2 semitones up)
                    bool resolvesUpByStep = (sharp11SemitoneDelta > 0 && sharp11SemitoneDelta <= 2);
                    
                    if (resolvesUpByStep)
                    {
                        // Determine chord quality
                        bool isDominant = currentChord.Extension == ChordExtension.Seventh &&
                                         currentChord.SeventhQuality == SeventhQuality.Dominant7;
                        bool isMajorOrMaj7 = (currentChord.Quality == ChordQuality.Major) ||
                                            (currentChord.Extension == ChordExtension.Seventh &&
                                             currentChord.SeventhQuality == SeventhQuality.Major7);
                        
                        float bonus = 0f;
                        string qualityLabel = "none";
                        
                        if (isDominant)
                        {
                            bonus = sharp11ResolveUpBonus_Dominant;
                            qualityLabel = "dom";
                        }
                        else if (isMajorOrMaj7)
                        {
                            bonus = sharp11ResolveUpBonus_Maj7;
                            qualityLabel = "maj7";
                        }
                        
                        if (bonus != 0f)
                        {
                            adjustment += bonus;
                            
                            if (enableTendencyDebug)
                            {
                                string currentName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                string nextName = TheoryPitch.GetPitchNameFromMidi(nextMelodyMidiValue, key);
                                UnityEngine.Debug.Log(
                                    $"[Tendency Debug] #11 tendency applied: {qualityLabel}, deltaCost={bonus}, " +
                                    $"resolvedUp={resolvesUpByStep} ({currentName}→{nextName}, delta={sharp11SemitoneDelta})");
                            }
                        }
                    }
                }
            }

            // ========================================================================
            // RULE A3: 9th resolution tendencies (b9, 9, #9)
            // Soft preferences for stepwise resolution when target pitch class exists in next chord
            // ========================================================================
            // Get candidatePCs for next chord (chord tones + requested tensions)
            var nextCandidatePcs = new HashSet<int>(nextChordTonePcs);
            if (nextChord.RequestedExtensions.HasAny)
            {
                int nextRootPc = TheoryScale.GetDegreePitchClass(key, nextChord.Degree);
                if (nextRootPc < 0) nextRootPc = 0;
                nextRootPc = (nextRootPc + nextChord.RootSemitoneOffset + 12) % 12;
                if (nextRootPc < 0) nextRootPc += 12;
                
                var nextReqExt = nextChord.RequestedExtensions;
                if (nextReqExt.TensionFlat9)
                    nextCandidatePcs.Add((nextRootPc + 1) % 12);
                else if (nextReqExt.Tension9)
                    nextCandidatePcs.Add((nextRootPc + 2) % 12);
                if (nextReqExt.TensionSharp11)
                    nextCandidatePcs.Add((nextRootPc + 6) % 12);
            }
            
            // Check if previous chord had 9th tensions (requested OR realized in dominant-quality chord)
            int prevPc = (from.midiNote % 12 + 12) % 12;
            int currentRootPc = TheoryScale.GetDegreePitchClass(key, currentChord.Degree);
            if (currentRootPc < 0) currentRootPc = 0;
            currentRootPc = (currentRootPc + currentChord.RootSemitoneOffset + 12) % 12;
            if (currentRootPc < 0) currentRootPc += 12;
            
            var reqExt = currentChord.RequestedExtensions;
            int semitoneDelta = toMidiNote - from.midiNote;
            int absDelta = Math.Abs(semitoneDelta);
            
            // Detect if chord is dominant-quality (for natural 9 detection even if not requested)
            bool isDominantQuality = (currentChord.Extension == ChordExtension.Seventh &&
                                     currentChord.SeventhQuality == SeventhQuality.Dominant7) ||
                                    (currentChord.Quality == ChordQuality.Major && 
                                     currentChord.Extension == ChordExtension.None);
            
            // Check for b9 (flat 9): interval +1 from root, resolve down by 1 semitone
            // CRITICAL: Only apply when the previous note of THIS voice has prevPc == b9Pc
            if (reqExt.HasAny && reqExt.TensionFlat9)
                {
                    int b9Pc = (currentRootPc + 1) % 12;
                    int targetResolutionPc = (b9Pc + 11) % 12;  // -1 semitone from b9
                    
                    // Only proceed if THIS voice has the b9
                    if (prevPc == b9Pc)
                    {
                        // Get chord token/label for logging
                        string currentChordToken = TheoryChord.RecipeToRomanNumeral(key, currentChord);
                        string nextChordToken = TheoryChord.RecipeToRomanNumeral(key, nextChord);
                        
                        int toPcFromRule = (toMidiNote % 12 + 12) % 12;
                        bool targetPcInNextCandidates = nextCandidatePcs.Contains(targetResolutionPc);
                        
                        // STRICT MIDI step requirement: candidateMidi - prevMidi == -1 (exactly -1, not octave-displaced)
                        bool isStrictStepDown = (semitoneDelta == -1);
                        bool candidateMatchesTarget = (toPcFromRule == targetResolutionPc);
                        
                        // Determine voice role (approximate based on isSoprano flag)
                        string voiceRole = isSoprano ? "Soprano" : "Inner voice (Tenor/Alto)";
                        
                        // DIAGNOSTIC: Log b9 resolution evaluation for step 1 (resolving from step 0)
                        // This helps identify if register anchoring or other factors are overriding strict-step preference
                        UnityEngine.Debug.Log(
                            $"[B9_RESOLVE_STEP1_DIAG] === b9 Resolution Evaluation (step 1, resolving from step 0) ===\n" +
                            $"  Previous chord: {currentChordToken}, Next chord: {nextChordToken}\n" +
                            $"  Voice with b9: prevMidi={from.midiNote} ({TheoryPitch.GetPitchNameFromMidi(from.midiNote, key)}), prevPc={prevPc}\n" +
                            $"  Candidate: candidateMidi={toMidiNote} ({TheoryPitch.GetPitchNameFromMidi(toMidiNote, key)}), candidatePc={toPcFromRule}\n" +
                            $"  midiDelta={semitoneDelta} (strict step down? {isStrictStepDown}, expected: -1)\n" +
                            $"  targetResolutionPc={targetResolutionPc}, matchesTarget={candidateMatchesTarget}\n" +
                            $"  targetPcInNextCandidates={targetPcInNextCandidates}\n" +
                            $"  voiceMinMidi={voiceMinMidi}, voiceMaxMidi={voiceMaxMidi}\n" +
                            $"  isSoprano={isSoprano}, voiceRole={voiceRole}");
                        
                        // Detailed logging only when this voice has the b9 (verbose only)
                        if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                            string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                            
                            UnityEngine.Debug.Log(
                                $"[B9_RESOLVE_DIAG] === b9 Detection for {currentChordToken} → {nextChordToken} ===\n" +
                                $"  Previous chord info:\n" +
                                $"    token/label: {currentChordToken}\n" +
                                $"    prevRootPc (used in b9PC calc): {currentRootPc}\n" +
                                $"    computed b9PC: {b9Pc}\n" +
                                $"    targetResolutionPC: {targetResolutionPc} (b9 down 1 semitone)\n" +
                                $"    TensionFlat9 flag: {reqExt.TensionFlat9}\n" +
                                $"  Voice with b9:\n" +
                                $"    voice role: {voiceRole}\n" +
                                $"    prevMidi: {from.midiNote}\n" +
                                $"    prevPc: {prevPc} ({prevName})\n" +
                                $"    prevPc == b9Pc? True (THIS VOICE HAS b9)\n" +
                                $"  Candidate evaluation:\n" +
                                $"    candidateMidi: {toMidiNote}\n" +
                                $"    midiDelta: {semitoneDelta} (strict step down? {isStrictStepDown})\n" +
                                $"    candidatePc: {toPcFromRule} ({candName})\n" +
                                $"    candidatePC == targetPC? {candidateMatchesTarget}\n" +
                                $"    targetPC in nextCandidatePCs? {targetPcInNextCandidates} (nextCandidatePCs: [{string.Join(",", nextCandidatePcs.OrderBy(x => x))}])\n" +
                                $"  Resolution check:\n" +
                                $"    All conditions met? {isStrictStepDown && candidateMatchesTarget && targetPcInNextCandidates}\n" +
                                $"    Bonus applied: {(isStrictStepDown && candidateMatchesTarget && targetPcInNextCandidates ? ninthResolutionFlat9DownBonus : 0f)}");
                        }
                        
                        // Check if target PC exists in next chord's candidatePCs
                        if (targetPcInNextCandidates)
                        {
                            // CRITICAL FIX: Check if strict-step resolution (prevMidi-1) exists and is valid
                            // If it does, apply a very large penalty to ALL candidates that are NOT exactly prevMidi-1
                            int strictTargetMidi = from.midiNote - 1;  // Strict-step resolution: exactly -1 semitone
                            int strictTargetPc = (strictTargetMidi % 12 + 12) % 12;
                            bool strictTargetIsValid = (strictTargetPc == targetResolutionPc) && 
                                                       (voiceMinMidi < 0 || strictTargetMidi >= voiceMinMidi) &&
                                                       (voiceMaxMidi < 0 || strictTargetMidi <= voiceMaxMidi);
                            
                            // If strict-step resolution exists and is valid, penalize all non-strict-step candidates
                            if (strictTargetIsValid && toMidiNote != strictTargetMidi)
                            {
                                // Very large penalty to make strict-step dominant
                                float strictStepPenalty = +50.0f;  // Large enough to override register gravity, compression, etc.
                                adjustment += strictStepPenalty;
                                
                                UnityEngine.Debug.Log(
                                    $"[B9_STRICT_STEP_PENALTY] === Applying penalty to non-strict-step candidate ===\n" +
                                    $"  Voice: {voiceRole}\n" +
                                    $"  prevMidi={from.midiNote} ({TheoryPitch.GetPitchNameFromMidi(from.midiNote, key)})\n" +
                                    $"  strictTargetMidi={strictTargetMidi} ({TheoryPitch.GetPitchNameFromMidi(strictTargetMidi, key)})\n" +
                                    $"  candidateMidi={toMidiNote} ({TheoryPitch.GetPitchNameFromMidi(toMidiNote, key)})\n" +
                                    $"  candidate != strictTarget? {toMidiNote != strictTargetMidi}\n" +
                                    $"  PENALTY applied: {strictStepPenalty}");
                            }
                            
                            // STRICT requirement: candidateMidi - prevMidi == -1 AND candidatePc == targetPc
                            // Do NOT treat octave-displaced motion (e.g., -13) as step resolution
                            if (isStrictStepDown && candidateMatchesTarget)
                            {
                                // CRITICAL FIX: Very large bonus for strict semitone-down resolution
                                // This ensures strict-step wins unless it would violate spacing/protection/range
                                adjustment += ninthResolutionFlat9DownBonus;
                                
                                // DIAGNOSTIC: Trace b9 resolution with voice index info
                                UnityEngine.Debug.Log(
                                    $"[B9_RESOLVE_TRACE] === b9 Resolution Applied ===\n" +
                                    $"  Voice: {voiceRole} (voice index mapping: [0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano)\n" +
                                    $"  Previous chord: {currentChordToken}, Next chord: {nextChordToken}\n" +
                                    $"  prevMidi={from.midiNote} ({TheoryPitch.GetPitchNameFromMidi(from.midiNote, key)}), prevPc={prevPc}\n" +
                                    $"  candidateMidi={toMidiNote} ({TheoryPitch.GetPitchNameFromMidi(toMidiNote, key)}), candidatePc={toPcFromRule}\n" +
                                    $"  midiDelta={semitoneDelta} (strict step down: {isStrictStepDown})\n" +
                                    $"  targetResolutionPc={targetResolutionPc}, matchesTarget={candidateMatchesTarget}\n" +
                                    $"  Bonus applied: {ninthResolutionFlat9DownBonus}");
                                
                                // High-level summary (always on)
                                if (s_debugTensionDetect)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                    UnityEngine.Debug.Log(
                                        $"Applied b9 downward resolution bonus ({voiceRole}): {prevName} -> {candName}");
                                }
                                
                                // Verbose details (gated)
                                if (s_debugTensionVerbose && s_debugTensionDetect)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                    UnityEngine.Debug.Log(
                                        $"[REQ_EXT_RESOLVE_TRACE] b9 resolution BONUS APPLIED ({voiceRole}): prev={prevName}(PC={prevPc}, MIDI={from.midiNote}) -> {candName}(PC={toPcFromRule}, MIDI={toMidiNote}), " +
                                        $"targetPC={targetResolutionPc}, midiDelta={semitoneDelta}, bonus={ninthResolutionFlat9DownBonus}");
                                }
                            }
                            else if (candidateMatchesTarget)
                            {
                                // CRITICAL FIX: Strong penalty for matching target PC but NOT strict semitone-down
                                // This prevents "correct PC but wrong octave" (e.g., G#4 -> G5 instead of G4)
                                // Penalty should be strong enough to make strict-step win, but not so strong it overrides spacing/protection
                                float nonStrictPenalty = +15.0f; // Strong penalty for non-strict-step when strict-step exists
                                adjustment += nonStrictPenalty;
                                
                                // DIAGNOSTIC: Trace non-strict resolution
                                UnityEngine.Debug.Log(
                                    $"[B9_RESOLVE_TRACE] === b9 NON-STRICT Resolution (PENALTY) ===\n" +
                                    $"  Voice: {voiceRole} (voice index mapping: [0]=Bass, [1]=Tenor, [2]=Alto, [3]=Soprano)\n" +
                                    $"  Previous chord: {currentChordToken}, Next chord: {nextChordToken}\n" +
                                    $"  prevMidi={from.midiNote} ({TheoryPitch.GetPitchNameFromMidi(from.midiNote, key)}), prevPc={prevPc}\n" +
                                    $"  candidateMidi={toMidiNote} ({TheoryPitch.GetPitchNameFromMidi(toMidiNote, key)}), candidatePc={toPcFromRule}\n" +
                                    $"  midiDelta={semitoneDelta} (strict step down: {isStrictStepDown}, expected: -1)\n" +
                                    $"  targetResolutionPc={targetResolutionPc}, matchesTarget={candidateMatchesTarget}\n" +
                                    $"  PENALTY applied: {nonStrictPenalty} (prevents octave-jump resolution)");
                                
                                if (s_debugTensionVerbose && s_debugTensionDetect)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                    UnityEngine.Debug.Log(
                                        $"[REQ_EXT_RESOLVE_TRACE] b9 detected but NON-STRICT resolution ({voiceRole}): prev={prevName}(PC={prevPc}, MIDI={from.midiNote}) -> {candName}(PC={toPcFromRule}, MIDI={toMidiNote}), " +
                                        $"targetPC={targetResolutionPc}, midiDelta={semitoneDelta} (expected -1), penalty={nonStrictPenalty}");
                                }
                            }
                            else if (s_debugTensionVerbose && s_debugTensionDetect)
                            {
                                // Log why bonus was NOT applied even though b9 detected and target exists (verbose only)
                                string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_RESOLVE_TRACE] b9 detected but NO bonus ({voiceRole}): prev={prevName}(PC={prevPc}, MIDI={from.midiNote}) -> {candName}(PC={toPcFromRule}, MIDI={toMidiNote}), " +
                                    $"targetPC={targetResolutionPc}, midiDelta={semitoneDelta}, " +
                                    $"isStrictStepDown={isStrictStepDown}, matchesTarget={candidateMatchesTarget}");
                            }
                        }
                        else if (s_debugTensionVerbose && s_debugTensionDetect)
                        {
                            // Log that target PC doesn't exist in next chord (verbose only)
                            string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                            string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                            UnityEngine.Debug.Log(
                                $"[REQ_EXT_RESOLVE_TRACE] b9 detected but targetPC {targetResolutionPc} NOT in nextCandidatePCs ({voiceRole}): " +
                                $"[{string.Join(",", nextCandidatePcs.OrderBy(x => x))}]\n" +
                                $"  prev={prevName}(PC={prevPc}, MIDI={from.midiNote}) -> {candName}(PC={toPcFromRule}, MIDI={toMidiNote})");
                        }
                    }
                }
                
                // Check for natural 9: interval +2 from root, prefer whole-step resolution (strong preference for down)
                // Detect if natural 9 is present: requestedExtension 9 OR realized pitch class = (root+2) mod 12 for dominant-quality chord
                bool hasNatural9 = (reqExt.HasAny && reqExt.Tension9 && !reqExt.TensionFlat9) ||  // Requested
                                   (isDominantQuality && prevPc == (currentRootPc + 2) % 12);      // Realized in dominant
                
                if (hasNatural9)
                {
                    int ninePc = (currentRootPc + 2) % 12;
                    if (prevPc == ninePc)
                    {
                        // Target resolution: whole-step (±2 semitones), strong preference for downward
                        int targetResolutionPcDown = (prevPc + 10) % 12;  // -2 semitones (down whole-step)
                        int targetResolutionPcUp = (prevPc + 2) % 12;     // +2 semitones (up whole-step)
                        int toPcFromRule = (toMidiNote % 12 + 12) % 12;
                        
                        // Check if either target PC exists in next chord's candidatePCs
                        bool canResolveDown = nextCandidatePcs.Contains(targetResolutionPcDown);
                        bool canResolveUp = nextCandidatePcs.Contains(targetResolutionPcUp);
                        
                        // Check if up-step target is the 7th of the next chord and that PC is already present elsewhere
                        bool upStepIsSeventh = false;
                        bool seventhAlreadyPresent = false;
                        if (canResolveUp)
                        {
                            // Check if targetResolutionPcUp is the 7th of next chord
                            int nextRootPcForSeventh = TheoryScale.GetDegreePitchClass(key, nextChord.Degree);
                            if (nextRootPcForSeventh < 0) nextRootPcForSeventh = 0;
                            nextRootPcForSeventh = (nextRootPcForSeventh + nextChord.RootSemitoneOffset + 12) % 12;
                            if (nextRootPcForSeventh < 0) nextRootPcForSeventh += 12;
                            
                            // Calculate 7th PC based on seventh quality
                            int seventhPc = -1;
                            if (nextChord.Extension == ChordExtension.Seventh && nextChord.SeventhQuality != SeventhQuality.None)
                            {
                                int seventhInterval = 0;
                                switch (nextChord.SeventhQuality)
                                {
                                    case SeventhQuality.Major7: seventhInterval = 11; break;
                                    case SeventhQuality.Minor7:
                                    case SeventhQuality.Dominant7:
                                    case SeventhQuality.HalfDiminished7: seventhInterval = 10; break;
                                    case SeventhQuality.Diminished7: seventhInterval = 9; break;
                                    default: seventhInterval = 10; break;
                                }
                                seventhPc = (nextRootPcForSeventh + seventhInterval) % 12;
                            }
                            
                            upStepIsSeventh = (targetResolutionPcUp == seventhPc);
                            
                            // Check if 7th PC is already present in other voices (we'd be doubling it)
                            // Note: We can't check other voices directly here, but we can check if it's in nextCandidatePcs
                            // and assume it might be doubled if we're resolving to it
                            seventhAlreadyPresent = upStepIsSeventh && nextCandidatePcs.Contains(seventhPc);
                        }
                        
                        // Check for leap resolution (>= P4 = 5 semitones)
                        bool isLeap = absDelta >= 5;
                        
                        // Determine voice role (for logging)
                        string voiceRole = isSoprano ? "Soprano" : "Inner voice (Tenor/Alto)";
                        
                        // NOTE: Structural rejection for natural 9 is now handled in VoiceNextChord candidate evaluation loops
                        // (candidates that don't resolve by step are rejected before cost computation)
                        // Here we only apply preference bonuses for correct resolutions
                        bool usesDownwardResolution = canResolveDown && semitoneDelta == -2 && toPcFromRule == targetResolutionPcDown;
                        bool usesUpwardResolution = canResolveUp && semitoneDelta == 2 && toPcFromRule == targetResolutionPcUp;
                        
                        // Apply bonuses/penalties for correct resolutions
                        if (usesDownwardResolution)
                        {
                            // Downward whole-step resolution (strongly preferred)
                            adjustment += ninthResolutionNatural9DownBonus;
                            
                            // High-level summary (always on)
                            if (s_debugTensionDetect)
                            {
                                string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                UnityEngine.Debug.Log($"Applied 9 downward whole-step resolution bonus: {prevName} -> {candName}");
                            }
                            
                            // Verbose details (gated)
                            if (s_debugTensionVerbose && s_debugTensionDetect)
                            {
                                string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_RESOLVE_TRACE] 9 resolution (down whole-step): prev={prevName}(PC={prevPc}) -> {candName}(PC={toPcFromRule}), " +
                                    $"targetPC={targetResolutionPcDown}, delta={semitoneDelta}, bonus={ninthResolutionNatural9DownBonus}");
                            }
                        }
                        else if (usesUpwardResolution)
                        {
                            // Upward whole-step resolution (weaker bonus)
                            float bonus = ninthResolutionNatural9UpBonus;
                            
                            // Apply soft penalty if up-step target is 7th and that PC is already present
                            if (seventhAlreadyPresent)
                            {
                                bonus += ninthResolutionNatural9DoubleSeventhPenalty;
                                
                                if (s_debugTensionVerbose && s_debugTensionDetect)
                                {
                                    UnityEngine.Debug.Log(
                                        $"[REQ_EXT_RESOLVE_TRACE] 9 up-step resolution doubles 7th: penalty={ninthResolutionNatural9DoubleSeventhPenalty}");
                                }
                            }
                            
                            adjustment += bonus;
                            
                            // High-level summary (always on)
                            if (s_debugTensionDetect)
                            {
                                string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                UnityEngine.Debug.Log($"Applied 9 upward whole-step resolution bonus: {prevName} -> {candName}");
                            }
                            
                            // Verbose details (gated)
                            if (s_debugTensionVerbose && s_debugTensionDetect)
                            {
                                string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                UnityEngine.Debug.Log(
                                    $"[REQ_EXT_RESOLVE_TRACE] 9 resolution (up whole-step): prev={prevName}(PC={prevPc}) -> {candName}(PC={toPcFromRule}), " +
                                    $"targetPC={targetResolutionPcUp}, delta={semitoneDelta}, bonus={bonus}");
                            }
                        }
                        else if (isLeap)
                        {
                            // Penalty for resolving 9 by leap (>= P4), especially in upper voices
                            float leapPenalty = ninthResolutionNatural9LeapPenalty;
                            if (isSoprano)
                            {
                                leapPenalty *= 1.5f; // Extra penalty for leaps in soprano
                            }
                            
                            adjustment += leapPenalty;
                            
                            if (s_debugTensionDetect)
                            {
                                string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                string voiceLabel = isSoprano ? "Soprano" : "Inner voice";
                                UnityEngine.Debug.Log(
                                    $"Applied 9 leap resolution penalty ({voiceLabel}): {prevName} -> {candName} (leap={absDelta} semitones), penalty={leapPenalty}");
                            }
                        }
                    }
                }
                
                // Check for #9 (sharp 9): interval +3 from root, resolve up by 1 semitone
                // Note: #9 is not explicitly tracked in RequestedExtensions currently.
                // Heuristic: detect root+3 PC in dominant 7th chords where natural 9 isn't requested
                // This is a common jazz context (e.g., V7#9). We'll be conservative and only apply
                // when the chord is a dominant 7th and natural 9 wasn't explicitly requested.
                bool isDominant7 = currentChord.Extension == ChordExtension.Seventh &&
                                  currentChord.SeventhQuality == SeventhQuality.Dominant7;
                bool natural9NotRequested = !reqExt.Tension9 && !reqExt.TensionFlat9;
                
                if (isDominant7 && natural9NotRequested)
                {
                    int sharp9Pc = (currentRootPc + 3) % 12;  // #9 is root + minor 3rd = +3 semitones
                    if (prevPc == sharp9Pc)
                    {
                        // Target resolution: up by 1 semitone
                        int targetResolutionPc = (prevPc + 1) % 12;  // +1 semitone
                        int toPcFromRule = (toMidiNote % 12 + 12) % 12;
                        
                        // Check if target PC exists in next chord's candidatePCs
                        if (nextCandidatePcs.Contains(targetResolutionPc))
                        {
                            // Check if candidate resolves up by exactly 1 semitone to target PC
                            if (semitoneDelta == 1 && toPcFromRule == targetResolutionPc)
                            {
                                adjustment += ninthResolutionSharp9UpBonus;
                                
                                // High-level summary (always on)
                                if (s_debugTensionDetect)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                    UnityEngine.Debug.Log($"Applied #9 upward resolution bonus: {prevName} -> {candName}");
                                }
                                
                                // Verbose details (gated)
                                if (s_debugTensionVerbose && s_debugTensionDetect)
                                {
                                    string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                    string candName = TheoryPitch.GetPitchNameFromMidi(toMidiNote, key);
                                    UnityEngine.Debug.Log(
                                        $"[REQ_EXT_RESOLVE_TRACE] #9 resolution (heuristic): prev={prevName}(PC={prevPc}) -> {candName}(PC={toPcFromRule}), " +
                                        $"targetPC={targetResolutionPc}, delta={semitoneDelta}, bonus={ninthResolutionSharp9UpBonus}");
                                }
                            }
                        }
                    }
                }

            // ========================================================================
            // RULE B: Global leading tone prefers to resolve up to tonic (softly)
            // ========================================================================
            if (from.isGlobalLeadingTone && toIsChordTone)
            {
                // Check if next chord needs its 7th (to avoid weakening leading tone when 7th coverage is critical)
                bool nextChordHasSeventh = nextChord.Extension == ChordExtension.Seventh &&
                                          nextChord.SeventhQuality != SeventhQuality.None;
                
                bool nextChordSeventhMissing = false;
                if (nextChordHasSeventh)
                {
                    // Calculate what the 7th pitch class should be
                    int nextRootPc = TheoryScale.GetDegreePitchClass(key, nextChord.Degree);
                    if (nextRootPc < 0) nextRootPc = 0;
                    nextRootPc = (nextRootPc + nextChord.RootSemitoneOffset) % 12;
                    if (nextRootPc < 0) nextRootPc += 12;
                    
                    // Determine 7th interval based on chord quality
                    int nextSeventhInterval = 10; // Default
                    switch (nextChord.SeventhQuality)
                    {
                        case SeventhQuality.Major7:
                            nextSeventhInterval = 11;
                            break;
                        case SeventhQuality.Minor7:
                        case SeventhQuality.Dominant7:
                        case SeventhQuality.HalfDiminished7:
                            nextSeventhInterval = 10;
                            break;
                        case SeventhQuality.Diminished7:
                            nextSeventhInterval = 9;
                            break;
                    }
                    int nextSeventhPc = (nextRootPc + nextSeventhInterval) % 12;
                    
                    // Check if the next chord's 7th is missing in the current candidate set
                    // (We can't check all voices here, but we can check if the candidate we're evaluating is NOT the 7th)
                    nextChordSeventhMissing = (toPc != nextSeventhPc);
                }
                
                // Check if next chord contains tonic (degree 1)
                var scalePcs = TheoryScale.GetDiatonicPitchClasses(key);
                if (scalePcs != null && scalePcs.Length >= 7)
                {
                    int tonicPc = scalePcs[0]; // Degree 1
                    bool nextChordContainsTonic = nextChordTonePcs.Contains(tonicPc);
                    
                    if (nextChordContainsTonic && toPc == tonicPc)
                    {
                        // Moving to tonic by small upward step
                        if (direction > 0 && semitoneDistance >= 1 && semitoneDistance <= 2)
                        {
                            float leadingToneBonus = 0f;
                            
                            if (isSoprano)
                            {
                                // For soprano: only apply if melody already moves up to tonic
                                if (nextMelodyMidi.HasValue && nextMelodyMidi.Value == toMidiNote)
                                {
                                    leadingToneBonus = -2.5f; // Stronger bonus when melody already wants this
                                }
                                // Don't fight the melody - if melody goes elsewhere, no adjustment
                            }
                            else
                            {
                                // For inner voices: stronger preference for 7→1
                                leadingToneBonus = -1.25f;
                                
                                // Soften leading-tone bonus if next chord needs its 7th and we're not providing it
                                if (nextChordHasSeventh && nextChordSeventhMissing)
                                {
                                    leadingToneBonus *= LeadingToneSoftenFactor;
                                    
                                    if (enableTendencyDebug)
                                    {
                                        string prevName = TheoryPitch.GetPitchNameFromMidi(from.midiNote, key);
                                        UnityEngine.Debug.Log($"[Tendency Debug] Leading tone softened to preserve 7th coverage: prev={prevName}, nextChord has 7th that needs coverage");
                                    }
                                }
                            }
                            
                            adjustment += leadingToneBonus;
                        }
                    }
                }
            }

            // ========================================================================
            // RULE C: Local leading tone (3rd of secondary dominants) resolves up to target root
            // ========================================================================
            if (from.isLocalLeadingTone && from.localTargetRootPc >= 0)
            {
                int targetRootPc = from.localTargetRootPc; // Already computed in AnalyzeVoiceTendencies
                
                // Check if next chord's root matches the target (accounting for potential chromatic alterations)
                int nextRootPc = TheoryScale.GetDegreePitchClass(key, nextChord.Degree);
                if (nextRootPc >= 0)
                {
                    nextRootPc = (nextRootPc + nextChord.RootSemitoneOffset) % 12;
                    if (nextRootPc < 0) nextRootPc += 12;

                    bool targetIsAvailable = (nextRootPc == targetRootPc);
                    
                    // Check if candidate is resolving to the target root (by pitch class match)
                    // Note: toPc is already computed earlier in the method
                    if (toPc == targetRootPc)
                    {
                        // Moving to the target root by small step (1-3 semitones in either direction)
                        // Use Math.Abs for distance check to recognize both upward and downward resolutions
                        if (semitoneDistance >= 1 && semitoneDistance <= 3)
                        {
                            // Prefer upward movement with stronger bonus, but also reward downward resolution
                            if (direction > 0)
                            {
                                adjustment -= 2.5f; // Strong bonus for resolving up to target
                            }
                            else
                            {
                                adjustment -= 2.0f; // Still good bonus for downward resolution
                            }
                        }
                    }
                    // Penalty for holding the local leading tone when target is available
                    else if (toMidiNote == from.midiNote && targetIsAvailable)
                    {
                        adjustment += 1.5f; // Penalty for holding when resolution available
                    }
                }
            }

            // ========================================================================
            // RULE D: Augmented 5th (#5) prefers to resolve up by semitone
            // ========================================================================
            if (from.isAugmentedFifth)
            {
                int m0 = from.midiNote;
                int m1 = toMidiNote;
                int interval = m1 - m0; // positive = up, negative = down
                
                // AUG5_DBG Log #4: Log tendency evaluation for augmented 5th
                if (s_enableAug5Debug)
                {
                    int aug5PrevPc = (m0 % 12 + 12) % 12;
                    int aug5TargetPc = (aug5PrevPc + 1) % 12; // +1 semitone resolution target
                    int aug5ToPc = (m1 % 12 + 12) % 12;
                    
                    // Check if next chord supports the resolution pitch class
                    var aug5NextChordTonePcs = GetChordTonePitchClasses(new ChordEvent { Key = key, Recipe = nextChord });
                    bool supportsTargetA = aug5NextChordTonePcs != null && aug5NextChordTonePcs.Contains(aug5TargetPc);
                    
                    string prevName = TheoryPitch.GetPitchNameFromMidi(m0, key);
                    string candName = TheoryPitch.GetPitchNameFromMidi(m1, key);
                    string prevChordName = TheoryChord.RecipeToRomanNumeral(key, currentChord);
                    string nextChordName = TheoryChord.RecipeToRomanNumeral(key, nextChord);
                    
                    string prefersInfo = "";
                    if (interval == 1 && aug5ToPc == aug5TargetPc)
                    {
                        prefersInfo = $"prefersCand={m1}({candName}) [CORRECT_RESOLUTION]";
                    }
                    else if (supportsTargetA)
                    {
                        prefersInfo = $"prefersCand=UNKNOWN (targetA={aug5TargetPc} supported but not in candidate)";
                    }
                    else
                    {
                        prefersInfo = $"prefersCand={m1}({candName}) [NO_TARGET_AVAILABLE]";
                    }
                    
                    UnityEngine.Debug.Log(
                        $"[AUG5_DBG] tendencyEval prevChord={prevChordName} aug5Voice prevMidi={m0}({prevName}) -> nextChord={nextChordName} supportsTargetA={supportsTargetA} targetPc={aug5TargetPc} | {prefersInfo}");
                }
                
                float tendencyPenalty = 0f;
                
                if (interval == 1)
                {
                    // Ideal: resolves up by semitone → no penalty (strong bonus)
                    tendencyPenalty = -1.0f; // Negative = bonus
                    
                    if (enableTendencyDebug)
                    {
                        string prevName = TheoryPitch.GetPitchNameFromMidi(m0, key);
                        string candName = TheoryPitch.GetPitchNameFromMidi(m1, key);
                        UnityEngine.Debug.Log($"[Tendency Debug] RuleD-AUG5 GOOD: prev={prevName}({m0}) -> {candName}({m1}), " +
                            $"interval={interval}, bonus={-tendencyPenalty}");
                    }
                }
                else if (interval == 0 || interval == -1)
                {
                    // Neutral-ish: stays or steps down by semitone
                    // Small penalty, but not catastrophic
                    tendencyPenalty = 0.5f;
                    
                    if (enableTendencyDebug)
                    {
                        string prevName = TheoryPitch.GetPitchNameFromMidi(m0, key);
                        string candName = TheoryPitch.GetPitchNameFromMidi(m1, key);
                        UnityEngine.Debug.Log($"[Tendency Debug] RuleD-AUG5 NEUTRAL: prev={prevName}({m0}) -> {candName}({m1}), " +
                            $"interval={interval}, penalty={tendencyPenalty}");
                    }
                }
                else
                {
                    // Bad: leaps or moves contrary to tendency
                    // Larger penalty (scaled by |interval|)
                    tendencyPenalty = 1.0f + 0.1f * Math.Abs(interval);
                    
                    if (enableTendencyDebug)
                    {
                        string prevName = TheoryPitch.GetPitchNameFromMidi(m0, key);
                        string candName = TheoryPitch.GetPitchNameFromMidi(m1, key);
                        UnityEngine.Debug.Log($"[Tendency Debug] RuleD-AUG5 BAD: prev={prevName}({m0}) -> {candName}({m1}), " +
                            $"interval={interval}, penalty={tendencyPenalty}");
                    }
                }
                
                // Scale by configurable weight and add to adjustment
                adjustment += augmentedFifthResolutionWeight * tendencyPenalty;
            }

            return adjustment;
        }

        /// <summary>
        /// Helper method to log tendency debug information for a chosen voice mapping.
        /// Only logs when enableTendencyDebug is true and the voice has relevant tendencies.
        /// </summary>
        private static void LogTendencyDebugInfo(
            int stepIndex,
            int voiceIndex,
            VoiceTendencyInfo tendencyInfo,
            int fromMidi,
            int chosenMidi,
            TheoryKey key,
            ChordRecipe nextChord,
            ChordFunctionProfile nextAnalysis,
            float baseCost,
            float tendAdjust,
            float totalCost)
        {
            if (!enableTendencyDebug) return;
            
            // Only log if this voice has relevant tendencies
            if (!tendencyInfo.isChordSeventh && !tendencyInfo.isGlobalLeadingTone && !tendencyInfo.isLocalLeadingTone)
                return;

            string fromNote = TheoryPitch.GetPitchNameFromMidi(fromMidi, key);
            string toNote = TheoryPitch.GetPitchNameFromMidi(chosenMidi, key);
            
            var logParts = new System.Text.StringBuilder();
            logParts.Append($"[Tendency Debug] Step {stepIndex}, Voice {voiceIndex}: ");
            logParts.Append($"{fromNote} ({fromMidi}) → {toNote} ({chosenMidi}) | ");
            logParts.Append($"BaseCost={baseCost:F2}, TendAdjust={tendAdjust:F2}, TotalCost={totalCost:F2} | ");
            
            if (tendencyInfo.isChordSeventh)
                logParts.Append("isChordSeventh ");
            if (tendencyInfo.isGlobalLeadingTone)
                logParts.Append("isGlobalLeadingTone ");
            if (tendencyInfo.isLocalLeadingTone)
            {
                logParts.Append($"isLocalLeadingTone (target={TheoryPitch.GetPitchNameFromMidi(tendencyInfo.localTargetRootPc + 60, key)}) ");
            }
            
            UnityEngine.Debug.Log(logParts.ToString());
        }

        /// <summary>
        /// Shifts a MIDI note by octaves to get it into range, preserving pitch class.
        /// Only uses ±12 semitone shifts. Returns the shifted note, or a last-resort clamped value
        /// if no octave shift can get it in range (shouldn't happen in practice).
        /// </summary>
        private static int ShiftToRangePreservingPitchClass(int midi, int minMidi, int maxMidi)
        {
            // Extract pitch class (0-11)
            int pc = ((midi % 12) + 12) % 12;
            
            // If already in range, return as-is
            if (midi >= minMidi && midi <= maxMidi)
                return midi;
            
            // Find the octave that puts this pitch class in range
            // Start by finding the lowest octave that could work
            int targetOctave = (minMidi - pc) / 12;
            if (targetOctave * 12 + pc < minMidi)
                targetOctave++;
            
            int candidate = targetOctave * 12 + pc;
            
            // If this candidate is in range, use it
            if (candidate >= minMidi && candidate <= maxMidi)
                return candidate;
            
            // Try one octave up
            candidate += 12;
            if (candidate >= minMidi && candidate <= maxMidi)
                return candidate;
            
            // Try one octave down from original
            candidate = (targetOctave - 1) * 12 + pc;
            if (candidate >= minMidi && candidate <= maxMidi)
                return candidate;
            
            // Last resort: find the closest octave in range (shouldn't happen, but be safe)
            // This preserves pitch class by finding the octave that minimizes distance to range
            int octave = (minMidi - pc) / 12;
            if (octave * 12 + pc < minMidi) octave++;
            candidate = octave * 12 + pc;
            
            // If still too high, go down an octave
            if (candidate > maxMidi)
                candidate -= 12;
            
            // Final safety clamp only if absolutely necessary (should preserve PC in most cases)
            if (candidate < minMidi || candidate > maxMidi)
            {
                // This is a last resort - find the closest valid MIDI that preserves PC
                int bestCandidate = candidate;
                int bestDistance = int.MaxValue;
                
                // Try a few octaves around the target
                for (int oct = octave - 2; oct <= octave + 2; oct++)
                {
                    int test = oct * 12 + pc;
                    if (test >= minMidi && test <= maxMidi)
                    {
                        int dist = Math.Abs(test - midi);
                        if (dist < bestDistance)
                        {
                            bestCandidate = test;
                            bestDistance = dist;
                        }
                    }
                }
                
                if (bestDistance < int.MaxValue)
                    return bestCandidate;
                
                // Absolute last resort: clamp (this will change pitch class, but it's better than crashing)
                return Math.Max(minMidi, Math.Min(maxMidi, midi));
            }
            
            return candidate;
        }

        /// <summary>
        /// Adjusts Play voicing for continuity and register control.
        /// Tames awkward leaps and extreme registers by shifting voices by octaves within reasonable ranges.
        /// Only shifts by exact octaves (±12 semitones); does not change pitch classes or chord tone choices.
        /// </summary>
        /// <param name="voicedChords">List of voiced chords to adjust (modified in-place)</param>
        /// <param name="cfg">Play voicing settings (ranges and max leap)</param>
        private static void AdjustPlayVoicingForContinuity(List<VoicedChord> voicedChords, PlayVoicingSettings cfg, IReadOnlyList<ChordEvent> chordEvents = null)
        {
            if (voicedChords == null || voicedChords.Count == 0)
                return;

            // Map from VoicedChord order [bass, tenor, alto, soprano] to user's top-to-bottom order [soprano, alto, tenor, bass]
            // VoicedChord.VoicesMidi[0] = bass = user voice 3
            // VoicedChord.VoicesMidi[1] = tenor = user voice 2
            // VoicedChord.VoicesMidi[2] = alto = user voice 1
            // VoicedChord.VoicesMidi[3] = soprano = user voice 0
            int[] voiceMapping = new int[] { 3, 2, 1, 0 }; // Maps user voice index to VoicesMidi index

            // Track previous MIDI for each voice (user indexing: 0=soprano, 3=bass)
            int[] prevMidi = null;

            for (int chordIndex = 0; chordIndex < voicedChords.Count; chordIndex++)
            {
                var voiced = voicedChords[chordIndex];
                if (voiced.VoicesMidi == null || voiced.VoicesMidi.Length < 4)
                    continue;

                // DIAGNOSTIC: Log before adjustment for step 0 and step 1
                if (chordIndex <= 1 && voiced.VoicesMidi.Length >= 4)
                {
                    UnityEngine.Debug.Log(
                        $"[CONTINUITY_ADJUST_DIAG] === AdjustPlayVoicingForContinuity chordIndex={chordIndex} ===\n" +
                        $"  BEFORE: VoicesMidi (BTAS): [{string.Join(", ", voiced.VoicesMidi)}]");
                }

                // Get chord event for this chord (if available) to determine required tones
                ChordEvent? chordEventNullable = null;
                HashSet<int> requiredPcs = null;
                if (chordEvents != null && chordIndex < chordEvents.Count)
                {
                    chordEventNullable = chordEvents[chordIndex];
                    requiredPcs = GetRequiredChordTonePcs(chordEventNullable.Value);
                }
                ChordEvent chordEvent = chordEventNullable ?? default(ChordEvent);

                // Create a working copy of the voices array
                int[] currMidi = new int[4];
                for (int i = 0; i < 4; i++)
                {
                    currMidi[i] = voiced.VoicesMidi[i];
                }

                // Helper function to check if a voice can be modified (doesn't carry unique required tone)
                // Declare at chord level so it's available in all voice adjustment and crossing fix logic
                // CRITICAL: Use currMidi directly (not captured) so it reflects current state during modifications
                var capturedRequiredPcs = requiredPcs;
                System.Func<int[], int, int, bool> CanModifyVoice = (int[] voicesArray, int voiceIdx, int newPc) =>
                {
                    if (capturedRequiredPcs == null || !capturedRequiredPcs.Contains(newPc))
                        return true; // Not a required tone, can modify
                    // Check if another voice already has this PC in the CURRENT state
                    for (int otherIdx = 0; otherIdx < voicesArray.Length; otherIdx++)
                    {
                        if (otherIdx != voiceIdx)
                        {
                            int otherPc = (voicesArray[otherIdx] % 12 + 12) % 12;
                            if (otherPc == newPc)
                                return true; // Another voice has it, can modify
                        }
                    }
                    return false; // Unique required tone, cannot modify
                };

                // Get realized pitch classes BEFORE adjustment (for required tone protection)
                var realizedPcsBefore = new HashSet<int>();
                for (int i = 0; i < currMidi.Length; i++)
                {
                    int pc = (currMidi[i] % 12 + 12) % 12;
                    realizedPcsBefore.Add(pc);
                }

                // Adjust each voice
                for (int userVoice = 0; userVoice < 4; userVoice++)
                {
                    int voicesMidiIndex = voiceMapping[userVoice];
                    int old = currMidi[voicesMidiIndex];
                    int oldPc = (old % 12 + 12) % 12;
                    int now = old;

                    // Get range for this voice (user indexing: 0=soprano, 3=bass)
                    int minMidi = cfg.MinMidiByVoice[userVoice];
                    int maxMidi = cfg.MaxMidiByVoice[userVoice];

                    // CRITICAL: Check if this voice carries a required tone
                    // If it does, we can only modify it if another voice already has the same required PC
                    // IMPORTANT: Check BEFORE modification - if this is the ONLY voice with this required PC, we cannot modify it
                    bool voiceCarriesRequiredTone = capturedRequiredPcs != null && capturedRequiredPcs.Contains(oldPc);
                    bool isOnlyVoiceWithRequiredPc = false;
                    if (voiceCarriesRequiredTone)
                    {
                        // Count how many voices currently have this required PC
                        int countWithRequiredPc = 0;
                        for (int checkIdx = 0; checkIdx < currMidi.Length; checkIdx++)
                        {
                            int checkPc = (currMidi[checkIdx] % 12 + 12) % 12;
                            if (checkPc == oldPc)
                                countWithRequiredPc++;
                        }
                        isOnlyVoiceWithRequiredPc = (countWithRequiredPc == 1);
                    }
                    bool canModifyThisVoice = !voiceCarriesRequiredTone || !isOnlyVoiceWithRequiredPc;

                    if (prevMidi == null)
                    {
                        // First chord: shift by octaves to get into range, preserving pitch class
                        // CRITICAL: Only allow modification if voice doesn't carry a unique required tone
                        if (canModifyThisVoice)
                        {
                            // DIAGNOSTIC: Log first chord adjustment
                            if (chordIndex == 0)
                            {
                                string voiceName = userVoice == 0 ? "Soprano" : userVoice == 1 ? "Alto" : userVoice == 2 ? "Tenor" : "Bass";
                                int newPc = oldPc; // Will be same after shift
                                now = ShiftToRangePreservingPitchClass(now, minMidi, maxMidi);
                                
                                if (now != old)
                                {
                                    UnityEngine.Debug.Log(
                                        $"[CONTINUITY_ADJUST_DIAG] First chord (chordIndex=0) {voiceName} (userVoice={userVoice}, voicesMidiIndex={voicesMidiIndex}): " +
                                        $"shifted {old} (pc={oldPc}) -> {now} (pc={newPc}) to fit range [{minMidi}, {maxMidi}]");
                                }
                            }
                            else
                            {
                                now = ShiftToRangePreservingPitchClass(now, minMidi, maxMidi);
                            }
                        }
                        // else: skip adjustment to protect required tone (keep now = old)
                    }
                    else
                    {
                        // Subsequent chords: reduce leaps by octave shifts
                        // CRITICAL: Only allow modification if voice doesn't carry a unique required tone
                        if (canModifyThisVoice)
                        {
                            int prev = prevMidi[userVoice];
                            int leap = Math.Abs(now - prev);

                            while (leap > cfg.MaxLeapSemitones)
                            {
                                // Try shifting by ±12 to reduce the leap
                                int tryUp = now + 12;
                                int tryDown = now - 12;
                                int leapUp = Math.Abs(tryUp - prev);
                                int leapDown = Math.Abs(tryDown - prev);

                                bool upInRange = (tryUp >= minMidi && tryUp <= maxMidi);
                                bool downInRange = (tryDown >= minMidi && tryDown <= maxMidi);

                                int bestNow = now;
                                int bestLeap = leap;
                                bool foundBetter = false;

                                // Prefer the shift that reduces leap the most while staying in range
                                if (upInRange && leapUp < bestLeap)
                                {
                                    bestNow = tryUp;
                                    bestLeap = leapUp;
                                    foundBetter = true;
                                }
                                if (downInRange && leapDown < bestLeap)
                                {
                                    bestNow = tryDown;
                                    bestLeap = leapDown;
                                    foundBetter = true;
                                }

                                if (foundBetter)
                                {
                                    now = bestNow;
                                    leap = bestLeap;
                                }
                                else
                                {
                                    // No better option found - accept the leap
                                    break;
                                }
                            }

                            // Ensure still in range after adjustments, using octave shifts to preserve pitch class
                            now = ShiftToRangePreservingPitchClass(now, minMidi, maxMidi);
                        }
                        // else: skip adjustment to protect required tone (keep now = old)
                    }

                    currMidi[voicesMidiIndex] = now;
                }

                // Enforce no voice crossing (VoicedChord order: [bass, tenor, alto, soprano] = low to high)
                // Ensure: bass <= tenor <= alto <= soprano
                bool hasCrossing = false;
                do
                {
                    hasCrossing = false;

                    // Check bass <= tenor
                    if (currMidi[0] > currMidi[1])
                    {
                        hasCrossing = true;
                        // Try shifting tenor up or bass down by octave
                        int tenorUp = currMidi[1] + 12;
                        int bassDown = currMidi[0] - 12;
                        int tenorMin = cfg.MinMidiByVoice[2]; // tenor = user voice 2
                        int tenorMax = cfg.MaxMidiByVoice[2];
                        int bassMin = cfg.MinMidiByVoice[3]; // bass = user voice 3
                        int bassMax = cfg.MaxMidiByVoice[3];

                        // Enforce absolute minimum of B1 (MIDI 35) to prevent inaudible notes
                        const int absoluteBassMinMidi = 35; // B1
                        if (bassMin < absoluteBassMinMidi)
                        {
                            bassMin = absoluteBassMinMidi;
                        }

                        int tenorUpPc = (tenorUp % 12 + 12) % 12;
                        int bassDownPc = (bassDown % 12 + 12) % 12;

                        bool canShiftTenorUp = (tenorUp <= tenorMax && tenorUp < currMidi[2]) && CanModifyVoice(currMidi, 1, tenorUpPc);
                        bool canShiftBassDown = (bassDown >= bassMin) && CanModifyVoice(currMidi, 0, bassDownPc);

                        if (canShiftTenorUp)
                        {
                            currMidi[1] = tenorUp;
                        }
                        else if (canShiftBassDown)
                        {
                            currMidi[0] = bassDown;
                        }
                        else
                        {
                            // Can't fix - leave mild crossing to protect required tones
                            break;
                        }
                    }

                    // Check tenor <= alto
                    if (currMidi[1] > currMidi[2])
                    {
                        hasCrossing = true;
                        int altoUp = currMidi[2] + 12;
                        int tenorDown = currMidi[1] - 12;
                        int altoMin = cfg.MinMidiByVoice[1]; // alto = user voice 1
                        int altoMax = cfg.MaxMidiByVoice[1];
                        int tenorMin = cfg.MinMidiByVoice[2];
                        int tenorMax = cfg.MaxMidiByVoice[2];

                        int altoUpPc = (altoUp % 12 + 12) % 12;
                        int tenorDownPc = (tenorDown % 12 + 12) % 12;

                        bool canShiftAltoUp = (altoUp <= altoMax && altoUp <= currMidi[3]) && CanModifyVoice(currMidi, 2, altoUpPc);
                        bool canShiftTenorDown = (tenorDown >= tenorMin && tenorDown >= currMidi[0]) && CanModifyVoice(currMidi, 1, tenorDownPc);

                        if (canShiftAltoUp)
                        {
                            currMidi[2] = altoUp;
                        }
                        else if (canShiftTenorDown)
                        {
                            currMidi[1] = tenorDown;
                        }
                        else
                        {
                            break; // Can't fix - protect required tones
                        }
                    }

                    // Check alto <= soprano
                    if (currMidi[2] > currMidi[3])
                    {
                        hasCrossing = true;
                        int sopranoUp = currMidi[3] + 12;
                        int altoDown = currMidi[2] - 12;
                        int sopranoMin = cfg.MinMidiByVoice[0]; // soprano = user voice 0
                        int sopranoMax = cfg.MaxMidiByVoice[0];
                        int altoMin = cfg.MinMidiByVoice[1];
                        int altoMax = cfg.MaxMidiByVoice[1];

                        int sopranoUpPc = (sopranoUp % 12 + 12) % 12;
                        int altoDownPc = (altoDown % 12 + 12) % 12;

                        bool canShiftSopranoUp = (sopranoUp <= sopranoMax) && CanModifyVoice(currMidi, 3, sopranoUpPc);
                        bool canShiftAltoDown = (altoDown >= altoMin && altoDown >= currMidi[1]) && CanModifyVoice(currMidi, 2, altoDownPc);

                        if (canShiftSopranoUp)
                        {
                            currMidi[3] = sopranoUp;
                        }
                        else if (canShiftAltoDown)
                        {
                            currMidi[2] = altoDown;
                        }
                        else
                        {
                            break; // Can't fix - protect required tones
                        }
                    }
                } while (hasCrossing);

                // DIAGNOSTIC: Log after adjustment for step 0 and step 1
                if (chordIndex <= 1)
                {
                    var afterPcs = new List<int>();
                    for (int i = 0; i < currMidi.Length; i++)
                    {
                        afterPcs.Add((currMidi[i] % 12 + 12) % 12);
                    }
                    
                    UnityEngine.Debug.Log(
                        $"[CONTINUITY_ADJUST_DIAG] === AFTER adjustment chordIndex={chordIndex} ===\n" +
                        $"  AFTER: VoicesMidi (BTAS): [{string.Join(", ", currMidi)}]\n" +
                        $"  pitch classes: [{string.Join(", ", afterPcs)}]");
                }
                
                // CRITICAL FIX: Enforce strict SATB ordering after continuity adjustment
                // This ensures Alto > Soprano violations are corrected via octave-only shifts
                // CRITICAL: Pass voice ranges to prefer lowering inner voices over raising Soprano
                // This prevents undoing continuity adjustments that lowered Soprano (e.g., 82→70)
                // CRITICAL: Pass requiredPcs to protect required chord tones from being removed
                int[] minMidiByVoiceBTAS = new int[] { cfg.MinMidiByVoice[3], cfg.MinMidiByVoice[2], cfg.MinMidiByVoice[1], cfg.MinMidiByVoice[0] }; // Map user order to BTAS
                int[] maxMidiByVoiceBTAS = new int[] { cfg.MaxMidiByVoice[3], cfg.MaxMidiByVoice[2], cfg.MaxMidiByVoice[1], cfg.MaxMidiByVoice[0] };
                EnforceVoiceOrderingBTAS(currMidi, minMidiByVoiceBTAS, maxMidiByVoiceBTAS, requiredPcs);
                
                // STAGE SNAPSHOT: PostEnforceVoiceOrderingBTAS for diminished triads
                if (chordEventNullable.HasValue)
                {
                    ChordEvent dimTriadChordEvent = chordEventNullable.Value;
                    if (dimTriadChordEvent.Recipe.Quality == ChordQuality.Diminished)
                    {
                        bool dimTriadHasSeventh = dimTriadChordEvent.Recipe.Extension == ChordExtension.Seventh &&
                                                  dimTriadChordEvent.Recipe.SeventhQuality != SeventhQuality.None;
                        if (!dimTriadHasSeventh) // Only triads, not dim7
                        {
                            var dimTriadChordTonePcs = GetChordTonePitchClasses(dimTriadChordEvent);
                            if (dimTriadChordTonePcs != null && dimTriadChordTonePcs.Count >= 3)
                            {
                                int dimTriadRootPc = dimTriadChordTonePcs[0];
                                int dimTriadThirdPc = dimTriadChordTonePcs[1];
                                int dimTriadFifthPc = dimTriadChordTonePcs[2];
                                int dimTriadThirdInterval = (dimTriadThirdPc - dimTriadRootPc + 12) % 12;
                                int dimTriadFifthInterval = (dimTriadFifthPc - dimTriadRootPc + 12) % 12;
                                if (dimTriadThirdInterval == 3 && dimTriadFifthInterval == 6) // Valid dim triad
                                {
                                    var requiredIdentityPcs = new HashSet<int> { dimTriadRootPc, dimTriadThirdPc, dimTriadFifthPc };
                                    string dimTriadChordToken = TheoryChord.RecipeToRomanNumeral(dimTriadChordEvent.Key, dimTriadChordEvent.Recipe);
                                    LogStageSnapshot_DimTriad(
                                        "PostEnforceVoiceOrderingBTAS",
                                        chordIndex,
                                        dimTriadChordToken,
                                        dimTriadChordToken,
                                        currMidi,
                                        requiredIdentityPcs,
                                        dimTriadChordEvent.Key);
                                }
                            }
                        }
                    }
                }
                
                // CRITICAL: After EnforceVoiceOrderingBTAS, verify required tones are still present
                // If any are missing, emit a warning (but don't auto-repair to avoid ping-pong)
                if (chordEventNullable.HasValue && requiredPcs != null && requiredPcs.Count > 0)
                {
                    var realizedPcsAfterOrdering = new HashSet<int>();
                    for (int i = 0; i < currMidi.Length; i++)
                    {
                        int pc = (currMidi[i] % 12 + 12) % 12;
                        realizedPcsAfterOrdering.Add(pc);
                    }

                    var missingRequiredPcs = new List<int>();
                    foreach (int requiredPc in requiredPcs)
                    {
                        if (!realizedPcsAfterOrdering.Contains(requiredPc))
                        {
                            missingRequiredPcs.Add(requiredPc);
                        }
                    }

                    if (missingRequiredPcs.Count > 0)
                    {
                        string chordToken = TheoryChord.RecipeToRomanNumeral(chordEvent.Key, chordEvent.Recipe);
                        string missingPcsStr = string.Join(", ", missingRequiredPcs);
                        string voicesStr = $"B={currMidi[0]}, T={currMidi[1]}, A={currMidi[2]}, S={currMidi[3]}";
                        string realizedPcsStr = string.Join(", ", realizedPcsAfterOrdering.OrderBy(pc => pc));
                        
                        UnityEngine.Debug.LogWarning(
                            $"[REQUIRED_TONE_VIOLATION] step={chordIndex} chord={chordToken}: " +
                            $"Required chord tone(s) missing after EnforceVoiceOrderingBTAS! " +
                            $"Missing PCs: [{missingPcsStr}]. " +
                            $"Required PCs: [{string.Join(", ", requiredPcs.OrderBy(pc => pc))}]. " +
                            $"Realized PCs: [{realizedPcsStr}]. " +
                            $"Voices: {voicesStr}. " +
                            $"Ordering pass protected required tones but could not satisfy ordering without breaking coverage. " +
                            $"This may indicate a minor ordering violation was accepted to preserve identity tones.");
                    }
                }
                
                // CHECKPOINT D: After continuity/register compression
                if (s_debugSharp9OctaveTrace && chordIndex == 0)
                {
                    if (voicedChords != null && chordIndex < voicedChords.Count)
                    {
                        // We need to get the chord event - it's not directly available here
                        // But we can check the voicing for #9
                        int[] currMidiForTrace = currMidi;
                        // Try to infer from context - for now, log what we have
                        int b = currMidiForTrace.Length > 0 ? currMidiForTrace[0] : -1;
                        int t = currMidiForTrace.Length > 1 ? currMidiForTrace[1] : -1;
                        int a = currMidiForTrace.Length > 2 ? currMidiForTrace[2] : -1;
                        int s = currMidiForTrace.Length > 3 ? currMidiForTrace[3] : -1;
                        // Check for #9 PC (10 for G7#9)
                        bool containsPc10 = false;
                        string laneWithSharp9 = "none";
                        int midiWithSharp9 = -1;
                        for (int v = 0; v < currMidiForTrace.Length; v++)
                        {
                            int voicePc = (currMidiForTrace[v] % 12 + 12) % 12;
                            if (voicePc == 10) // A#/Bb PC for G root
                            {
                                containsPc10 = true;
                                laneWithSharp9 = v == 0 ? "B" : v == 1 ? "T" : v == 2 ? "A" : "S";
                                midiWithSharp9 = currMidiForTrace[v];
                                break;
                            }
                        }
                        // We don't have key/chordEvent here, so use generic pitch name
                        string pitchName = midiWithSharp9 >= 0 ? $"MIDI{midiWithSharp9}" : "none";
                        UnityEngine.Debug.Log(
                            $"[SHARP9_TRACE][POST_CONTINUITY] step=0 chordIndex={chordIndex} B={b} T={t} A={a} S={s} containsPc10={containsPc10} laneWithSharp9={laneWithSharp9} midi={midiWithSharp9}({pitchName})");
                    }
                }
                
                // CRITICAL: Check BTAS invariant after continuity adjustment and ordering enforcement
                if (currMidi != null && currMidi.Length >= 2)
                {
                    string chordLabel = $"chordIndex={chordIndex}";
                    CheckAndLogBTASInvariant(currMidi, chordIndex, chordLabel);
                }
                
                // Debug assert: verify ordering is never violated after adjustment
                #if UNITY_EDITOR
                if (ViolatesVoiceOrdering(currMidi))
                {
                    UnityEngine.Debug.LogError(
                        $"[VOICE_ORDERING_ASSERT] CRITICAL: Voice ordering violation after AdjustPlayVoicingForContinuity (chordIndex={chordIndex})!\n" +
                        $"  Voices (BTAS): [{string.Join(", ", currMidi)}]\n" +
                        $"  Bass={currMidi[0]}, Tenor={currMidi[1]}, Alto={currMidi[2]}, Soprano={currMidi[3]}\n" +
                        $"  Violations: B>T={currMidi[0] > currMidi[1]}, T>A={currMidi[1] > currMidi[2]}, A>S={currMidi[2] > currMidi[3]}");
                }
                #endif
                
                // Update the voiced chord with adjusted MIDI
                voicedChords[chordIndex] = new VoicedChord
                {
                    TimeBeats = voiced.TimeBeats,
                    VoicesMidi = currMidi
                };

                // Update prevMidi for next iteration (using user indexing for consistency)
                prevMidi = new int[4];
                prevMidi[0] = currMidi[3]; // soprano
                prevMidi[1] = currMidi[2]; // alto
                prevMidi[2] = currMidi[1]; // tenor
                prevMidi[3] = currMidi[0]; // bass
            }
        }
        
        /// <summary>
        /// Computes soft cost adjustments for 11th tension voicing heuristics (soprano-only, v1).
        /// When soprano is natural 11: penalizes presence of 3rd in inner voices (sus bias), bonuses omission.
        /// When soprano is #11: penalizes 3rd too close to soprano (register separation).
        /// </summary>
        /// <param name="current">Current chord event</param>
        /// <param name="sopranoMidi">Soprano MIDI note</param>
        /// <param name="bassMidi">Bass MIDI note</param>
        /// <param name="tenorMidi">Tenor MIDI note</param>
        /// <param name="altoMidi">Alto MIDI note</param>
        /// <param name="chordTonePcs">Chord tone pitch classes [root, 3rd, 5th, 7th?]</param>
        /// <returns>Cost adjustment (positive = penalty, negative = bonus)</returns>
        private static float ComputeEleventhTensionCostAdjustment(
            ChordEvent current,
            int sopranoMidi,
            int bassMidi,
            int tenorMidi,
            int altoMidi,
            List<int> chordTonePcs)
        {
            if (!s_enableEleventhHeuristics || chordTonePcs == null || chordTonePcs.Count < 2)
                return 0f;
            
            // Get root and 3rd pitch classes
            int rootPc = chordTonePcs[0];
            int thirdPc = chordTonePcs[1];
            
            // Check if soprano is an 11th tension
            int sopranoPc = ((sopranoMidi % 12) + 12) % 12;
            int rel = (sopranoPc - rootPc + 12) % 12;
            
            bool isEleven = false;
            bool isSharpEleven = false;
            
            if (ChordTensionUtils.TryGetEleventhTensionKindFromInterval(rel, out TensionKind kind))
            {
                isEleven = (kind == TensionKind.Eleven);
                isSharpEleven = (kind == TensionKind.SharpEleven);
            }
            
            if (!isEleven && !isSharpEleven)
                return 0f; // Soprano is not an 11th tension
            
            float adjustment = 0f;
            
            // Check if 3rd is present in inner voices (Alto, Tenor, or Bass)
            bool thirdPresent = false;
            int minDistanceToSoprano = int.MaxValue;
            
            // Check inner voices (Bass, Tenor, Alto)
            int[] innerVoices = { bassMidi, tenorMidi, altoMidi };
            foreach (int voiceMidi in innerVoices)
            {
                int voicePc = ((voiceMidi % 12) + 12) % 12;
                if (voicePc == thirdPc)
                {
                    thirdPresent = true;
                    int distanceToSoprano = Math.Abs(voiceMidi - sopranoMidi);
                    if (distanceToSoprano < minDistanceToSoprano)
                    {
                        minDistanceToSoprano = distanceToSoprano;
                    }
                }
            }
            
            if (isEleven)
            {
                // Natural 11: sus bias
                if (thirdPresent)
                {
                    // Penalty based on chord quality
                    bool isMajor = current.Recipe.Quality == ChordQuality.Major;
                    bool isDominant = current.Recipe.Extension == ChordExtension.Seventh &&
                                     (current.Recipe.SeventhQuality == SeventhQuality.Dominant7 ||
                                      current.Recipe.SeventhQuality == SeventhQuality.Major7);
                    bool isMinor = current.Recipe.Quality == ChordQuality.Minor;
                    
                    if (isMajor)
                    {
                        adjustment += s_penalty_11_withThird_Maj;
                    }
                    else if (isDominant)
                    {
                        adjustment += s_penalty_11_withThird_Dom;
                    }
                    else if (isMinor)
                    {
                        adjustment += s_penalty_11_withThird_Min;
                    }
                }
                else
                {
                    // Bonus for omitting 3rd (only if omission is already allowed by coverage logic)
                    // Check if root is still present (required tone)
                    bool rootPresent = false;
                    foreach (int voiceMidi in innerVoices)
                    {
                        int voicePc = ((voiceMidi % 12) + 12) % 12;
                        if (voicePc == rootPc)
                        {
                            rootPresent = true;
                            break;
                        }
                    }
                    
                    // Only apply bonus if root is present (coverage is satisfied)
                    if (rootPresent)
                    {
                        adjustment += s_bonus_11_withoutThird;
                    }
                }
            }
            else if (isSharpEleven)
            {
                // #11: register separation preference
                if (thirdPresent && minDistanceToSoprano <= 12)
                {
                    // 3rd is within 12 semitones of soprano - apply penalty
                    adjustment += s_penalty_sharp11_closeToThirdWithinOctave;
                }
            }
            
            return adjustment;
        }
    }
}


